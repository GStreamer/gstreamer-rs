// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// from gst-gir-files (https://gitlab.freedesktop.org/gstreamer/gir-files-rs.git)
// DO NOT EDIT

use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstRTCPFBType")]
pub enum RTCPFBType {
    #[doc(alias = "GST_RTCP_FB_TYPE_INVALID")]
    FbTypeInvalid,
    #[doc(alias = "GST_RTCP_RTPFB_TYPE_NACK")]
    RtpfbTypeNack,
    #[doc(alias = "GST_RTCP_RTPFB_TYPE_TMMBR")]
    RtpfbTypeTmmbr,
    #[doc(alias = "GST_RTCP_RTPFB_TYPE_TMMBN")]
    RtpfbTypeTmmbn,
    #[doc(alias = "GST_RTCP_RTPFB_TYPE_RTCP_SR_REQ")]
    RtpfbTypeRtcpSrReq,
    #[doc(alias = "GST_RTCP_RTPFB_TYPE_TWCC")]
    RtpfbTypeTwcc,
    #[doc(alias = "GST_RTCP_PSFB_TYPE_SLI")]
    PsfbTypeSli,
    #[doc(alias = "GST_RTCP_PSFB_TYPE_TSTN")]
    PsfbTypeTstn,
    #[doc(alias = "GST_RTCP_PSFB_TYPE_VBCN")]
    PsfbTypeVbcn,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for RTCPFBType {
    type GlibType = ffi::GstRTCPFBType;

    fn to_glib(&self) -> ffi::GstRTCPFBType {
        match *self {
            RTCPFBType::FbTypeInvalid => ffi::GST_RTCP_FB_TYPE_INVALID,
            RTCPFBType::RtpfbTypeNack => ffi::GST_RTCP_RTPFB_TYPE_NACK,
            RTCPFBType::RtpfbTypeTmmbr => ffi::GST_RTCP_RTPFB_TYPE_TMMBR,
            RTCPFBType::RtpfbTypeTmmbn => ffi::GST_RTCP_RTPFB_TYPE_TMMBN,
            RTCPFBType::RtpfbTypeRtcpSrReq => ffi::GST_RTCP_RTPFB_TYPE_RTCP_SR_REQ,
            RTCPFBType::RtpfbTypeTwcc => ffi::GST_RTCP_RTPFB_TYPE_TWCC,
            RTCPFBType::PsfbTypeSli => ffi::GST_RTCP_PSFB_TYPE_SLI,
            RTCPFBType::PsfbTypeTstn => ffi::GST_RTCP_PSFB_TYPE_TSTN,
            RTCPFBType::PsfbTypeVbcn => ffi::GST_RTCP_PSFB_TYPE_VBCN,
            RTCPFBType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstRTCPFBType> for RTCPFBType {
    unsafe fn from_glib(value: ffi::GstRTCPFBType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RTCPFBType::FbTypeInvalid,
            1 => RTCPFBType::RtpfbTypeNack,
            3 => RTCPFBType::RtpfbTypeTmmbr,
            4 => RTCPFBType::RtpfbTypeTmmbn,
            5 => RTCPFBType::RtpfbTypeRtcpSrReq,
            15 => RTCPFBType::RtpfbTypeTwcc,
            2 => RTCPFBType::PsfbTypeSli,
            6 => RTCPFBType::PsfbTypeTstn,
            7 => RTCPFBType::PsfbTypeVbcn,
            value => RTCPFBType::__Unknown(value),
        }
    }
}

impl StaticType for RTCPFBType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_rtcpfb_type_get_type()) }
    }
}

impl glib::value::ValueType for RTCPFBType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for RTCPFBType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RTCPFBType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<RTCPFBType>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.to_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstRTCPSDESType")]
pub enum RTCPSDESType {
    #[doc(alias = "GST_RTCP_SDES_INVALID")]
    Invalid,
    #[doc(alias = "GST_RTCP_SDES_END")]
    End,
    #[doc(alias = "GST_RTCP_SDES_CNAME")]
    Cname,
    #[doc(alias = "GST_RTCP_SDES_NAME")]
    Name,
    #[doc(alias = "GST_RTCP_SDES_EMAIL")]
    Email,
    #[doc(alias = "GST_RTCP_SDES_PHONE")]
    Phone,
    #[doc(alias = "GST_RTCP_SDES_LOC")]
    Loc,
    #[doc(alias = "GST_RTCP_SDES_TOOL")]
    Tool,
    #[doc(alias = "GST_RTCP_SDES_NOTE")]
    Note,
    #[doc(alias = "GST_RTCP_SDES_PRIV")]
    Priv,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for RTCPSDESType {
    type GlibType = ffi::GstRTCPSDESType;

    fn to_glib(&self) -> ffi::GstRTCPSDESType {
        match *self {
            RTCPSDESType::Invalid => ffi::GST_RTCP_SDES_INVALID,
            RTCPSDESType::End => ffi::GST_RTCP_SDES_END,
            RTCPSDESType::Cname => ffi::GST_RTCP_SDES_CNAME,
            RTCPSDESType::Name => ffi::GST_RTCP_SDES_NAME,
            RTCPSDESType::Email => ffi::GST_RTCP_SDES_EMAIL,
            RTCPSDESType::Phone => ffi::GST_RTCP_SDES_PHONE,
            RTCPSDESType::Loc => ffi::GST_RTCP_SDES_LOC,
            RTCPSDESType::Tool => ffi::GST_RTCP_SDES_TOOL,
            RTCPSDESType::Note => ffi::GST_RTCP_SDES_NOTE,
            RTCPSDESType::Priv => ffi::GST_RTCP_SDES_PRIV,
            RTCPSDESType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstRTCPSDESType> for RTCPSDESType {
    unsafe fn from_glib(value: ffi::GstRTCPSDESType) -> Self {
        skip_assert_initialized!();
        match value {
            -1 => RTCPSDESType::Invalid,
            0 => RTCPSDESType::End,
            1 => RTCPSDESType::Cname,
            2 => RTCPSDESType::Name,
            3 => RTCPSDESType::Email,
            4 => RTCPSDESType::Phone,
            5 => RTCPSDESType::Loc,
            6 => RTCPSDESType::Tool,
            7 => RTCPSDESType::Note,
            8 => RTCPSDESType::Priv,
            value => RTCPSDESType::__Unknown(value),
        }
    }
}

impl StaticType for RTCPSDESType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_rtcpsdes_type_get_type()) }
    }
}

impl glib::value::ValueType for RTCPSDESType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for RTCPSDESType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RTCPSDESType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<RTCPSDESType>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.to_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstRTCPType")]
pub enum RTCPType {
    #[doc(alias = "GST_RTCP_TYPE_INVALID")]
    Invalid,
    #[doc(alias = "GST_RTCP_TYPE_SR")]
    Sr,
    #[doc(alias = "GST_RTCP_TYPE_RR")]
    Rr,
    #[doc(alias = "GST_RTCP_TYPE_SDES")]
    Sdes,
    #[doc(alias = "GST_RTCP_TYPE_BYE")]
    Bye,
    #[doc(alias = "GST_RTCP_TYPE_APP")]
    App,
    #[doc(alias = "GST_RTCP_TYPE_RTPFB")]
    Rtpfb,
    #[doc(alias = "GST_RTCP_TYPE_PSFB")]
    Psfb,
    #[doc(alias = "GST_RTCP_TYPE_XR")]
    Xr,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for RTCPType {
    type GlibType = ffi::GstRTCPType;

    fn to_glib(&self) -> ffi::GstRTCPType {
        match *self {
            RTCPType::Invalid => ffi::GST_RTCP_TYPE_INVALID,
            RTCPType::Sr => ffi::GST_RTCP_TYPE_SR,
            RTCPType::Rr => ffi::GST_RTCP_TYPE_RR,
            RTCPType::Sdes => ffi::GST_RTCP_TYPE_SDES,
            RTCPType::Bye => ffi::GST_RTCP_TYPE_BYE,
            RTCPType::App => ffi::GST_RTCP_TYPE_APP,
            RTCPType::Rtpfb => ffi::GST_RTCP_TYPE_RTPFB,
            RTCPType::Psfb => ffi::GST_RTCP_TYPE_PSFB,
            RTCPType::Xr => ffi::GST_RTCP_TYPE_XR,
            RTCPType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstRTCPType> for RTCPType {
    unsafe fn from_glib(value: ffi::GstRTCPType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RTCPType::Invalid,
            200 => RTCPType::Sr,
            201 => RTCPType::Rr,
            202 => RTCPType::Sdes,
            203 => RTCPType::Bye,
            204 => RTCPType::App,
            205 => RTCPType::Rtpfb,
            206 => RTCPType::Psfb,
            207 => RTCPType::Xr,
            value => RTCPType::__Unknown(value),
        }
    }
}

impl StaticType for RTCPType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_rtcp_type_get_type()) }
    }
}

impl glib::value::ValueType for RTCPType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for RTCPType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RTCPType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<RTCPType>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.to_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstRTCPXRType")]
pub enum RTCPXRType {
    #[doc(alias = "GST_RTCP_XR_TYPE_INVALID")]
    Invalid,
    #[doc(alias = "GST_RTCP_XR_TYPE_LRLE")]
    Lrle,
    #[doc(alias = "GST_RTCP_XR_TYPE_DRLE")]
    Drle,
    #[doc(alias = "GST_RTCP_XR_TYPE_PRT")]
    Prt,
    #[doc(alias = "GST_RTCP_XR_TYPE_RRT")]
    Rrt,
    #[doc(alias = "GST_RTCP_XR_TYPE_DLRR")]
    Dlrr,
    #[doc(alias = "GST_RTCP_XR_TYPE_SSUMM")]
    Ssumm,
    #[doc(alias = "GST_RTCP_XR_TYPE_VOIP_METRICS")]
    VoipMetrics,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl ToGlib for RTCPXRType {
    type GlibType = ffi::GstRTCPXRType;

    fn to_glib(&self) -> ffi::GstRTCPXRType {
        match *self {
            RTCPXRType::Invalid => ffi::GST_RTCP_XR_TYPE_INVALID,
            RTCPXRType::Lrle => ffi::GST_RTCP_XR_TYPE_LRLE,
            RTCPXRType::Drle => ffi::GST_RTCP_XR_TYPE_DRLE,
            RTCPXRType::Prt => ffi::GST_RTCP_XR_TYPE_PRT,
            RTCPXRType::Rrt => ffi::GST_RTCP_XR_TYPE_RRT,
            RTCPXRType::Dlrr => ffi::GST_RTCP_XR_TYPE_DLRR,
            RTCPXRType::Ssumm => ffi::GST_RTCP_XR_TYPE_SSUMM,
            RTCPXRType::VoipMetrics => ffi::GST_RTCP_XR_TYPE_VOIP_METRICS,
            RTCPXRType::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl FromGlib<ffi::GstRTCPXRType> for RTCPXRType {
    unsafe fn from_glib(value: ffi::GstRTCPXRType) -> Self {
        skip_assert_initialized!();
        match value {
            -1 => RTCPXRType::Invalid,
            1 => RTCPXRType::Lrle,
            2 => RTCPXRType::Drle,
            3 => RTCPXRType::Prt,
            4 => RTCPXRType::Rrt,
            5 => RTCPXRType::Dlrr,
            6 => RTCPXRType::Ssumm,
            7 => RTCPXRType::VoipMetrics,
            value => RTCPXRType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
impl StaticType for RTCPXRType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_rtcpxr_type_get_type()) }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
impl glib::value::ValueType for RTCPXRType {
    type Type = Self;
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
unsafe impl<'a> FromValue<'a> for RTCPXRType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_16")))]
impl ToValue for RTCPXRType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<RTCPXRType>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.to_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstRTPPayload")]
pub enum RTPPayload {
    #[doc(alias = "GST_RTP_PAYLOAD_PCMU")]
    Pcmu,
    #[doc(alias = "GST_RTP_PAYLOAD_1016")]
    _1016,
    #[doc(alias = "GST_RTP_PAYLOAD_G721")]
    G721,
    #[doc(alias = "GST_RTP_PAYLOAD_GSM")]
    Gsm,
    #[doc(alias = "GST_RTP_PAYLOAD_G723")]
    G723,
    #[doc(alias = "GST_RTP_PAYLOAD_DVI4_8000")]
    Dvi48000,
    #[doc(alias = "GST_RTP_PAYLOAD_DVI4_16000")]
    Dvi416000,
    #[doc(alias = "GST_RTP_PAYLOAD_LPC")]
    Lpc,
    #[doc(alias = "GST_RTP_PAYLOAD_PCMA")]
    Pcma,
    #[doc(alias = "GST_RTP_PAYLOAD_G722")]
    G722,
    #[doc(alias = "GST_RTP_PAYLOAD_L16_STEREO")]
    L16Stereo,
    #[doc(alias = "GST_RTP_PAYLOAD_L16_MONO")]
    L16Mono,
    #[doc(alias = "GST_RTP_PAYLOAD_QCELP")]
    Qcelp,
    #[doc(alias = "GST_RTP_PAYLOAD_CN")]
    Cn,
    #[doc(alias = "GST_RTP_PAYLOAD_MPA")]
    Mpa,
    #[doc(alias = "GST_RTP_PAYLOAD_G728")]
    G728,
    #[doc(alias = "GST_RTP_PAYLOAD_DVI4_11025")]
    Dvi411025,
    #[doc(alias = "GST_RTP_PAYLOAD_DVI4_22050")]
    Dvi422050,
    #[doc(alias = "GST_RTP_PAYLOAD_G729")]
    G729,
    #[doc(alias = "GST_RTP_PAYLOAD_CELLB")]
    Cellb,
    #[doc(alias = "GST_RTP_PAYLOAD_JPEG")]
    Jpeg,
    #[doc(alias = "GST_RTP_PAYLOAD_NV")]
    Nv,
    #[doc(alias = "GST_RTP_PAYLOAD_H261")]
    H261,
    #[doc(alias = "GST_RTP_PAYLOAD_MPV")]
    Mpv,
    #[doc(alias = "GST_RTP_PAYLOAD_MP2T")]
    Mp2t,
    #[doc(alias = "GST_RTP_PAYLOAD_H263")]
    H263,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for RTPPayload {
    type GlibType = ffi::GstRTPPayload;

    fn to_glib(&self) -> ffi::GstRTPPayload {
        match *self {
            RTPPayload::Pcmu => ffi::GST_RTP_PAYLOAD_PCMU,
            RTPPayload::_1016 => ffi::GST_RTP_PAYLOAD_1016,
            RTPPayload::G721 => ffi::GST_RTP_PAYLOAD_G721,
            RTPPayload::Gsm => ffi::GST_RTP_PAYLOAD_GSM,
            RTPPayload::G723 => ffi::GST_RTP_PAYLOAD_G723,
            RTPPayload::Dvi48000 => ffi::GST_RTP_PAYLOAD_DVI4_8000,
            RTPPayload::Dvi416000 => ffi::GST_RTP_PAYLOAD_DVI4_16000,
            RTPPayload::Lpc => ffi::GST_RTP_PAYLOAD_LPC,
            RTPPayload::Pcma => ffi::GST_RTP_PAYLOAD_PCMA,
            RTPPayload::G722 => ffi::GST_RTP_PAYLOAD_G722,
            RTPPayload::L16Stereo => ffi::GST_RTP_PAYLOAD_L16_STEREO,
            RTPPayload::L16Mono => ffi::GST_RTP_PAYLOAD_L16_MONO,
            RTPPayload::Qcelp => ffi::GST_RTP_PAYLOAD_QCELP,
            RTPPayload::Cn => ffi::GST_RTP_PAYLOAD_CN,
            RTPPayload::Mpa => ffi::GST_RTP_PAYLOAD_MPA,
            RTPPayload::G728 => ffi::GST_RTP_PAYLOAD_G728,
            RTPPayload::Dvi411025 => ffi::GST_RTP_PAYLOAD_DVI4_11025,
            RTPPayload::Dvi422050 => ffi::GST_RTP_PAYLOAD_DVI4_22050,
            RTPPayload::G729 => ffi::GST_RTP_PAYLOAD_G729,
            RTPPayload::Cellb => ffi::GST_RTP_PAYLOAD_CELLB,
            RTPPayload::Jpeg => ffi::GST_RTP_PAYLOAD_JPEG,
            RTPPayload::Nv => ffi::GST_RTP_PAYLOAD_NV,
            RTPPayload::H261 => ffi::GST_RTP_PAYLOAD_H261,
            RTPPayload::Mpv => ffi::GST_RTP_PAYLOAD_MPV,
            RTPPayload::Mp2t => ffi::GST_RTP_PAYLOAD_MP2T,
            RTPPayload::H263 => ffi::GST_RTP_PAYLOAD_H263,
            RTPPayload::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstRTPPayload> for RTPPayload {
    unsafe fn from_glib(value: ffi::GstRTPPayload) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RTPPayload::Pcmu,
            1 => RTPPayload::_1016,
            2 => RTPPayload::G721,
            3 => RTPPayload::Gsm,
            4 => RTPPayload::G723,
            5 => RTPPayload::Dvi48000,
            6 => RTPPayload::Dvi416000,
            7 => RTPPayload::Lpc,
            8 => RTPPayload::Pcma,
            9 => RTPPayload::G722,
            10 => RTPPayload::L16Stereo,
            11 => RTPPayload::L16Mono,
            12 => RTPPayload::Qcelp,
            13 => RTPPayload::Cn,
            14 => RTPPayload::Mpa,
            15 => RTPPayload::G728,
            16 => RTPPayload::Dvi411025,
            17 => RTPPayload::Dvi422050,
            18 => RTPPayload::G729,
            25 => RTPPayload::Cellb,
            26 => RTPPayload::Jpeg,
            28 => RTPPayload::Nv,
            31 => RTPPayload::H261,
            32 => RTPPayload::Mpv,
            33 => RTPPayload::Mp2t,
            34 => RTPPayload::H263,
            value => RTPPayload::__Unknown(value),
        }
    }
}

impl StaticType for RTPPayload {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_rtp_payload_get_type()) }
    }
}

impl glib::value::ValueType for RTPPayload {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for RTPPayload {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RTPPayload {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<RTPPayload>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.to_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstRTPProfile")]
pub enum RTPProfile {
    #[doc(alias = "GST_RTP_PROFILE_UNKNOWN")]
    Unknown,
    #[doc(alias = "GST_RTP_PROFILE_AVP")]
    Avp,
    #[doc(alias = "GST_RTP_PROFILE_SAVP")]
    Savp,
    #[doc(alias = "GST_RTP_PROFILE_AVPF")]
    Avpf,
    #[doc(alias = "GST_RTP_PROFILE_SAVPF")]
    Savpf,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for RTPProfile {
    type GlibType = ffi::GstRTPProfile;

    fn to_glib(&self) -> ffi::GstRTPProfile {
        match *self {
            RTPProfile::Unknown => ffi::GST_RTP_PROFILE_UNKNOWN,
            RTPProfile::Avp => ffi::GST_RTP_PROFILE_AVP,
            RTPProfile::Savp => ffi::GST_RTP_PROFILE_SAVP,
            RTPProfile::Avpf => ffi::GST_RTP_PROFILE_AVPF,
            RTPProfile::Savpf => ffi::GST_RTP_PROFILE_SAVPF,
            RTPProfile::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstRTPProfile> for RTPProfile {
    unsafe fn from_glib(value: ffi::GstRTPProfile) -> Self {
        skip_assert_initialized!();
        match value {
            0 => RTPProfile::Unknown,
            1 => RTPProfile::Avp,
            2 => RTPProfile::Savp,
            3 => RTPProfile::Avpf,
            4 => RTPProfile::Savpf,
            value => RTPProfile::__Unknown(value),
        }
    }
}

impl StaticType for RTPProfile {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gst_rtp_profile_get_type()) }
    }
}

impl glib::value::ValueType for RTPProfile {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for RTPProfile {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RTPProfile {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<RTPProfile>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.to_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
