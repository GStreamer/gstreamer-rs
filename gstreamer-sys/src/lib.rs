// This file was generated by gir (https://github.com/gtk-rs/gir @ f5fca82)
// from gir-files (https://github.com/gtk-rs/gir-files @ ???)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![cfg_attr(feature = "cargo-clippy", allow(approx_constant, type_complexity, unreadable_literal))]

extern crate libc;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Aliases
pub type GstClockID = gpointer;
pub type GstClockTime = u64;
pub type GstClockTimeDiff = i64;
pub type GstElementFactoryListType = u64;

// Enums
pub type GstBufferingMode = c_int;
pub const GST_BUFFERING_STREAM: GstBufferingMode = 0;
pub const GST_BUFFERING_DOWNLOAD: GstBufferingMode = 1;
pub const GST_BUFFERING_TIMESHIFT: GstBufferingMode = 2;
pub const GST_BUFFERING_LIVE: GstBufferingMode = 3;

pub type GstBusSyncReply = c_int;
pub const GST_BUS_DROP: GstBusSyncReply = 0;
pub const GST_BUS_PASS: GstBusSyncReply = 1;
pub const GST_BUS_ASYNC: GstBusSyncReply = 2;

pub type GstCapsIntersectMode = c_int;
pub const GST_CAPS_INTERSECT_ZIG_ZAG: GstCapsIntersectMode = 0;
pub const GST_CAPS_INTERSECT_FIRST: GstCapsIntersectMode = 1;

pub type GstClockEntryType = c_int;
pub const GST_CLOCK_ENTRY_SINGLE: GstClockEntryType = 0;
pub const GST_CLOCK_ENTRY_PERIODIC: GstClockEntryType = 1;

pub type GstClockReturn = c_int;
pub const GST_CLOCK_OK: GstClockReturn = 0;
pub const GST_CLOCK_EARLY: GstClockReturn = 1;
pub const GST_CLOCK_UNSCHEDULED: GstClockReturn = 2;
pub const GST_CLOCK_BUSY: GstClockReturn = 3;
pub const GST_CLOCK_BADTIME: GstClockReturn = 4;
pub const GST_CLOCK_ERROR: GstClockReturn = 5;
pub const GST_CLOCK_UNSUPPORTED: GstClockReturn = 6;
pub const GST_CLOCK_DONE: GstClockReturn = 7;

pub type GstClockType = c_int;
pub const GST_CLOCK_TYPE_REALTIME: GstClockType = 0;
pub const GST_CLOCK_TYPE_MONOTONIC: GstClockType = 1;
pub const GST_CLOCK_TYPE_OTHER: GstClockType = 2;

pub type GstCoreError = c_int;
pub const GST_CORE_ERROR_FAILED: GstCoreError = 1;
pub const GST_CORE_ERROR_TOO_LAZY: GstCoreError = 2;
pub const GST_CORE_ERROR_NOT_IMPLEMENTED: GstCoreError = 3;
pub const GST_CORE_ERROR_STATE_CHANGE: GstCoreError = 4;
pub const GST_CORE_ERROR_PAD: GstCoreError = 5;
pub const GST_CORE_ERROR_THREAD: GstCoreError = 6;
pub const GST_CORE_ERROR_NEGOTIATION: GstCoreError = 7;
pub const GST_CORE_ERROR_EVENT: GstCoreError = 8;
pub const GST_CORE_ERROR_SEEK: GstCoreError = 9;
pub const GST_CORE_ERROR_CAPS: GstCoreError = 10;
pub const GST_CORE_ERROR_TAG: GstCoreError = 11;
pub const GST_CORE_ERROR_MISSING_PLUGIN: GstCoreError = 12;
pub const GST_CORE_ERROR_CLOCK: GstCoreError = 13;
pub const GST_CORE_ERROR_DISABLED: GstCoreError = 14;
pub const GST_CORE_ERROR_NUM_ERRORS: GstCoreError = 15;

pub type GstDebugColorMode = c_int;
pub const GST_DEBUG_COLOR_MODE_OFF: GstDebugColorMode = 0;
pub const GST_DEBUG_COLOR_MODE_ON: GstDebugColorMode = 1;
pub const GST_DEBUG_COLOR_MODE_UNIX: GstDebugColorMode = 2;

pub type GstDebugLevel = c_int;
pub const GST_LEVEL_NONE: GstDebugLevel = 0;
pub const GST_LEVEL_ERROR: GstDebugLevel = 1;
pub const GST_LEVEL_WARNING: GstDebugLevel = 2;
pub const GST_LEVEL_FIXME: GstDebugLevel = 3;
pub const GST_LEVEL_INFO: GstDebugLevel = 4;
pub const GST_LEVEL_DEBUG: GstDebugLevel = 5;
pub const GST_LEVEL_LOG: GstDebugLevel = 6;
pub const GST_LEVEL_TRACE: GstDebugLevel = 7;
pub const GST_LEVEL_MEMDUMP: GstDebugLevel = 9;
pub const GST_LEVEL_COUNT: GstDebugLevel = 10;

pub type GstEventType = c_int;
pub const GST_EVENT_UNKNOWN: GstEventType = 0;
pub const GST_EVENT_FLUSH_START: GstEventType = 2563;
pub const GST_EVENT_FLUSH_STOP: GstEventType = 5127;
pub const GST_EVENT_STREAM_START: GstEventType = 10254;
pub const GST_EVENT_CAPS: GstEventType = 12814;
pub const GST_EVENT_SEGMENT: GstEventType = 17934;
pub const GST_EVENT_STREAM_COLLECTION: GstEventType = 19230;
pub const GST_EVENT_TAG: GstEventType = 20510;
pub const GST_EVENT_BUFFERSIZE: GstEventType = 23054;
pub const GST_EVENT_SINK_MESSAGE: GstEventType = 25630;
pub const GST_EVENT_STREAM_GROUP_DONE: GstEventType = 26894;
pub const GST_EVENT_EOS: GstEventType = 28174;
pub const GST_EVENT_TOC: GstEventType = 30750;
pub const GST_EVENT_PROTECTION: GstEventType = 33310;
pub const GST_EVENT_SEGMENT_DONE: GstEventType = 38406;
pub const GST_EVENT_GAP: GstEventType = 40966;
pub const GST_EVENT_QOS: GstEventType = 48641;
pub const GST_EVENT_SEEK: GstEventType = 51201;
pub const GST_EVENT_NAVIGATION: GstEventType = 53761;
pub const GST_EVENT_LATENCY: GstEventType = 56321;
pub const GST_EVENT_STEP: GstEventType = 58881;
pub const GST_EVENT_RECONFIGURE: GstEventType = 61441;
pub const GST_EVENT_TOC_SELECT: GstEventType = 64001;
pub const GST_EVENT_SELECT_STREAMS: GstEventType = 66561;
pub const GST_EVENT_CUSTOM_UPSTREAM: GstEventType = 69121;
pub const GST_EVENT_CUSTOM_DOWNSTREAM: GstEventType = 71686;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_OOB: GstEventType = 74242;
pub const GST_EVENT_CUSTOM_DOWNSTREAM_STICKY: GstEventType = 76830;
pub const GST_EVENT_CUSTOM_BOTH: GstEventType = 79367;
pub const GST_EVENT_CUSTOM_BOTH_OOB: GstEventType = 81923;

pub type GstFlowReturn = c_int;
pub const GST_FLOW_CUSTOM_SUCCESS_2: GstFlowReturn = 102;
pub const GST_FLOW_CUSTOM_SUCCESS_1: GstFlowReturn = 101;
pub const GST_FLOW_CUSTOM_SUCCESS: GstFlowReturn = 100;
pub const GST_FLOW_OK: GstFlowReturn = 0;
pub const GST_FLOW_NOT_LINKED: GstFlowReturn = -1;
pub const GST_FLOW_FLUSHING: GstFlowReturn = -2;
pub const GST_FLOW_EOS: GstFlowReturn = -3;
pub const GST_FLOW_NOT_NEGOTIATED: GstFlowReturn = -4;
pub const GST_FLOW_ERROR: GstFlowReturn = -5;
pub const GST_FLOW_NOT_SUPPORTED: GstFlowReturn = -6;
pub const GST_FLOW_CUSTOM_ERROR: GstFlowReturn = -100;
pub const GST_FLOW_CUSTOM_ERROR_1: GstFlowReturn = -101;
pub const GST_FLOW_CUSTOM_ERROR_2: GstFlowReturn = -102;

pub type GstFormat = c_int;
pub const GST_FORMAT_UNDEFINED: GstFormat = 0;
pub const GST_FORMAT_DEFAULT: GstFormat = 1;
pub const GST_FORMAT_BYTES: GstFormat = 2;
pub const GST_FORMAT_TIME: GstFormat = 3;
pub const GST_FORMAT_BUFFERS: GstFormat = 4;
pub const GST_FORMAT_PERCENT: GstFormat = 5;

pub type GstIteratorItem = c_int;
pub const GST_ITERATOR_ITEM_SKIP: GstIteratorItem = 0;
pub const GST_ITERATOR_ITEM_PASS: GstIteratorItem = 1;
pub const GST_ITERATOR_ITEM_END: GstIteratorItem = 2;

pub type GstIteratorResult = c_int;
pub const GST_ITERATOR_DONE: GstIteratorResult = 0;
pub const GST_ITERATOR_OK: GstIteratorResult = 1;
pub const GST_ITERATOR_RESYNC: GstIteratorResult = 2;
pub const GST_ITERATOR_ERROR: GstIteratorResult = 3;

pub type GstLibraryError = c_int;
pub const GST_LIBRARY_ERROR_FAILED: GstLibraryError = 1;
pub const GST_LIBRARY_ERROR_TOO_LAZY: GstLibraryError = 2;
pub const GST_LIBRARY_ERROR_INIT: GstLibraryError = 3;
pub const GST_LIBRARY_ERROR_SHUTDOWN: GstLibraryError = 4;
pub const GST_LIBRARY_ERROR_SETTINGS: GstLibraryError = 5;
pub const GST_LIBRARY_ERROR_ENCODE: GstLibraryError = 6;
pub const GST_LIBRARY_ERROR_NUM_ERRORS: GstLibraryError = 7;

pub type GstPadDirection = c_int;
pub const GST_PAD_UNKNOWN: GstPadDirection = 0;
pub const GST_PAD_SRC: GstPadDirection = 1;
pub const GST_PAD_SINK: GstPadDirection = 2;

pub type GstPadLinkReturn = c_int;
pub const GST_PAD_LINK_OK: GstPadLinkReturn = 0;
pub const GST_PAD_LINK_WRONG_HIERARCHY: GstPadLinkReturn = -1;
pub const GST_PAD_LINK_WAS_LINKED: GstPadLinkReturn = -2;
pub const GST_PAD_LINK_WRONG_DIRECTION: GstPadLinkReturn = -3;
pub const GST_PAD_LINK_NOFORMAT: GstPadLinkReturn = -4;
pub const GST_PAD_LINK_NOSCHED: GstPadLinkReturn = -5;
pub const GST_PAD_LINK_REFUSED: GstPadLinkReturn = -6;

pub type GstPadMode = c_int;
pub const GST_PAD_MODE_NONE: GstPadMode = 0;
pub const GST_PAD_MODE_PUSH: GstPadMode = 1;
pub const GST_PAD_MODE_PULL: GstPadMode = 2;

pub type GstPadPresence = c_int;
pub const GST_PAD_ALWAYS: GstPadPresence = 0;
pub const GST_PAD_SOMETIMES: GstPadPresence = 1;
pub const GST_PAD_REQUEST: GstPadPresence = 2;

pub type GstPadProbeReturn = c_int;
pub const GST_PAD_PROBE_DROP: GstPadProbeReturn = 0;
pub const GST_PAD_PROBE_OK: GstPadProbeReturn = 1;
pub const GST_PAD_PROBE_REMOVE: GstPadProbeReturn = 2;
pub const GST_PAD_PROBE_PASS: GstPadProbeReturn = 3;
pub const GST_PAD_PROBE_HANDLED: GstPadProbeReturn = 4;

pub type GstParseError = c_int;
pub const GST_PARSE_ERROR_SYNTAX: GstParseError = 0;
pub const GST_PARSE_ERROR_NO_SUCH_ELEMENT: GstParseError = 1;
pub const GST_PARSE_ERROR_NO_SUCH_PROPERTY: GstParseError = 2;
pub const GST_PARSE_ERROR_LINK: GstParseError = 3;
pub const GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY: GstParseError = 4;
pub const GST_PARSE_ERROR_EMPTY_BIN: GstParseError = 5;
pub const GST_PARSE_ERROR_EMPTY: GstParseError = 6;
pub const GST_PARSE_ERROR_DELAYED_LINK: GstParseError = 7;

pub type GstPluginError = c_int;
pub const GST_PLUGIN_ERROR_MODULE: GstPluginError = 0;
pub const GST_PLUGIN_ERROR_DEPENDENCIES: GstPluginError = 1;
pub const GST_PLUGIN_ERROR_NAME_MISMATCH: GstPluginError = 2;

pub type GstProgressType = c_int;
pub const GST_PROGRESS_TYPE_START: GstProgressType = 0;
pub const GST_PROGRESS_TYPE_CONTINUE: GstProgressType = 1;
pub const GST_PROGRESS_TYPE_COMPLETE: GstProgressType = 2;
pub const GST_PROGRESS_TYPE_CANCELED: GstProgressType = 3;
pub const GST_PROGRESS_TYPE_ERROR: GstProgressType = 4;

pub type GstPromiseResult = c_int;
pub const GST_PROMISE_RESULT_PENDING: GstPromiseResult = 0;
pub const GST_PROMISE_RESULT_INTERRUPTED: GstPromiseResult = 1;
pub const GST_PROMISE_RESULT_REPLIED: GstPromiseResult = 2;
pub const GST_PROMISE_RESULT_EXPIRED: GstPromiseResult = 3;

pub type GstQOSType = c_int;
pub const GST_QOS_TYPE_OVERFLOW: GstQOSType = 0;
pub const GST_QOS_TYPE_UNDERFLOW: GstQOSType = 1;
pub const GST_QOS_TYPE_THROTTLE: GstQOSType = 2;

pub type GstQueryType = c_int;
pub const GST_QUERY_UNKNOWN: GstQueryType = 0;
pub const GST_QUERY_POSITION: GstQueryType = 2563;
pub const GST_QUERY_DURATION: GstQueryType = 5123;
pub const GST_QUERY_LATENCY: GstQueryType = 7683;
pub const GST_QUERY_JITTER: GstQueryType = 10243;
pub const GST_QUERY_RATE: GstQueryType = 12803;
pub const GST_QUERY_SEEKING: GstQueryType = 15363;
pub const GST_QUERY_SEGMENT: GstQueryType = 17923;
pub const GST_QUERY_CONVERT: GstQueryType = 20483;
pub const GST_QUERY_FORMATS: GstQueryType = 23043;
pub const GST_QUERY_BUFFERING: GstQueryType = 28163;
pub const GST_QUERY_CUSTOM: GstQueryType = 30723;
pub const GST_QUERY_URI: GstQueryType = 33283;
pub const GST_QUERY_ALLOCATION: GstQueryType = 35846;
pub const GST_QUERY_SCHEDULING: GstQueryType = 38401;
pub const GST_QUERY_ACCEPT_CAPS: GstQueryType = 40963;
pub const GST_QUERY_CAPS: GstQueryType = 43523;
pub const GST_QUERY_DRAIN: GstQueryType = 46086;
pub const GST_QUERY_CONTEXT: GstQueryType = 48643;

pub type GstRank = c_int;
pub const GST_RANK_NONE: GstRank = 0;
pub const GST_RANK_MARGINAL: GstRank = 64;
pub const GST_RANK_SECONDARY: GstRank = 128;
pub const GST_RANK_PRIMARY: GstRank = 256;

pub type GstResourceError = c_int;
pub const GST_RESOURCE_ERROR_FAILED: GstResourceError = 1;
pub const GST_RESOURCE_ERROR_TOO_LAZY: GstResourceError = 2;
pub const GST_RESOURCE_ERROR_NOT_FOUND: GstResourceError = 3;
pub const GST_RESOURCE_ERROR_BUSY: GstResourceError = 4;
pub const GST_RESOURCE_ERROR_OPEN_READ: GstResourceError = 5;
pub const GST_RESOURCE_ERROR_OPEN_WRITE: GstResourceError = 6;
pub const GST_RESOURCE_ERROR_OPEN_READ_WRITE: GstResourceError = 7;
pub const GST_RESOURCE_ERROR_CLOSE: GstResourceError = 8;
pub const GST_RESOURCE_ERROR_READ: GstResourceError = 9;
pub const GST_RESOURCE_ERROR_WRITE: GstResourceError = 10;
pub const GST_RESOURCE_ERROR_SEEK: GstResourceError = 11;
pub const GST_RESOURCE_ERROR_SYNC: GstResourceError = 12;
pub const GST_RESOURCE_ERROR_SETTINGS: GstResourceError = 13;
pub const GST_RESOURCE_ERROR_NO_SPACE_LEFT: GstResourceError = 14;
pub const GST_RESOURCE_ERROR_NOT_AUTHORIZED: GstResourceError = 15;
pub const GST_RESOURCE_ERROR_NUM_ERRORS: GstResourceError = 16;

pub type GstSearchMode = c_int;
pub const GST_SEARCH_MODE_EXACT: GstSearchMode = 0;
pub const GST_SEARCH_MODE_BEFORE: GstSearchMode = 1;
pub const GST_SEARCH_MODE_AFTER: GstSearchMode = 2;

pub type GstSeekType = c_int;
pub const GST_SEEK_TYPE_NONE: GstSeekType = 0;
pub const GST_SEEK_TYPE_SET: GstSeekType = 1;
pub const GST_SEEK_TYPE_END: GstSeekType = 2;

pub type GstState = c_int;
pub const GST_STATE_VOID_PENDING: GstState = 0;
pub const GST_STATE_NULL: GstState = 1;
pub const GST_STATE_READY: GstState = 2;
pub const GST_STATE_PAUSED: GstState = 3;
pub const GST_STATE_PLAYING: GstState = 4;

pub type GstStateChange = c_int;
pub const GST_STATE_CHANGE_NULL_TO_READY: GstStateChange = 10;
pub const GST_STATE_CHANGE_READY_TO_PAUSED: GstStateChange = 19;
pub const GST_STATE_CHANGE_PAUSED_TO_PLAYING: GstStateChange = 28;
pub const GST_STATE_CHANGE_PLAYING_TO_PAUSED: GstStateChange = 35;
pub const GST_STATE_CHANGE_PAUSED_TO_READY: GstStateChange = 26;
pub const GST_STATE_CHANGE_READY_TO_NULL: GstStateChange = 17;
pub const GST_STATE_CHANGE_NULL_TO_NULL: GstStateChange = 9;
pub const GST_STATE_CHANGE_READY_TO_READY: GstStateChange = 18;
pub const GST_STATE_CHANGE_PAUSED_TO_PAUSED: GstStateChange = 27;
pub const GST_STATE_CHANGE_PLAYING_TO_PLAYING: GstStateChange = 36;

pub type GstStateChangeReturn = c_int;
pub const GST_STATE_CHANGE_FAILURE: GstStateChangeReturn = 0;
pub const GST_STATE_CHANGE_SUCCESS: GstStateChangeReturn = 1;
pub const GST_STATE_CHANGE_ASYNC: GstStateChangeReturn = 2;
pub const GST_STATE_CHANGE_NO_PREROLL: GstStateChangeReturn = 3;

pub type GstStreamError = c_int;
pub const GST_STREAM_ERROR_FAILED: GstStreamError = 1;
pub const GST_STREAM_ERROR_TOO_LAZY: GstStreamError = 2;
pub const GST_STREAM_ERROR_NOT_IMPLEMENTED: GstStreamError = 3;
pub const GST_STREAM_ERROR_TYPE_NOT_FOUND: GstStreamError = 4;
pub const GST_STREAM_ERROR_WRONG_TYPE: GstStreamError = 5;
pub const GST_STREAM_ERROR_CODEC_NOT_FOUND: GstStreamError = 6;
pub const GST_STREAM_ERROR_DECODE: GstStreamError = 7;
pub const GST_STREAM_ERROR_ENCODE: GstStreamError = 8;
pub const GST_STREAM_ERROR_DEMUX: GstStreamError = 9;
pub const GST_STREAM_ERROR_MUX: GstStreamError = 10;
pub const GST_STREAM_ERROR_FORMAT: GstStreamError = 11;
pub const GST_STREAM_ERROR_DECRYPT: GstStreamError = 12;
pub const GST_STREAM_ERROR_DECRYPT_NOKEY: GstStreamError = 13;
pub const GST_STREAM_ERROR_NUM_ERRORS: GstStreamError = 14;

pub type GstStreamStatusType = c_int;
pub const GST_STREAM_STATUS_TYPE_CREATE: GstStreamStatusType = 0;
pub const GST_STREAM_STATUS_TYPE_ENTER: GstStreamStatusType = 1;
pub const GST_STREAM_STATUS_TYPE_LEAVE: GstStreamStatusType = 2;
pub const GST_STREAM_STATUS_TYPE_DESTROY: GstStreamStatusType = 3;
pub const GST_STREAM_STATUS_TYPE_START: GstStreamStatusType = 8;
pub const GST_STREAM_STATUS_TYPE_PAUSE: GstStreamStatusType = 9;
pub const GST_STREAM_STATUS_TYPE_STOP: GstStreamStatusType = 10;

pub type GstStructureChangeType = c_int;
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_LINK: GstStructureChangeType = 0;
pub const GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK: GstStructureChangeType = 1;

pub type GstTagFlag = c_int;
pub const GST_TAG_FLAG_UNDEFINED: GstTagFlag = 0;
pub const GST_TAG_FLAG_META: GstTagFlag = 1;
pub const GST_TAG_FLAG_ENCODED: GstTagFlag = 2;
pub const GST_TAG_FLAG_DECODED: GstTagFlag = 3;
pub const GST_TAG_FLAG_COUNT: GstTagFlag = 4;

pub type GstTagMergeMode = c_int;
pub const GST_TAG_MERGE_UNDEFINED: GstTagMergeMode = 0;
pub const GST_TAG_MERGE_REPLACE_ALL: GstTagMergeMode = 1;
pub const GST_TAG_MERGE_REPLACE: GstTagMergeMode = 2;
pub const GST_TAG_MERGE_APPEND: GstTagMergeMode = 3;
pub const GST_TAG_MERGE_PREPEND: GstTagMergeMode = 4;
pub const GST_TAG_MERGE_KEEP: GstTagMergeMode = 5;
pub const GST_TAG_MERGE_KEEP_ALL: GstTagMergeMode = 6;
pub const GST_TAG_MERGE_COUNT: GstTagMergeMode = 7;

pub type GstTagScope = c_int;
pub const GST_TAG_SCOPE_STREAM: GstTagScope = 0;
pub const GST_TAG_SCOPE_GLOBAL: GstTagScope = 1;

pub type GstTaskState = c_int;
pub const GST_TASK_STARTED: GstTaskState = 0;
pub const GST_TASK_STOPPED: GstTaskState = 1;
pub const GST_TASK_PAUSED: GstTaskState = 2;

pub type GstTocEntryType = c_int;
pub const GST_TOC_ENTRY_TYPE_ANGLE: GstTocEntryType = -3;
pub const GST_TOC_ENTRY_TYPE_VERSION: GstTocEntryType = -2;
pub const GST_TOC_ENTRY_TYPE_EDITION: GstTocEntryType = -1;
pub const GST_TOC_ENTRY_TYPE_INVALID: GstTocEntryType = 0;
pub const GST_TOC_ENTRY_TYPE_TITLE: GstTocEntryType = 1;
pub const GST_TOC_ENTRY_TYPE_TRACK: GstTocEntryType = 2;
pub const GST_TOC_ENTRY_TYPE_CHAPTER: GstTocEntryType = 3;

pub type GstTocLoopType = c_int;
pub const GST_TOC_LOOP_NONE: GstTocLoopType = 0;
pub const GST_TOC_LOOP_FORWARD: GstTocLoopType = 1;
pub const GST_TOC_LOOP_REVERSE: GstTocLoopType = 2;
pub const GST_TOC_LOOP_PING_PONG: GstTocLoopType = 3;

pub type GstTocScope = c_int;
pub const GST_TOC_SCOPE_GLOBAL: GstTocScope = 1;
pub const GST_TOC_SCOPE_CURRENT: GstTocScope = 2;

pub type GstTracerValueScope = c_int;
pub const GST_TRACER_VALUE_SCOPE_PROCESS: GstTracerValueScope = 0;
pub const GST_TRACER_VALUE_SCOPE_THREAD: GstTracerValueScope = 1;
pub const GST_TRACER_VALUE_SCOPE_ELEMENT: GstTracerValueScope = 2;
pub const GST_TRACER_VALUE_SCOPE_PAD: GstTracerValueScope = 3;

pub type GstTypeFindProbability = c_int;
pub const GST_TYPE_FIND_NONE: GstTypeFindProbability = 0;
pub const GST_TYPE_FIND_MINIMUM: GstTypeFindProbability = 1;
pub const GST_TYPE_FIND_POSSIBLE: GstTypeFindProbability = 50;
pub const GST_TYPE_FIND_LIKELY: GstTypeFindProbability = 80;
pub const GST_TYPE_FIND_NEARLY_CERTAIN: GstTypeFindProbability = 99;
pub const GST_TYPE_FIND_MAXIMUM: GstTypeFindProbability = 100;

pub type GstURIError = c_int;
pub const GST_URI_ERROR_UNSUPPORTED_PROTOCOL: GstURIError = 0;
pub const GST_URI_ERROR_BAD_URI: GstURIError = 1;
pub const GST_URI_ERROR_BAD_STATE: GstURIError = 2;
pub const GST_URI_ERROR_BAD_REFERENCE: GstURIError = 3;

pub type GstURIType = c_int;
pub const GST_URI_UNKNOWN: GstURIType = 0;
pub const GST_URI_SINK: GstURIType = 1;
pub const GST_URI_SRC: GstURIType = 2;

// Constants
pub const GST_ALLOCATOR_SYSMEM: *const c_char = b"SystemMemory\0" as *const u8 as *const c_char;
pub const GST_BUFFER_COPY_ALL: GstBufferCopyFlags = 15;
pub const GST_BUFFER_COPY_METADATA: GstBufferCopyFlags = 7;
pub const GST_BUFFER_OFFSET_NONE: u64 = 18446744073709551615;
pub const GST_CAN_INLINE: c_int = 1;
pub const GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY: *const c_char = b"memory:SystemMemory\0" as *const u8 as *const c_char;
pub const GST_CLOCK_TIME_NONE: GstClockTime = 18446744073709551615;
pub const GST_DEBUG_BG_MASK: c_int = 240;
pub const GST_DEBUG_FG_MASK: c_int = 15;
pub const GST_DEBUG_FORMAT_MASK: c_int = 65280;
pub const GST_ELEMENT_FACTORY_KLASS_DECODER: *const c_char = b"Decoder\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_DECRYPTOR: *const c_char = b"Decryptor\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_DEMUXER: *const c_char = b"Demuxer\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_DEPAYLOADER: *const c_char = b"Depayloader\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_ENCODER: *const c_char = b"Encoder\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_ENCRYPTOR: *const c_char = b"Encryptor\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_FORMATTER: *const c_char = b"Formatter\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_AUDIO: *const c_char = b"Audio\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_IMAGE: *const c_char = b"Image\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_METADATA: *const c_char = b"Metadata\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE: *const c_char = b"Subtitle\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MEDIA_VIDEO: *const c_char = b"Video\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_MUXER: *const c_char = b"Muxer\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_PARSER: *const c_char = b"Parser\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_PAYLOADER: *const c_char = b"Payloader\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_SINK: *const c_char = b"Sink\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_KLASS_SRC: *const c_char = b"Source\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_FACTORY_TYPE_ANY: GstElementFactoryListType = 562949953421311;
pub const GST_ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS: GstElementFactoryListType = 3940649673949188;
pub const GST_ELEMENT_FACTORY_TYPE_AUDIO_ENCODER: GstElementFactoryListType = 1125899906842626;
pub const GST_ELEMENT_FACTORY_TYPE_DECODABLE: GstElementFactoryListType = 1377;
pub const GST_ELEMENT_FACTORY_TYPE_DECODER: GstElementFactoryListType = 1;
pub const GST_ELEMENT_FACTORY_TYPE_DECRYPTOR: GstElementFactoryListType = 1024;
pub const GST_ELEMENT_FACTORY_TYPE_DEMUXER: GstElementFactoryListType = 32;
pub const GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER: GstElementFactoryListType = 256;
pub const GST_ELEMENT_FACTORY_TYPE_ENCODER: GstElementFactoryListType = 2;
pub const GST_ELEMENT_FACTORY_TYPE_ENCRYPTOR: GstElementFactoryListType = 2048;
pub const GST_ELEMENT_FACTORY_TYPE_FORMATTER: GstElementFactoryListType = 512;
pub const GST_ELEMENT_FACTORY_TYPE_MAX_ELEMENTS: GstElementFactoryListType = 281474976710656;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_ANY: GstElementFactoryListType = 18446462598732840960;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO: GstElementFactoryListType = 1125899906842624;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE: GstElementFactoryListType = 2251799813685248;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_METADATA: GstElementFactoryListType = 9007199254740992;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE: GstElementFactoryListType = 4503599627370496;
pub const GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO: GstElementFactoryListType = 562949953421312;
pub const GST_ELEMENT_FACTORY_TYPE_MUXER: GstElementFactoryListType = 16;
pub const GST_ELEMENT_FACTORY_TYPE_PARSER: GstElementFactoryListType = 64;
pub const GST_ELEMENT_FACTORY_TYPE_PAYLOADER: GstElementFactoryListType = 128;
pub const GST_ELEMENT_FACTORY_TYPE_SINK: GstElementFactoryListType = 4;
pub const GST_ELEMENT_FACTORY_TYPE_SRC: GstElementFactoryListType = 8;
pub const GST_ELEMENT_FACTORY_TYPE_VIDEO_ENCODER: GstElementFactoryListType = 2814749767106562;
pub const GST_ELEMENT_METADATA_AUTHOR: *const c_char = b"author\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_DESCRIPTION: *const c_char = b"description\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_DOC_URI: *const c_char = b"doc-uri\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_ICON_NAME: *const c_char = b"icon-name\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_KLASS: *const c_char = b"klass\0" as *const u8 as *const c_char;
pub const GST_ELEMENT_METADATA_LONGNAME: *const c_char = b"long-name\0" as *const u8 as *const c_char;
pub const GST_ERROR_SYSTEM: *const c_char = b"system error: %s\0" as *const u8 as *const c_char;
pub const GST_EVENT_NUM_SHIFT: c_int = 8;
pub const GST_EVENT_TYPE_BOTH: GstEventTypeFlags = 3;
pub const GST_FLAG_SET_MASK_EXACT: c_uint = 4294967295;
pub const GST_FORMAT_PERCENT_MAX: i64 = 1000000;
pub const GST_FORMAT_PERCENT_SCALE: i64 = 10000;
pub const GST_FOURCC_FORMAT: *const c_char = b"c%c%c%c\0" as *const u8 as *const c_char;
pub const GST_GROUP_ID_INVALID: c_int = 0;
pub const GST_LICENSE_UNKNOWN: *const c_char = b"unknown\0" as *const u8 as *const c_char;
pub const GST_LOCK_FLAG_READWRITE: GstLockFlags = 3;
pub const GST_MAP_READWRITE: GstMapFlags = 3;
pub const GST_META_TAG_MEMORY_STR: *const c_char = b"memory\0" as *const u8 as *const c_char;
pub const GST_MSECOND: GstClockTimeDiff = 1000000;
pub const GST_NSECOND: GstClockTimeDiff = 1;
pub const GST_PARAM_CONTROLLABLE: c_int = 512;
pub const GST_PARAM_MUTABLE_PAUSED: c_int = 2048;
pub const GST_PARAM_MUTABLE_PLAYING: c_int = 4096;
pub const GST_PARAM_MUTABLE_READY: c_int = 1024;
pub const GST_PARAM_USER_SHIFT: c_int = 65536;
pub const GST_PROTECTION_SYSTEM_ID_CAPS_FIELD: *const c_char = b"protection-system\0" as *const u8 as *const c_char;
pub const GST_PTR_FORMAT: *const c_char = b"paA\0" as *const u8 as *const c_char;
pub const GST_QUERY_NUM_SHIFT: c_int = 8;
pub const GST_QUERY_TYPE_BOTH: GstQueryTypeFlags = 3;
pub const GST_SECOND: GstClockTimeDiff = 1000000000;
pub const GST_SEGMENT_FORMAT: *const c_char = b"paB\0" as *const u8 as *const c_char;
pub const GST_SEQNUM_INVALID: c_int = 0;
pub const GST_STIME_FORMAT: *const c_char = b"c%\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM: *const c_char = b"album\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_ARTIST: *const c_char = b"album-artist\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_ARTIST_SORTNAME: *const c_char = b"album-artist-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_GAIN: *const c_char = b"replaygain-album-gain\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_PEAK: *const c_char = b"replaygain-album-peak\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_SORTNAME: *const c_char = b"album-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_VOLUME_COUNT: *const c_char = b"album-disc-count\0" as *const u8 as *const c_char;
pub const GST_TAG_ALBUM_VOLUME_NUMBER: *const c_char = b"album-disc-number\0" as *const u8 as *const c_char;
pub const GST_TAG_APPLICATION_DATA: *const c_char = b"application-data\0" as *const u8 as *const c_char;
pub const GST_TAG_APPLICATION_NAME: *const c_char = b"application-name\0" as *const u8 as *const c_char;
pub const GST_TAG_ARTIST: *const c_char = b"artist\0" as *const u8 as *const c_char;
pub const GST_TAG_ARTIST_SORTNAME: *const c_char = b"artist-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_ATTACHMENT: *const c_char = b"attachment\0" as *const u8 as *const c_char;
pub const GST_TAG_AUDIO_CODEC: *const c_char = b"audio-codec\0" as *const u8 as *const c_char;
pub const GST_TAG_BEATS_PER_MINUTE: *const c_char = b"beats-per-minute\0" as *const u8 as *const c_char;
pub const GST_TAG_BITRATE: *const c_char = b"bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_CODEC: *const c_char = b"codec\0" as *const u8 as *const c_char;
pub const GST_TAG_COMMENT: *const c_char = b"comment\0" as *const u8 as *const c_char;
pub const GST_TAG_COMPOSER: *const c_char = b"composer\0" as *const u8 as *const c_char;
pub const GST_TAG_COMPOSER_SORTNAME: *const c_char = b"composer-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_CONDUCTOR: *const c_char = b"conductor\0" as *const u8 as *const c_char;
pub const GST_TAG_CONTACT: *const c_char = b"contact\0" as *const u8 as *const c_char;
pub const GST_TAG_CONTAINER_FORMAT: *const c_char = b"container-format\0" as *const u8 as *const c_char;
pub const GST_TAG_COPYRIGHT: *const c_char = b"copyright\0" as *const u8 as *const c_char;
pub const GST_TAG_COPYRIGHT_URI: *const c_char = b"copyright-uri\0" as *const u8 as *const c_char;
pub const GST_TAG_DATE: *const c_char = b"date\0" as *const u8 as *const c_char;
pub const GST_TAG_DATE_TIME: *const c_char = b"datetime\0" as *const u8 as *const c_char;
pub const GST_TAG_DESCRIPTION: *const c_char = b"description\0" as *const u8 as *const c_char;
pub const GST_TAG_DEVICE_MANUFACTURER: *const c_char = b"device-manufacturer\0" as *const u8 as *const c_char;
pub const GST_TAG_DEVICE_MODEL: *const c_char = b"device-model\0" as *const u8 as *const c_char;
pub const GST_TAG_DURATION: *const c_char = b"duration\0" as *const u8 as *const c_char;
pub const GST_TAG_ENCODED_BY: *const c_char = b"encoded-by\0" as *const u8 as *const c_char;
pub const GST_TAG_ENCODER: *const c_char = b"encoder\0" as *const u8 as *const c_char;
pub const GST_TAG_ENCODER_VERSION: *const c_char = b"encoder-version\0" as *const u8 as *const c_char;
pub const GST_TAG_EXTENDED_COMMENT: *const c_char = b"extended-comment\0" as *const u8 as *const c_char;
pub const GST_TAG_GENRE: *const c_char = b"genre\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION: *const c_char = b"geo-location-capture-direction\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_CITY: *const c_char = b"geo-location-city\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_COUNTRY: *const c_char = b"geo-location-country\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_ELEVATION: *const c_char = b"geo-location-elevation\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR: *const c_char = b"geo-location-horizontal-error\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_LATITUDE: *const c_char = b"geo-location-latitude\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_LONGITUDE: *const c_char = b"geo-location-longitude\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION: *const c_char = b"geo-location-movement-direction\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_MOVEMENT_SPEED: *const c_char = b"geo-location-movement-speed\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_NAME: *const c_char = b"geo-location-name\0" as *const u8 as *const c_char;
pub const GST_TAG_GEO_LOCATION_SUBLOCATION: *const c_char = b"geo-location-sublocation\0" as *const u8 as *const c_char;
pub const GST_TAG_GROUPING: *const c_char = b"grouping\0" as *const u8 as *const c_char;
pub const GST_TAG_HOMEPAGE: *const c_char = b"homepage\0" as *const u8 as *const c_char;
pub const GST_TAG_IMAGE: *const c_char = b"image\0" as *const u8 as *const c_char;
pub const GST_TAG_IMAGE_ORIENTATION: *const c_char = b"image-orientation\0" as *const u8 as *const c_char;
pub const GST_TAG_INTERPRETED_BY: *const c_char = b"interpreted-by\0" as *const u8 as *const c_char;
pub const GST_TAG_ISRC: *const c_char = b"isrc\0" as *const u8 as *const c_char;
pub const GST_TAG_KEYWORDS: *const c_char = b"keywords\0" as *const u8 as *const c_char;
pub const GST_TAG_LANGUAGE_CODE: *const c_char = b"language-code\0" as *const u8 as *const c_char;
pub const GST_TAG_LANGUAGE_NAME: *const c_char = b"language-name\0" as *const u8 as *const c_char;
pub const GST_TAG_LICENSE: *const c_char = b"license\0" as *const u8 as *const c_char;
pub const GST_TAG_LICENSE_URI: *const c_char = b"license-uri\0" as *const u8 as *const c_char;
pub const GST_TAG_LOCATION: *const c_char = b"location\0" as *const u8 as *const c_char;
pub const GST_TAG_LYRICS: *const c_char = b"lyrics\0" as *const u8 as *const c_char;
pub const GST_TAG_MAXIMUM_BITRATE: *const c_char = b"maximum-bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_MIDI_BASE_NOTE: *const c_char = b"midi-base-note\0" as *const u8 as *const c_char;
pub const GST_TAG_MINIMUM_BITRATE: *const c_char = b"minimum-bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_NOMINAL_BITRATE: *const c_char = b"nominal-bitrate\0" as *const u8 as *const c_char;
pub const GST_TAG_ORGANIZATION: *const c_char = b"organization\0" as *const u8 as *const c_char;
pub const GST_TAG_PERFORMER: *const c_char = b"performer\0" as *const u8 as *const c_char;
pub const GST_TAG_PREVIEW_IMAGE: *const c_char = b"preview-image\0" as *const u8 as *const c_char;
pub const GST_TAG_PRIVATE_DATA: *const c_char = b"private-data\0" as *const u8 as *const c_char;
pub const GST_TAG_PUBLISHER: *const c_char = b"publisher\0" as *const u8 as *const c_char;
pub const GST_TAG_REFERENCE_LEVEL: *const c_char = b"replaygain-reference-level\0" as *const u8 as *const c_char;
pub const GST_TAG_SERIAL: *const c_char = b"serial\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_EPISODE_NUMBER: *const c_char = b"show-episode-number\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_NAME: *const c_char = b"show-name\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_SEASON_NUMBER: *const c_char = b"show-season-number\0" as *const u8 as *const c_char;
pub const GST_TAG_SHOW_SORTNAME: *const c_char = b"show-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_SUBTITLE_CODEC: *const c_char = b"subtitle-codec\0" as *const u8 as *const c_char;
pub const GST_TAG_TITLE: *const c_char = b"title\0" as *const u8 as *const c_char;
pub const GST_TAG_TITLE_SORTNAME: *const c_char = b"title-sortname\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_COUNT: *const c_char = b"track-count\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_GAIN: *const c_char = b"replaygain-track-gain\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_NUMBER: *const c_char = b"track-number\0" as *const u8 as *const c_char;
pub const GST_TAG_TRACK_PEAK: *const c_char = b"replaygain-track-peak\0" as *const u8 as *const c_char;
pub const GST_TAG_USER_RATING: *const c_char = b"user-rating\0" as *const u8 as *const c_char;
pub const GST_TAG_VERSION: *const c_char = b"version\0" as *const u8 as *const c_char;
pub const GST_TAG_VIDEO_CODEC: *const c_char = b"video-codec\0" as *const u8 as *const c_char;
pub const GST_TIME_FORMAT: *const c_char = b"u:%02u:%02u.%09u\0" as *const u8 as *const c_char;
pub const GST_TOC_REPEAT_COUNT_INFINITE: c_int = -1;
pub const GST_URI_NO_PORT: c_int = 0;
pub const GST_USECOND: GstClockTimeDiff = 1000;
pub const GST_VALUE_EQUAL: c_int = 0;
pub const GST_VALUE_GREATER_THAN: c_int = 1;
pub const GST_VALUE_LESS_THAN: c_int = -1;
pub const GST_VALUE_UNORDERED: c_int = 2;

// Flags
pub type GstAllocatorFlags = c_uint;
pub const GST_ALLOCATOR_FLAG_CUSTOM_ALLOC: GstAllocatorFlags = 16;
pub const GST_ALLOCATOR_FLAG_LAST: GstAllocatorFlags = 1048576;

pub type GstBinFlags = c_uint;
pub const GST_BIN_FLAG_NO_RESYNC: GstBinFlags = 16384;
pub const GST_BIN_FLAG_STREAMS_AWARE: GstBinFlags = 32768;
pub const GST_BIN_FLAG_LAST: GstBinFlags = 524288;

pub type GstBufferCopyFlags = c_uint;
pub const GST_BUFFER_COPY_NONE: GstBufferCopyFlags = 0;
pub const GST_BUFFER_COPY_FLAGS: GstBufferCopyFlags = 1;
pub const GST_BUFFER_COPY_TIMESTAMPS: GstBufferCopyFlags = 2;
pub const GST_BUFFER_COPY_META: GstBufferCopyFlags = 4;
pub const GST_BUFFER_COPY_MEMORY: GstBufferCopyFlags = 8;
pub const GST_BUFFER_COPY_MERGE: GstBufferCopyFlags = 16;
pub const GST_BUFFER_COPY_DEEP: GstBufferCopyFlags = 32;

pub type GstBufferFlags = c_uint;
pub const GST_BUFFER_FLAG_LIVE: GstBufferFlags = 16;
pub const GST_BUFFER_FLAG_DECODE_ONLY: GstBufferFlags = 32;
pub const GST_BUFFER_FLAG_DISCONT: GstBufferFlags = 64;
pub const GST_BUFFER_FLAG_RESYNC: GstBufferFlags = 128;
pub const GST_BUFFER_FLAG_CORRUPTED: GstBufferFlags = 256;
pub const GST_BUFFER_FLAG_MARKER: GstBufferFlags = 512;
pub const GST_BUFFER_FLAG_HEADER: GstBufferFlags = 1024;
pub const GST_BUFFER_FLAG_GAP: GstBufferFlags = 2048;
pub const GST_BUFFER_FLAG_DROPPABLE: GstBufferFlags = 4096;
pub const GST_BUFFER_FLAG_DELTA_UNIT: GstBufferFlags = 8192;
pub const GST_BUFFER_FLAG_TAG_MEMORY: GstBufferFlags = 16384;
pub const GST_BUFFER_FLAG_SYNC_AFTER: GstBufferFlags = 32768;
pub const GST_BUFFER_FLAG_NON_DROPPABLE: GstBufferFlags = 65536;
pub const GST_BUFFER_FLAG_LAST: GstBufferFlags = 1048576;

pub type GstBufferPoolAcquireFlags = c_uint;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_NONE: GstBufferPoolAcquireFlags = 0;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT: GstBufferPoolAcquireFlags = 1;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT: GstBufferPoolAcquireFlags = 2;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT: GstBufferPoolAcquireFlags = 4;
pub const GST_BUFFER_POOL_ACQUIRE_FLAG_LAST: GstBufferPoolAcquireFlags = 65536;

pub type GstBusFlags = c_uint;
pub const GST_BUS_FLUSHING: GstBusFlags = 16;
pub const GST_BUS_FLAG_LAST: GstBusFlags = 32;

pub type GstCapsFlags = c_uint;
pub const GST_CAPS_FLAG_ANY: GstCapsFlags = 16;

pub type GstClockFlags = c_uint;
pub const GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC: GstClockFlags = 16;
pub const GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC: GstClockFlags = 32;
pub const GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC: GstClockFlags = 64;
pub const GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC: GstClockFlags = 128;
pub const GST_CLOCK_FLAG_CAN_SET_RESOLUTION: GstClockFlags = 256;
pub const GST_CLOCK_FLAG_CAN_SET_MASTER: GstClockFlags = 512;
pub const GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC: GstClockFlags = 1024;
pub const GST_CLOCK_FLAG_LAST: GstClockFlags = 4096;

pub type GstDebugColorFlags = c_uint;
pub const GST_DEBUG_FG_BLACK: GstDebugColorFlags = 0;
pub const GST_DEBUG_FG_RED: GstDebugColorFlags = 1;
pub const GST_DEBUG_FG_GREEN: GstDebugColorFlags = 2;
pub const GST_DEBUG_FG_YELLOW: GstDebugColorFlags = 3;
pub const GST_DEBUG_FG_BLUE: GstDebugColorFlags = 4;
pub const GST_DEBUG_FG_MAGENTA: GstDebugColorFlags = 5;
pub const GST_DEBUG_FG_CYAN: GstDebugColorFlags = 6;
pub const GST_DEBUG_FG_WHITE: GstDebugColorFlags = 7;
pub const GST_DEBUG_BG_BLACK: GstDebugColorFlags = 0;
pub const GST_DEBUG_BG_RED: GstDebugColorFlags = 16;
pub const GST_DEBUG_BG_GREEN: GstDebugColorFlags = 32;
pub const GST_DEBUG_BG_YELLOW: GstDebugColorFlags = 48;
pub const GST_DEBUG_BG_BLUE: GstDebugColorFlags = 64;
pub const GST_DEBUG_BG_MAGENTA: GstDebugColorFlags = 80;
pub const GST_DEBUG_BG_CYAN: GstDebugColorFlags = 96;
pub const GST_DEBUG_BG_WHITE: GstDebugColorFlags = 112;
pub const GST_DEBUG_BOLD: GstDebugColorFlags = 256;
pub const GST_DEBUG_UNDERLINE: GstDebugColorFlags = 512;

pub type GstDebugGraphDetails = c_uint;
pub const GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE: GstDebugGraphDetails = 1;
pub const GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS: GstDebugGraphDetails = 2;
pub const GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS: GstDebugGraphDetails = 4;
pub const GST_DEBUG_GRAPH_SHOW_STATES: GstDebugGraphDetails = 8;
pub const GST_DEBUG_GRAPH_SHOW_FULL_PARAMS: GstDebugGraphDetails = 16;
pub const GST_DEBUG_GRAPH_SHOW_ALL: GstDebugGraphDetails = 15;
pub const GST_DEBUG_GRAPH_SHOW_VERBOSE: GstDebugGraphDetails = 4294967295;

pub type GstElementFlags = c_uint;
pub const GST_ELEMENT_FLAG_LOCKED_STATE: GstElementFlags = 16;
pub const GST_ELEMENT_FLAG_SINK: GstElementFlags = 32;
pub const GST_ELEMENT_FLAG_SOURCE: GstElementFlags = 64;
pub const GST_ELEMENT_FLAG_PROVIDE_CLOCK: GstElementFlags = 128;
pub const GST_ELEMENT_FLAG_REQUIRE_CLOCK: GstElementFlags = 256;
pub const GST_ELEMENT_FLAG_INDEXABLE: GstElementFlags = 512;
pub const GST_ELEMENT_FLAG_LAST: GstElementFlags = 16384;

pub type GstEventTypeFlags = c_uint;
pub const GST_EVENT_TYPE_UPSTREAM: GstEventTypeFlags = 1;
pub const GST_EVENT_TYPE_DOWNSTREAM: GstEventTypeFlags = 2;
pub const GST_EVENT_TYPE_SERIALIZED: GstEventTypeFlags = 4;
pub const GST_EVENT_TYPE_STICKY: GstEventTypeFlags = 8;
pub const GST_EVENT_TYPE_STICKY_MULTI: GstEventTypeFlags = 16;

pub type GstLockFlags = c_uint;
pub const GST_LOCK_FLAG_READ: GstLockFlags = 1;
pub const GST_LOCK_FLAG_WRITE: GstLockFlags = 2;
pub const GST_LOCK_FLAG_EXCLUSIVE: GstLockFlags = 4;
pub const GST_LOCK_FLAG_LAST: GstLockFlags = 256;

pub type GstMapFlags = c_uint;
pub const GST_MAP_READ: GstMapFlags = 1;
pub const GST_MAP_WRITE: GstMapFlags = 2;
pub const GST_MAP_FLAG_LAST: GstMapFlags = 65536;

pub type GstMemoryFlags = c_uint;
pub const GST_MEMORY_FLAG_READONLY: GstMemoryFlags = 2;
pub const GST_MEMORY_FLAG_NO_SHARE: GstMemoryFlags = 16;
pub const GST_MEMORY_FLAG_ZERO_PREFIXED: GstMemoryFlags = 32;
pub const GST_MEMORY_FLAG_ZERO_PADDED: GstMemoryFlags = 64;
pub const GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS: GstMemoryFlags = 128;
pub const GST_MEMORY_FLAG_NOT_MAPPABLE: GstMemoryFlags = 256;
pub const GST_MEMORY_FLAG_LAST: GstMemoryFlags = 1048576;

pub type GstMessageType = c_uint;
pub const GST_MESSAGE_UNKNOWN: GstMessageType = 0;
pub const GST_MESSAGE_EOS: GstMessageType = 1;
pub const GST_MESSAGE_ERROR: GstMessageType = 2;
pub const GST_MESSAGE_WARNING: GstMessageType = 4;
pub const GST_MESSAGE_INFO: GstMessageType = 8;
pub const GST_MESSAGE_TAG: GstMessageType = 16;
pub const GST_MESSAGE_BUFFERING: GstMessageType = 32;
pub const GST_MESSAGE_STATE_CHANGED: GstMessageType = 64;
pub const GST_MESSAGE_STATE_DIRTY: GstMessageType = 128;
pub const GST_MESSAGE_STEP_DONE: GstMessageType = 256;
pub const GST_MESSAGE_CLOCK_PROVIDE: GstMessageType = 512;
pub const GST_MESSAGE_CLOCK_LOST: GstMessageType = 1024;
pub const GST_MESSAGE_NEW_CLOCK: GstMessageType = 2048;
pub const GST_MESSAGE_STRUCTURE_CHANGE: GstMessageType = 4096;
pub const GST_MESSAGE_STREAM_STATUS: GstMessageType = 8192;
pub const GST_MESSAGE_APPLICATION: GstMessageType = 16384;
pub const GST_MESSAGE_ELEMENT: GstMessageType = 32768;
pub const GST_MESSAGE_SEGMENT_START: GstMessageType = 65536;
pub const GST_MESSAGE_SEGMENT_DONE: GstMessageType = 131072;
pub const GST_MESSAGE_DURATION_CHANGED: GstMessageType = 262144;
pub const GST_MESSAGE_LATENCY: GstMessageType = 524288;
pub const GST_MESSAGE_ASYNC_START: GstMessageType = 1048576;
pub const GST_MESSAGE_ASYNC_DONE: GstMessageType = 2097152;
pub const GST_MESSAGE_REQUEST_STATE: GstMessageType = 4194304;
pub const GST_MESSAGE_STEP_START: GstMessageType = 8388608;
pub const GST_MESSAGE_QOS: GstMessageType = 16777216;
pub const GST_MESSAGE_PROGRESS: GstMessageType = 33554432;
pub const GST_MESSAGE_TOC: GstMessageType = 67108864;
pub const GST_MESSAGE_RESET_TIME: GstMessageType = 134217728;
pub const GST_MESSAGE_STREAM_START: GstMessageType = 268435456;
pub const GST_MESSAGE_NEED_CONTEXT: GstMessageType = 536870912;
pub const GST_MESSAGE_HAVE_CONTEXT: GstMessageType = 1073741824;
pub const GST_MESSAGE_EXTENDED: GstMessageType = 2147483648;
pub const GST_MESSAGE_DEVICE_ADDED: GstMessageType = 2147483649;
pub const GST_MESSAGE_DEVICE_REMOVED: GstMessageType = 2147483650;
pub const GST_MESSAGE_PROPERTY_NOTIFY: GstMessageType = 2147483651;
pub const GST_MESSAGE_STREAM_COLLECTION: GstMessageType = 2147483652;
pub const GST_MESSAGE_STREAMS_SELECTED: GstMessageType = 2147483653;
pub const GST_MESSAGE_REDIRECT: GstMessageType = 2147483654;
pub const GST_MESSAGE_ANY: GstMessageType = 4294967295;

pub type GstMetaFlags = c_uint;
pub const GST_META_FLAG_NONE: GstMetaFlags = 0;
pub const GST_META_FLAG_READONLY: GstMetaFlags = 1;
pub const GST_META_FLAG_POOLED: GstMetaFlags = 2;
pub const GST_META_FLAG_LOCKED: GstMetaFlags = 4;
pub const GST_META_FLAG_LAST: GstMetaFlags = 65536;

pub type GstMiniObjectFlags = c_uint;
pub const GST_MINI_OBJECT_FLAG_LOCKABLE: GstMiniObjectFlags = 1;
pub const GST_MINI_OBJECT_FLAG_LOCK_READONLY: GstMiniObjectFlags = 2;
pub const GST_MINI_OBJECT_FLAG_MAY_BE_LEAKED: GstMiniObjectFlags = 4;
pub const GST_MINI_OBJECT_FLAG_LAST: GstMiniObjectFlags = 16;

pub type GstObjectFlags = c_uint;
pub const GST_OBJECT_FLAG_MAY_BE_LEAKED: GstObjectFlags = 1;
pub const GST_OBJECT_FLAG_LAST: GstObjectFlags = 16;

pub type GstPadFlags = c_uint;
pub const GST_PAD_FLAG_BLOCKED: GstPadFlags = 16;
pub const GST_PAD_FLAG_FLUSHING: GstPadFlags = 32;
pub const GST_PAD_FLAG_EOS: GstPadFlags = 64;
pub const GST_PAD_FLAG_BLOCKING: GstPadFlags = 128;
pub const GST_PAD_FLAG_NEED_PARENT: GstPadFlags = 256;
pub const GST_PAD_FLAG_NEED_RECONFIGURE: GstPadFlags = 512;
pub const GST_PAD_FLAG_PENDING_EVENTS: GstPadFlags = 1024;
pub const GST_PAD_FLAG_FIXED_CAPS: GstPadFlags = 2048;
pub const GST_PAD_FLAG_PROXY_CAPS: GstPadFlags = 4096;
pub const GST_PAD_FLAG_PROXY_ALLOCATION: GstPadFlags = 8192;
pub const GST_PAD_FLAG_PROXY_SCHEDULING: GstPadFlags = 16384;
pub const GST_PAD_FLAG_ACCEPT_INTERSECT: GstPadFlags = 32768;
pub const GST_PAD_FLAG_ACCEPT_TEMPLATE: GstPadFlags = 65536;
pub const GST_PAD_FLAG_LAST: GstPadFlags = 1048576;

pub type GstPadLinkCheck = c_uint;
pub const GST_PAD_LINK_CHECK_NOTHING: GstPadLinkCheck = 0;
pub const GST_PAD_LINK_CHECK_HIERARCHY: GstPadLinkCheck = 1;
pub const GST_PAD_LINK_CHECK_TEMPLATE_CAPS: GstPadLinkCheck = 2;
pub const GST_PAD_LINK_CHECK_CAPS: GstPadLinkCheck = 4;
pub const GST_PAD_LINK_CHECK_NO_RECONFIGURE: GstPadLinkCheck = 8;
pub const GST_PAD_LINK_CHECK_DEFAULT: GstPadLinkCheck = 5;

pub type GstPadProbeType = c_uint;
pub const GST_PAD_PROBE_TYPE_INVALID: GstPadProbeType = 0;
pub const GST_PAD_PROBE_TYPE_IDLE: GstPadProbeType = 1;
pub const GST_PAD_PROBE_TYPE_BLOCK: GstPadProbeType = 2;
pub const GST_PAD_PROBE_TYPE_BUFFER: GstPadProbeType = 16;
pub const GST_PAD_PROBE_TYPE_BUFFER_LIST: GstPadProbeType = 32;
pub const GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM: GstPadProbeType = 64;
pub const GST_PAD_PROBE_TYPE_EVENT_UPSTREAM: GstPadProbeType = 128;
pub const GST_PAD_PROBE_TYPE_EVENT_FLUSH: GstPadProbeType = 256;
pub const GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM: GstPadProbeType = 512;
pub const GST_PAD_PROBE_TYPE_QUERY_UPSTREAM: GstPadProbeType = 1024;
pub const GST_PAD_PROBE_TYPE_PUSH: GstPadProbeType = 4096;
pub const GST_PAD_PROBE_TYPE_PULL: GstPadProbeType = 8192;
pub const GST_PAD_PROBE_TYPE_BLOCKING: GstPadProbeType = 3;
pub const GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM: GstPadProbeType = 112;
pub const GST_PAD_PROBE_TYPE_DATA_UPSTREAM: GstPadProbeType = 128;
pub const GST_PAD_PROBE_TYPE_DATA_BOTH: GstPadProbeType = 240;
pub const GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM: GstPadProbeType = 114;
pub const GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM: GstPadProbeType = 130;
pub const GST_PAD_PROBE_TYPE_EVENT_BOTH: GstPadProbeType = 192;
pub const GST_PAD_PROBE_TYPE_QUERY_BOTH: GstPadProbeType = 1536;
pub const GST_PAD_PROBE_TYPE_ALL_BOTH: GstPadProbeType = 1776;
pub const GST_PAD_PROBE_TYPE_SCHEDULING: GstPadProbeType = 12288;

pub type GstPadTemplateFlags = c_uint;
pub const GST_PAD_TEMPLATE_FLAG_LAST: GstPadTemplateFlags = 256;

pub type GstParseFlags = c_uint;
pub const GST_PARSE_FLAG_NONE: GstParseFlags = 0;
pub const GST_PARSE_FLAG_FATAL_ERRORS: GstParseFlags = 1;
pub const GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS: GstParseFlags = 2;
pub const GST_PARSE_FLAG_PLACE_IN_BIN: GstParseFlags = 4;

pub type GstPipelineFlags = c_uint;
pub const GST_PIPELINE_FLAG_FIXED_CLOCK: GstPipelineFlags = 524288;
pub const GST_PIPELINE_FLAG_LAST: GstPipelineFlags = 8388608;

pub type GstPluginDependencyFlags = c_uint;
pub const GST_PLUGIN_DEPENDENCY_FLAG_NONE: GstPluginDependencyFlags = 0;
pub const GST_PLUGIN_DEPENDENCY_FLAG_RECURSE: GstPluginDependencyFlags = 1;
pub const GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY: GstPluginDependencyFlags = 2;
pub const GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX: GstPluginDependencyFlags = 4;
pub const GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX: GstPluginDependencyFlags = 8;
pub const GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE: GstPluginDependencyFlags = 16;

pub type GstPluginFlags = c_uint;
pub const GST_PLUGIN_FLAG_CACHED: GstPluginFlags = 16;
pub const GST_PLUGIN_FLAG_BLACKLISTED: GstPluginFlags = 32;

pub type GstQueryTypeFlags = c_uint;
pub const GST_QUERY_TYPE_UPSTREAM: GstQueryTypeFlags = 1;
pub const GST_QUERY_TYPE_DOWNSTREAM: GstQueryTypeFlags = 2;
pub const GST_QUERY_TYPE_SERIALIZED: GstQueryTypeFlags = 4;

pub type GstSchedulingFlags = c_uint;
pub const GST_SCHEDULING_FLAG_SEEKABLE: GstSchedulingFlags = 1;
pub const GST_SCHEDULING_FLAG_SEQUENTIAL: GstSchedulingFlags = 2;
pub const GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED: GstSchedulingFlags = 4;

pub type GstSeekFlags = c_uint;
pub const GST_SEEK_FLAG_NONE: GstSeekFlags = 0;
pub const GST_SEEK_FLAG_FLUSH: GstSeekFlags = 1;
pub const GST_SEEK_FLAG_ACCURATE: GstSeekFlags = 2;
pub const GST_SEEK_FLAG_KEY_UNIT: GstSeekFlags = 4;
pub const GST_SEEK_FLAG_SEGMENT: GstSeekFlags = 8;
pub const GST_SEEK_FLAG_TRICKMODE: GstSeekFlags = 16;
pub const GST_SEEK_FLAG_SKIP: GstSeekFlags = 16;
pub const GST_SEEK_FLAG_SNAP_BEFORE: GstSeekFlags = 32;
pub const GST_SEEK_FLAG_SNAP_AFTER: GstSeekFlags = 64;
pub const GST_SEEK_FLAG_SNAP_NEAREST: GstSeekFlags = 96;
pub const GST_SEEK_FLAG_TRICKMODE_KEY_UNITS: GstSeekFlags = 128;
pub const GST_SEEK_FLAG_TRICKMODE_NO_AUDIO: GstSeekFlags = 256;

pub type GstSegmentFlags = c_uint;
pub const GST_SEGMENT_FLAG_NONE: GstSegmentFlags = 0;
pub const GST_SEGMENT_FLAG_RESET: GstSegmentFlags = 1;
pub const GST_SEGMENT_FLAG_TRICKMODE: GstSegmentFlags = 16;
pub const GST_SEGMENT_FLAG_SKIP: GstSegmentFlags = 16;
pub const GST_SEGMENT_FLAG_SEGMENT: GstSegmentFlags = 8;
pub const GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS: GstSegmentFlags = 128;
pub const GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO: GstSegmentFlags = 256;

pub type GstStackTraceFlags = c_uint;
pub const GST_STACK_TRACE_SHOW_FULL: GstStackTraceFlags = 1;

pub type GstStreamFlags = c_uint;
pub const GST_STREAM_FLAG_NONE: GstStreamFlags = 0;
pub const GST_STREAM_FLAG_SPARSE: GstStreamFlags = 1;
pub const GST_STREAM_FLAG_SELECT: GstStreamFlags = 2;
pub const GST_STREAM_FLAG_UNSELECT: GstStreamFlags = 4;

pub type GstStreamType = c_uint;
pub const GST_STREAM_TYPE_UNKNOWN: GstStreamType = 1;
pub const GST_STREAM_TYPE_AUDIO: GstStreamType = 2;
pub const GST_STREAM_TYPE_VIDEO: GstStreamType = 4;
pub const GST_STREAM_TYPE_CONTAINER: GstStreamType = 8;
pub const GST_STREAM_TYPE_TEXT: GstStreamType = 16;

pub type GstTracerValueFlags = c_uint;
pub const GST_TRACER_VALUE_FLAGS_NONE: GstTracerValueFlags = 0;
pub const GST_TRACER_VALUE_FLAGS_OPTIONAL: GstTracerValueFlags = 1;
pub const GST_TRACER_VALUE_FLAGS_AGGREGATED: GstTracerValueFlags = 2;

// Unions
#[repr(C)]
#[derive(Copy, Clone)]
pub union GstControlBinding_ABI {
    pub abi: GstControlBinding_ABI_abi,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstControlBinding_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlBinding_ABI @ {:?}", self as *const _))
         .field("abi", unsafe { &self.abi })
         .field("_gst_reserved", unsafe { &self._gst_reserved })
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union GstPadProbeInfo_ABI {
    pub _gst_reserved: [gpointer; 4],
    pub abi: GstPadProbeInfo_ABI_abi,
}

impl ::std::fmt::Debug for GstPadProbeInfo_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadProbeInfo_ABI @ {:?}", self as *const _))
         .field("_gst_reserved", unsafe { &self._gst_reserved })
         .field("abi", unsafe { &self.abi })
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union GstPadTemplate_ABI {
    pub _gst_reserved: [gpointer; 4],
    pub abi: GstPadTemplate_ABI_abi,
}

impl ::std::fmt::Debug for GstPadTemplate_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadTemplate_ABI @ {:?}", self as *const _))
         .field("_gst_reserved", unsafe { &self._gst_reserved })
         .field("abi", unsafe { &self.abi })
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union GstPad_ABI {
    pub _gst_reserved: [gpointer; 4],
    pub abi: GstPad_ABI_abi,
}

impl ::std::fmt::Debug for GstPad_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPad_ABI @ {:?}", self as *const _))
         .field("_gst_reserved", unsafe { &self._gst_reserved })
         .field("abi", unsafe { &self.abi })
         .finish()
    }
}

// Callbacks
pub type GstBufferForeachMetaFunc = Option<unsafe extern "C" fn(*mut GstBuffer, *mut *mut GstMeta, gpointer) -> gboolean>;
pub type GstBufferListFunc = Option<unsafe extern "C" fn(*mut *mut GstBuffer, c_uint, gpointer) -> gboolean>;
pub type GstBusFunc = Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage, gpointer) -> gboolean>;
pub type GstBusSyncHandler = Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage, gpointer) -> GstBusSyncReply>;
pub type GstCapsFilterMapFunc = Option<unsafe extern "C" fn(*mut GstCapsFeatures, *mut GstStructure, gpointer) -> gboolean>;
pub type GstCapsForeachFunc = Option<unsafe extern "C" fn(*mut GstCapsFeatures, *mut GstStructure, gpointer) -> gboolean>;
pub type GstCapsMapFunc = Option<unsafe extern "C" fn(*mut GstCapsFeatures, *mut GstStructure, gpointer) -> gboolean>;
pub type GstClockCallback = Option<unsafe extern "C" fn(*mut GstClock, GstClockTime, GstClockID, gpointer) -> gboolean>;
pub type GstControlBindingConvert = Option<unsafe extern "C" fn(*mut GstControlBinding, c_double, *mut gobject::GValue)>;
pub type GstControlSourceGetValue = Option<unsafe extern "C" fn(*mut GstControlSource, GstClockTime, *mut c_double) -> gboolean>;
pub type GstControlSourceGetValueArray = Option<unsafe extern "C" fn(*mut GstControlSource, GstClockTime, GstClockTime, c_uint, *mut c_double) -> gboolean>;
pub type GstDebugFuncPtr = Option<unsafe extern "C" fn()>;
pub type GstElementCallAsyncFunc = Option<unsafe extern "C" fn(*mut GstElement, gpointer)>;
pub type GstElementForeachPadFunc = Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad, gpointer) -> gboolean>;
pub type GstIteratorCopyFunction = Option<unsafe extern "C" fn(*const GstIterator, *mut GstIterator)>;
pub type GstIteratorFoldFunction = Option<unsafe extern "C" fn(*const gobject::GValue, *mut gobject::GValue, gpointer) -> gboolean>;
pub type GstIteratorForeachFunction = Option<unsafe extern "C" fn(*const gobject::GValue, gpointer)>;
pub type GstIteratorFreeFunction = Option<unsafe extern "C" fn(*mut GstIterator)>;
pub type GstIteratorItemFunction = Option<unsafe extern "C" fn(*mut GstIterator, *const gobject::GValue) -> GstIteratorItem>;
pub type GstIteratorNextFunction = Option<unsafe extern "C" fn(*mut GstIterator, *mut gobject::GValue) -> GstIteratorResult>;
pub type GstIteratorResyncFunction = Option<unsafe extern "C" fn(*mut GstIterator)>;
pub type GstLogFunction = Option<unsafe extern "C" fn(*mut GstDebugCategory, GstDebugLevel, *const c_char, *const c_char, c_int, *mut gobject::GObject, *mut GstDebugMessage, gpointer)>;
pub type GstMemoryCopyFunction = Option<unsafe extern "C" fn(*mut GstMemory, ssize_t, ssize_t) -> *mut GstMemory>;
pub type GstMemoryIsSpanFunction = Option<unsafe extern "C" fn(*mut GstMemory, *mut GstMemory, *mut size_t) -> gboolean>;
pub type GstMemoryMapFullFunction = Option<unsafe extern "C" fn(*mut GstMemory, *mut GstMapInfo, size_t) -> gpointer>;
pub type GstMemoryMapFunction = Option<unsafe extern "C" fn(*mut GstMemory, size_t, GstMapFlags) -> gpointer>;
pub type GstMemoryShareFunction = Option<unsafe extern "C" fn(*mut GstMemory, ssize_t, ssize_t) -> *mut GstMemory>;
pub type GstMemoryUnmapFullFunction = Option<unsafe extern "C" fn(*mut GstMemory, *mut GstMapInfo)>;
pub type GstMemoryUnmapFunction = Option<unsafe extern "C" fn(*mut GstMemory)>;
pub type GstMetaFreeFunction = Option<unsafe extern "C" fn(*mut GstMeta, *mut GstBuffer)>;
pub type GstMetaInitFunction = Option<unsafe extern "C" fn(*mut GstMeta, gpointer, *mut GstBuffer) -> gboolean>;
pub type GstMetaTransformFunction = Option<unsafe extern "C" fn(*mut GstBuffer, *mut GstMeta, *mut GstBuffer, glib::GQuark, gpointer) -> gboolean>;
pub type GstMiniObjectCopyFunction = Option<unsafe extern "C" fn(*const GstMiniObject) -> *mut GstMiniObject>;
pub type GstMiniObjectDisposeFunction = Option<unsafe extern "C" fn(*mut GstMiniObject) -> gboolean>;
pub type GstMiniObjectFreeFunction = Option<unsafe extern "C" fn(*mut GstMiniObject)>;
pub type GstMiniObjectNotify = Option<unsafe extern "C" fn(gpointer, *mut GstMiniObject)>;
pub type GstPadActivateFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject) -> gboolean>;
pub type GstPadActivateModeFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, GstPadMode, gboolean) -> gboolean>;
pub type GstPadChainFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstBuffer) -> GstFlowReturn>;
pub type GstPadChainListFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstBufferList) -> GstFlowReturn>;
pub type GstPadEventFullFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstEvent) -> GstFlowReturn>;
pub type GstPadEventFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstEvent) -> gboolean>;
pub type GstPadForwardFunction = Option<unsafe extern "C" fn(*mut GstPad, gpointer) -> gboolean>;
pub type GstPadGetRangeFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, u64, c_uint, *mut *mut GstBuffer) -> GstFlowReturn>;
pub type GstPadIterIntLinkFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject) -> *mut GstIterator>;
pub type GstPadLinkFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstPad) -> GstPadLinkReturn>;
pub type GstPadProbeCallback = Option<unsafe extern "C" fn(*mut GstPad, *mut GstPadProbeInfo, gpointer) -> GstPadProbeReturn>;
pub type GstPadQueryFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject, *mut GstQuery) -> gboolean>;
pub type GstPadStickyEventsForeachFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut *mut GstEvent, gpointer) -> gboolean>;
pub type GstPadUnlinkFunction = Option<unsafe extern "C" fn(*mut GstPad, *mut GstObject)>;
pub type GstPluginFeatureFilter = Option<unsafe extern "C" fn(*mut GstPluginFeature, gpointer) -> gboolean>;
pub type GstPluginFilter = Option<unsafe extern "C" fn(*mut GstPlugin, gpointer) -> gboolean>;
pub type GstPluginInitFullFunc = Option<unsafe extern "C" fn(*mut GstPlugin, gpointer) -> gboolean>;
pub type GstPluginInitFunc = Option<unsafe extern "C" fn(*mut GstPlugin) -> gboolean>;
pub type GstPromiseChangeFunc = Option<unsafe extern "C" fn(*mut GstPromise, gpointer)>;
pub type GstStructureFilterMapFunc = Option<unsafe extern "C" fn(glib::GQuark, *mut gobject::GValue, gpointer) -> gboolean>;
pub type GstStructureForeachFunc = Option<unsafe extern "C" fn(glib::GQuark, *const gobject::GValue, gpointer) -> gboolean>;
pub type GstStructureMapFunc = Option<unsafe extern "C" fn(glib::GQuark, *mut gobject::GValue, gpointer) -> gboolean>;
pub type GstTagForeachFunc = Option<unsafe extern "C" fn(*const GstTagList, *const c_char, gpointer)>;
pub type GstTagMergeFunc = Option<unsafe extern "C" fn(*mut gobject::GValue, *const gobject::GValue)>;
pub type GstTaskFunction = Option<unsafe extern "C" fn(gpointer)>;
pub type GstTaskPoolFunction = Option<unsafe extern "C" fn(*mut c_void)>;
pub type GstTaskThreadFunc = Option<unsafe extern "C" fn(*mut GstTask, *mut glib::GThread, gpointer)>;
pub type GstTypeFindFunction = Option<unsafe extern "C" fn(*mut GstTypeFind, gpointer)>;
pub type GstValueCompareFunc = Option<unsafe extern "C" fn(*const gobject::GValue, *const gobject::GValue) -> c_int>;
pub type GstValueDeserializeFunc = Option<unsafe extern "C" fn(*mut gobject::GValue, *const c_char) -> gboolean>;
pub type GstValueSerializeFunc = Option<unsafe extern "C" fn(*const gobject::GValue) -> *mut c_char>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstAllocationParams {
    pub flags: GstMemoryFlags,
    pub align: size_t,
    pub prefix: size_t,
    pub padding: size_t,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAllocationParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAllocationParams @ {:?}", self as *const _))
         .field("flags", &self.flags)
         .field("align", &self.align)
         .field("prefix", &self.prefix)
         .field("padding", &self.padding)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstAllocatorClass {
    pub object_class: GstObjectClass,
    pub alloc: Option<unsafe extern "C" fn(*mut GstAllocator, size_t, *mut GstAllocationParams) -> *mut GstMemory>,
    pub free: Option<unsafe extern "C" fn(*mut GstAllocator, *mut GstMemory)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAllocatorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAllocatorClass @ {:?}", self as *const _))
         .field("object_class", &self.object_class)
         .field("alloc", &self.alloc)
         .field("free", &self.free)
         .finish()
    }
}

#[repr(C)]
pub struct GstAllocatorPrivate(c_void);

impl ::std::fmt::Debug for GstAllocatorPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAllocatorPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstAtomicQueue(c_void);

impl ::std::fmt::Debug for GstAtomicQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAtomicQueue @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstBinClass {
    pub parent_class: GstElementClass,
    pub pool: *mut glib::GThreadPool,
    pub element_added: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement)>,
    pub element_removed: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement)>,
    pub add_element: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement) -> gboolean>,
    pub remove_element: Option<unsafe extern "C" fn(*mut GstBin, *mut GstElement) -> gboolean>,
    pub handle_message: Option<unsafe extern "C" fn(*mut GstBin, *mut GstMessage)>,
    pub do_latency: Option<unsafe extern "C" fn(*mut GstBin) -> gboolean>,
    pub deep_element_added: Option<unsafe extern "C" fn(*mut GstBin, *mut GstBin, *mut GstElement)>,
    pub deep_element_removed: Option<unsafe extern "C" fn(*mut GstBin, *mut GstBin, *mut GstElement)>,
    pub _gst_reserved: [gpointer; 2],
}

impl ::std::fmt::Debug for GstBinClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBinClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("element_added", &self.element_added)
         .field("element_removed", &self.element_removed)
         .field("add_element", &self.add_element)
         .field("remove_element", &self.remove_element)
         .field("handle_message", &self.handle_message)
         .field("do_latency", &self.do_latency)
         .field("deep_element_added", &self.deep_element_added)
         .field("deep_element_removed", &self.deep_element_removed)
         .finish()
    }
}

#[repr(C)]
pub struct GstBinPrivate(c_void);

impl ::std::fmt::Debug for GstBinPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBinPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstBuffer {
    pub mini_object: GstMiniObject,
    pub pool: *mut GstBufferPool,
    pub pts: GstClockTime,
    pub dts: GstClockTime,
    pub duration: GstClockTime,
    pub offset: u64,
    pub offset_end: u64,
}

impl ::std::fmt::Debug for GstBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBuffer @ {:?}", self as *const _))
         .field("mini_object", &self.mini_object)
         .field("pool", &self.pool)
         .field("pts", &self.pts)
         .field("dts", &self.dts)
         .field("duration", &self.duration)
         .field("offset", &self.offset)
         .field("offset_end", &self.offset_end)
         .finish()
    }
}

#[repr(C)]
pub struct GstBufferList(c_void);

impl ::std::fmt::Debug for GstBufferList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBufferList @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstBufferPoolAcquireParams {
    pub format: GstFormat,
    pub start: i64,
    pub stop: i64,
    pub flags: GstBufferPoolAcquireFlags,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBufferPoolAcquireParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBufferPoolAcquireParams @ {:?}", self as *const _))
         .field("format", &self.format)
         .field("start", &self.start)
         .field("stop", &self.stop)
         .field("flags", &self.flags)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstBufferPoolClass {
    pub object_class: GstObjectClass,
    pub get_options: Option<unsafe extern "C" fn(*mut GstBufferPool) -> *mut *mut c_char>,
    pub set_config: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstStructure) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstBufferPool) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstBufferPool) -> gboolean>,
    pub acquire_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut *mut GstBuffer, *mut GstBufferPoolAcquireParams) -> GstFlowReturn>,
    pub alloc_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut *mut GstBuffer, *mut GstBufferPoolAcquireParams) -> GstFlowReturn>,
    pub reset_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstBuffer)>,
    pub release_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstBuffer)>,
    pub free_buffer: Option<unsafe extern "C" fn(*mut GstBufferPool, *mut GstBuffer)>,
    pub flush_start: Option<unsafe extern "C" fn(*mut GstBufferPool)>,
    pub flush_stop: Option<unsafe extern "C" fn(*mut GstBufferPool)>,
    pub _gst_reserved: [gpointer; 2],
}

impl ::std::fmt::Debug for GstBufferPoolClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBufferPoolClass @ {:?}", self as *const _))
         .field("object_class", &self.object_class)
         .field("get_options", &self.get_options)
         .field("set_config", &self.set_config)
         .field("start", &self.start)
         .field("stop", &self.stop)
         .field("acquire_buffer", &self.acquire_buffer)
         .field("alloc_buffer", &self.alloc_buffer)
         .field("reset_buffer", &self.reset_buffer)
         .field("release_buffer", &self.release_buffer)
         .field("free_buffer", &self.free_buffer)
         .field("flush_start", &self.flush_start)
         .field("flush_stop", &self.flush_stop)
         .finish()
    }
}

#[repr(C)]
pub struct GstBufferPoolPrivate(c_void);

impl ::std::fmt::Debug for GstBufferPoolPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBufferPoolPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstBusClass {
    pub parent_class: GstObjectClass,
    pub message: Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage)>,
    pub sync_message: Option<unsafe extern "C" fn(*mut GstBus, *mut GstMessage)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBusClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBusClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("message", &self.message)
         .field("sync_message", &self.sync_message)
         .finish()
    }
}

#[repr(C)]
pub struct GstBusPrivate(c_void);

impl ::std::fmt::Debug for GstBusPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBusPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstCaps {
    pub mini_object: GstMiniObject,
}

impl ::std::fmt::Debug for GstCaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstCaps @ {:?}", self as *const _))
         .field("mini_object", &self.mini_object)
         .finish()
    }
}

#[repr(C)]
pub struct GstCapsFeatures(c_void);

impl ::std::fmt::Debug for GstCapsFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstCapsFeatures @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstChildProxyInterface {
    pub parent: gobject::GTypeInterface,
    pub get_child_by_name: Option<unsafe extern "C" fn(*mut GstChildProxy, *const c_char) -> *mut gobject::GObject>,
    pub get_child_by_index: Option<unsafe extern "C" fn(*mut GstChildProxy, c_uint) -> *mut gobject::GObject>,
    pub get_children_count: Option<unsafe extern "C" fn(*mut GstChildProxy) -> c_uint>,
    pub child_added: Option<unsafe extern "C" fn(*mut GstChildProxy, *mut gobject::GObject, *const c_char)>,
    pub child_removed: Option<unsafe extern "C" fn(*mut GstChildProxy, *mut gobject::GObject, *const c_char)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstChildProxyInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstChildProxyInterface @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get_child_by_name", &self.get_child_by_name)
         .field("get_child_by_index", &self.get_child_by_index)
         .field("get_children_count", &self.get_children_count)
         .field("child_added", &self.child_added)
         .field("child_removed", &self.child_removed)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstClockClass {
    pub parent_class: GstObjectClass,
    pub change_resolution: Option<unsafe extern "C" fn(*mut GstClock, GstClockTime, GstClockTime) -> GstClockTime>,
    pub get_resolution: Option<unsafe extern "C" fn(*mut GstClock) -> GstClockTime>,
    pub get_internal_time: Option<unsafe extern "C" fn(*mut GstClock) -> GstClockTime>,
    pub wait: Option<unsafe extern "C" fn(*mut GstClock, *mut GstClockEntry, *mut GstClockTimeDiff) -> GstClockReturn>,
    pub wait_async: Option<unsafe extern "C" fn(*mut GstClock, *mut GstClockEntry) -> GstClockReturn>,
    pub unschedule: Option<unsafe extern "C" fn(*mut GstClock, *mut GstClockEntry)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstClockClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstClockClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("change_resolution", &self.change_resolution)
         .field("get_resolution", &self.get_resolution)
         .field("get_internal_time", &self.get_internal_time)
         .field("wait", &self.wait)
         .field("wait_async", &self.wait_async)
         .field("unschedule", &self.unschedule)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstClockEntry {
    pub refcount: c_int,
    pub clock: *mut GstClock,
    pub type_: GstClockEntryType,
    pub time: GstClockTime,
    pub interval: GstClockTime,
    pub status: GstClockReturn,
    pub func: GstClockCallback,
    pub user_data: gpointer,
    pub destroy_data: glib::GDestroyNotify,
    pub unscheduled: gboolean,
    pub woken_up: gboolean,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstClockEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstClockEntry @ {:?}", self as *const _))
         .field("refcount", &self.refcount)
         .field("clock", &self.clock)
         .field("type_", &self.type_)
         .field("time", &self.time)
         .field("interval", &self.interval)
         .field("status", &self.status)
         .field("func", &self.func)
         .field("user_data", &self.user_data)
         .field("destroy_data", &self.destroy_data)
         .field("unscheduled", &self.unscheduled)
         .field("woken_up", &self.woken_up)
         .finish()
    }
}

#[repr(C)]
pub struct GstClockPrivate(c_void);

impl ::std::fmt::Debug for GstClockPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstClockPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstContext(c_void);

impl ::std::fmt::Debug for GstContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstContext @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstControlBindingClass {
    pub parent_class: GstObjectClass,
    pub sync_values: Option<unsafe extern "C" fn(*mut GstControlBinding, *mut GstObject, GstClockTime, GstClockTime) -> gboolean>,
    pub get_value: Option<unsafe extern "C" fn(*mut GstControlBinding, GstClockTime) -> *mut gobject::GValue>,
    pub get_value_array: Option<unsafe extern "C" fn(*mut GstControlBinding, GstClockTime, GstClockTime, c_uint, gpointer) -> gboolean>,
    pub get_g_value_array: Option<unsafe extern "C" fn(*mut GstControlBinding, GstClockTime, GstClockTime, c_uint, *mut gobject::GValue) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstControlBindingClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlBindingClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("sync_values", &self.sync_values)
         .field("get_value", &self.get_value)
         .field("get_value_array", &self.get_value_array)
         .field("get_g_value_array", &self.get_g_value_array)
         .finish()
    }
}

#[repr(C)]
pub struct GstControlBindingPrivate(c_void);

impl ::std::fmt::Debug for GstControlBindingPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlBindingPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstControlBinding_ABI_abi {
    pub priv_: *mut GstControlBindingPrivate,
}

impl ::std::fmt::Debug for GstControlBinding_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlBinding_ABI_abi @ {:?}", self as *const _))
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstControlSourceClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstControlSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlSourceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GstDateTime(c_void);

impl ::std::fmt::Debug for GstDateTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDateTime @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstDebugCategory {
    pub threshold: c_int,
    pub color: c_uint,
    pub name: *const c_char,
    pub description: *const c_char,
}

impl ::std::fmt::Debug for GstDebugCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDebugCategory @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstDebugMessage(c_void);

impl ::std::fmt::Debug for GstDebugMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDebugMessage @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstDeviceClass {
    pub parent_class: GstObjectClass,
    pub create_element: Option<unsafe extern "C" fn(*mut GstDevice, *const c_char) -> *mut GstElement>,
    pub reconfigure_element: Option<unsafe extern "C" fn(*mut GstDevice, *mut GstElement) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("create_element", &self.create_element)
         .field("reconfigure_element", &self.reconfigure_element)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstDeviceMonitorClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceMonitorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceMonitorClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GstDeviceMonitorPrivate(c_void);

impl ::std::fmt::Debug for GstDeviceMonitorPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceMonitorPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstDevicePrivate(c_void);

impl ::std::fmt::Debug for GstDevicePrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDevicePrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstDeviceProviderClass {
    pub parent_class: GstObjectClass,
    pub factory: *mut GstDeviceProviderFactory,
    pub probe: Option<unsafe extern "C" fn(*mut GstDeviceProvider) -> *mut glib::GList>,
    pub start: Option<unsafe extern "C" fn(*mut GstDeviceProvider) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstDeviceProvider)>,
    pub metadata: gpointer,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceProviderClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceProviderClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("factory", &self.factory)
         .field("probe", &self.probe)
         .field("start", &self.start)
         .field("stop", &self.stop)
         .finish()
    }
}

#[repr(C)]
pub struct GstDeviceProviderFactoryClass(c_void);

impl ::std::fmt::Debug for GstDeviceProviderFactoryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceProviderFactoryClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstDeviceProviderPrivate(c_void);

impl ::std::fmt::Debug for GstDeviceProviderPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceProviderPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstDynamicTypeFactoryClass(c_void);

impl ::std::fmt::Debug for GstDynamicTypeFactoryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDynamicTypeFactoryClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstElementClass {
    pub parent_class: GstObjectClass,
    pub metadata: gpointer,
    pub elementfactory: *mut GstElementFactory,
    pub padtemplates: *mut glib::GList,
    pub numpadtemplates: c_int,
    pub pad_templ_cookie: u32,
    pub pad_added: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad)>,
    pub pad_removed: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad)>,
    pub no_more_pads: Option<unsafe extern "C" fn(*mut GstElement)>,
    pub request_new_pad: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPadTemplate, *const c_char, *const GstCaps) -> *mut GstPad>,
    pub release_pad: Option<unsafe extern "C" fn(*mut GstElement, *mut GstPad)>,
    pub get_state: Option<unsafe extern "C" fn(*mut GstElement, *mut GstState, *mut GstState, GstClockTime) -> GstStateChangeReturn>,
    pub set_state: Option<unsafe extern "C" fn(*mut GstElement, GstState) -> GstStateChangeReturn>,
    pub change_state: Option<unsafe extern "C" fn(*mut GstElement, GstStateChange) -> GstStateChangeReturn>,
    pub state_changed: Option<unsafe extern "C" fn(*mut GstElement, GstState, GstState, GstState)>,
    pub set_bus: Option<unsafe extern "C" fn(*mut GstElement, *mut GstBus)>,
    pub provide_clock: Option<unsafe extern "C" fn(*mut GstElement) -> *mut GstClock>,
    pub set_clock: Option<unsafe extern "C" fn(*mut GstElement, *mut GstClock) -> gboolean>,
    pub send_event: Option<unsafe extern "C" fn(*mut GstElement, *mut GstEvent) -> gboolean>,
    pub query: Option<unsafe extern "C" fn(*mut GstElement, *mut GstQuery) -> gboolean>,
    pub post_message: Option<unsafe extern "C" fn(*mut GstElement, *mut GstMessage) -> gboolean>,
    pub set_context: Option<unsafe extern "C" fn(*mut GstElement, *mut GstContext)>,
    pub _gst_reserved: [gpointer; 18],
}

impl ::std::fmt::Debug for GstElementClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstElementClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("metadata", &self.metadata)
         .field("elementfactory", &self.elementfactory)
         .field("padtemplates", &self.padtemplates)
         .field("numpadtemplates", &self.numpadtemplates)
         .field("pad_templ_cookie", &self.pad_templ_cookie)
         .field("pad_added", &self.pad_added)
         .field("pad_removed", &self.pad_removed)
         .field("no_more_pads", &self.no_more_pads)
         .field("request_new_pad", &self.request_new_pad)
         .field("release_pad", &self.release_pad)
         .field("get_state", &self.get_state)
         .field("set_state", &self.set_state)
         .field("change_state", &self.change_state)
         .field("state_changed", &self.state_changed)
         .field("set_bus", &self.set_bus)
         .field("provide_clock", &self.provide_clock)
         .field("set_clock", &self.set_clock)
         .field("send_event", &self.send_event)
         .field("query", &self.query)
         .field("post_message", &self.post_message)
         .field("set_context", &self.set_context)
         .finish()
    }
}

#[repr(C)]
pub struct GstElementFactoryClass(c_void);

impl ::std::fmt::Debug for GstElementFactoryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstElementFactoryClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstEvent {
    pub mini_object: GstMiniObject,
    pub type_: GstEventType,
    pub timestamp: u64,
    pub seqnum: u32,
}

impl ::std::fmt::Debug for GstEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstEvent @ {:?}", self as *const _))
         .field("mini_object", &self.mini_object)
         .field("type_", &self.type_)
         .field("timestamp", &self.timestamp)
         .field("seqnum", &self.seqnum)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstFormatDefinition {
    pub value: GstFormat,
    pub nick: *const c_char,
    pub description: *const c_char,
    pub quark: glib::GQuark,
}

impl ::std::fmt::Debug for GstFormatDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstFormatDefinition @ {:?}", self as *const _))
         .field("value", &self.value)
         .field("nick", &self.nick)
         .field("description", &self.description)
         .field("quark", &self.quark)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstGhostPadClass {
    pub parent_class: GstProxyPadClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstGhostPadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstGhostPadClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GstGhostPadPrivate(c_void);

impl ::std::fmt::Debug for GstGhostPadPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstGhostPadPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstIterator {
    pub copy: GstIteratorCopyFunction,
    pub next: GstIteratorNextFunction,
    pub item: GstIteratorItemFunction,
    pub resync: GstIteratorResyncFunction,
    pub free: GstIteratorFreeFunction,
    pub pushed: *mut GstIterator,
    pub type_: GType,
    pub lock: *mut glib::GMutex,
    pub cookie: u32,
    pub master_cookie: *mut u32,
    pub size: c_uint,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstIterator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstIterator @ {:?}", self as *const _))
         .field("copy", &self.copy)
         .field("next", &self.next)
         .field("item", &self.item)
         .field("resync", &self.resync)
         .field("free", &self.free)
         .field("pushed", &self.pushed)
         .field("type_", &self.type_)
         .field("lock", &self.lock)
         .field("cookie", &self.cookie)
         .field("master_cookie", &self.master_cookie)
         .field("size", &self.size)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstMapInfo {
    pub memory: *mut GstMemory,
    pub flags: GstMapFlags,
    pub data: *mut u8,
    pub size: size_t,
    pub maxsize: size_t,
    pub user_data: [gpointer; 4],
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstMapInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMapInfo @ {:?}", self as *const _))
         .field("memory", &self.memory)
         .field("flags", &self.flags)
         .field("data", &self.data)
         .field("size", &self.size)
         .field("maxsize", &self.maxsize)
         .field("user_data", &self.user_data)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstMemory {
    pub mini_object: GstMiniObject,
    pub allocator: *mut GstAllocator,
    pub parent: *mut GstMemory,
    pub maxsize: size_t,
    pub align: size_t,
    pub offset: size_t,
    pub size: size_t,
}

impl ::std::fmt::Debug for GstMemory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMemory @ {:?}", self as *const _))
         .field("mini_object", &self.mini_object)
         .field("allocator", &self.allocator)
         .field("parent", &self.parent)
         .field("maxsize", &self.maxsize)
         .field("align", &self.align)
         .field("offset", &self.offset)
         .field("size", &self.size)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstMessage {
    pub mini_object: GstMiniObject,
    pub type_: GstMessageType,
    pub timestamp: u64,
    pub src: *mut GstObject,
    pub seqnum: u32,
    pub lock: glib::GMutex,
    pub cond: glib::GCond,
}

impl ::std::fmt::Debug for GstMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMessage @ {:?}", self as *const _))
         .field("mini_object", &self.mini_object)
         .field("type_", &self.type_)
         .field("timestamp", &self.timestamp)
         .field("src", &self.src)
         .field("seqnum", &self.seqnum)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstMeta {
    pub flags: GstMetaFlags,
    pub info: *const GstMetaInfo,
}

impl ::std::fmt::Debug for GstMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMeta @ {:?}", self as *const _))
         .field("flags", &self.flags)
         .field("info", &self.info)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstMetaInfo {
    pub api: GType,
    pub type_: GType,
    pub size: size_t,
    pub init_func: GstMetaInitFunction,
    pub free_func: GstMetaFreeFunction,
    pub transform_func: GstMetaTransformFunction,
}

impl ::std::fmt::Debug for GstMetaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMetaInfo @ {:?}", self as *const _))
         .field("api", &self.api)
         .field("type_", &self.type_)
         .field("size", &self.size)
         .field("init_func", &self.init_func)
         .field("free_func", &self.free_func)
         .field("transform_func", &self.transform_func)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstMetaTransformCopy {
    pub region: gboolean,
    pub offset: size_t,
    pub size: size_t,
}

impl ::std::fmt::Debug for GstMetaTransformCopy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMetaTransformCopy @ {:?}", self as *const _))
         .field("region", &self.region)
         .field("offset", &self.offset)
         .field("size", &self.size)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstMiniObject {
    pub type_: GType,
    pub refcount: c_int,
    pub lockstate: c_int,
    pub flags: c_uint,
    pub copy: GstMiniObjectCopyFunction,
    pub dispose: GstMiniObjectDisposeFunction,
    pub free: GstMiniObjectFreeFunction,
    pub n_qdata: c_uint,
    pub qdata: gpointer,
}

impl ::std::fmt::Debug for GstMiniObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstMiniObject @ {:?}", self as *const _))
         .field("type_", &self.type_)
         .field("refcount", &self.refcount)
         .field("lockstate", &self.lockstate)
         .field("flags", &self.flags)
         .field("copy", &self.copy)
         .field("dispose", &self.dispose)
         .field("free", &self.free)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstObjectClass {
    pub parent_class: gobject::GInitiallyUnownedClass,
    pub path_string_separator: *const c_char,
    pub deep_notify: Option<unsafe extern "C" fn(*mut GstObject, *mut GstObject, *mut gobject::GParamSpec)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstObjectClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("path_string_separator", &self.path_string_separator)
         .field("deep_notify", &self.deep_notify)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPadClass {
    pub parent_class: GstObjectClass,
    pub linked: Option<unsafe extern "C" fn(*mut GstPad, *mut GstPad)>,
    pub unlinked: Option<unsafe extern "C" fn(*mut GstPad, *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("linked", &self.linked)
         .field("unlinked", &self.unlinked)
         .finish()
    }
}

#[repr(C)]
pub struct GstPadPrivate(c_void);

impl ::std::fmt::Debug for GstPadPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPadProbeInfo {
    pub type_: GstPadProbeType,
    pub id: c_ulong,
    pub data: gpointer,
    pub offset: u64,
    pub size: c_uint,
    pub ABI: GstPadProbeInfo_ABI,
}

impl ::std::fmt::Debug for GstPadProbeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadProbeInfo @ {:?}", self as *const _))
         .field("type_", &self.type_)
         .field("id", &self.id)
         .field("data", &self.data)
         .field("offset", &self.offset)
         .field("size", &self.size)
         .field("ABI", &self.ABI)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPadProbeInfo_ABI_abi {
    pub flow_ret: GstFlowReturn,
}

impl ::std::fmt::Debug for GstPadProbeInfo_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadProbeInfo_ABI_abi @ {:?}", self as *const _))
         .field("flow_ret", &self.flow_ret)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPadTemplateClass {
    pub parent_class: GstObjectClass,
    pub pad_created: Option<unsafe extern "C" fn(*mut GstPadTemplate, *mut GstPad)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPadTemplateClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadTemplateClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("pad_created", &self.pad_created)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPadTemplate_ABI_abi {
    pub gtype: GType,
}

impl ::std::fmt::Debug for GstPadTemplate_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadTemplate_ABI_abi @ {:?}", self as *const _))
         .field("gtype", &self.gtype)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPad_ABI_abi {
    pub last_flowret: GstFlowReturn,
    pub eventfullfunc: GstPadEventFullFunction,
}

impl ::std::fmt::Debug for GstPad_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPad_ABI_abi @ {:?}", self as *const _))
         .field("last_flowret", &self.last_flowret)
         .field("eventfullfunc", &self.eventfullfunc)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstParamSpecArray {
    pub parent_instance: gobject::GParamSpec,
    pub element_spec: *mut gobject::GParamSpec,
}

impl ::std::fmt::Debug for GstParamSpecArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParamSpecArray @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .field("element_spec", &self.element_spec)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstParamSpecFraction {
    pub parent_instance: gobject::GParamSpec,
    pub min_num: c_int,
    pub min_den: c_int,
    pub max_num: c_int,
    pub max_den: c_int,
    pub def_num: c_int,
    pub def_den: c_int,
}

impl ::std::fmt::Debug for GstParamSpecFraction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParamSpecFraction @ {:?}", self as *const _))
         .field("parent_instance", &self.parent_instance)
         .field("min_num", &self.min_num)
         .field("min_den", &self.min_den)
         .field("max_num", &self.max_num)
         .field("max_den", &self.max_den)
         .field("def_num", &self.def_num)
         .field("def_den", &self.def_den)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstParentBufferMeta {
    pub parent: GstMeta,
    pub buffer: *mut GstBuffer,
}

impl ::std::fmt::Debug for GstParentBufferMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParentBufferMeta @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("buffer", &self.buffer)
         .finish()
    }
}

#[repr(C)]
pub struct GstParseContext(c_void);

impl ::std::fmt::Debug for GstParseContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParseContext @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPipelineClass {
    pub parent_class: GstBinClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPipelineClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPipelineClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GstPipelinePrivate(c_void);

impl ::std::fmt::Debug for GstPipelinePrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPipelinePrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstPluginClass(c_void);

impl ::std::fmt::Debug for GstPluginClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPluginClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPluginDesc {
    pub major_version: c_int,
    pub minor_version: c_int,
    pub name: *const c_char,
    pub description: *const c_char,
    pub plugin_init: GstPluginInitFunc,
    pub version: *const c_char,
    pub license: *const c_char,
    pub source: *const c_char,
    pub package: *const c_char,
    pub origin: *const c_char,
    pub release_datetime: *const c_char,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPluginDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPluginDesc @ {:?}", self as *const _))
         .field("major_version", &self.major_version)
         .field("minor_version", &self.minor_version)
         .field("name", &self.name)
         .field("description", &self.description)
         .field("plugin_init", &self.plugin_init)
         .field("version", &self.version)
         .field("license", &self.license)
         .field("source", &self.source)
         .field("package", &self.package)
         .field("origin", &self.origin)
         .field("release_datetime", &self.release_datetime)
         .finish()
    }
}

#[repr(C)]
pub struct GstPluginFeatureClass(c_void);

impl ::std::fmt::Debug for GstPluginFeatureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPluginFeatureClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstPoll(c_void);

impl ::std::fmt::Debug for GstPoll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPoll @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPollFD {
    pub fd: c_int,
    pub idx: c_int,
}

impl ::std::fmt::Debug for GstPollFD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPollFD @ {:?}", self as *const _))
         .field("fd", &self.fd)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPresetInterface {
    pub parent: gobject::GTypeInterface,
    pub get_preset_names: Option<unsafe extern "C" fn(*mut GstPreset) -> *mut *mut c_char>,
    pub get_property_names: Option<unsafe extern "C" fn(*mut GstPreset) -> *mut *mut c_char>,
    pub load_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char) -> gboolean>,
    pub save_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char) -> gboolean>,
    pub rename_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char, *const c_char) -> gboolean>,
    pub delete_preset: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char) -> gboolean>,
    pub set_meta: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char, *const c_char, *mut *mut c_char) -> gboolean>,
    pub get_meta: Option<unsafe extern "C" fn(*mut GstPreset, *const c_char, *const c_char, *mut *mut c_char) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPresetInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPresetInterface @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get_preset_names", &self.get_preset_names)
         .field("get_property_names", &self.get_property_names)
         .field("load_preset", &self.load_preset)
         .field("save_preset", &self.save_preset)
         .field("rename_preset", &self.rename_preset)
         .field("delete_preset", &self.delete_preset)
         .field("set_meta", &self.set_meta)
         .field("get_meta", &self.get_meta)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPromise {
    pub parent: GstMiniObject,
}

impl ::std::fmt::Debug for GstPromise {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPromise @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstProtectionMeta {
    pub meta: GstMeta,
    pub info: *mut GstStructure,
}

impl ::std::fmt::Debug for GstProtectionMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstProtectionMeta @ {:?}", self as *const _))
         .field("meta", &self.meta)
         .field("info", &self.info)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstProxyPadClass {
    pub parent_class: GstPadClass,
    pub _gst_reserved: [gpointer; 1],
}

impl ::std::fmt::Debug for GstProxyPadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstProxyPadClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GstProxyPadPrivate(c_void);

impl ::std::fmt::Debug for GstProxyPadPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstProxyPadPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstQuery {
    pub mini_object: GstMiniObject,
    pub type_: GstQueryType,
}

impl ::std::fmt::Debug for GstQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstQuery @ {:?}", self as *const _))
         .field("mini_object", &self.mini_object)
         .field("type_", &self.type_)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstReferenceTimestampMeta {
    pub parent: GstMeta,
    pub reference: *mut GstCaps,
    pub timestamp: GstClockTime,
    pub duration: GstClockTime,
}

impl ::std::fmt::Debug for GstReferenceTimestampMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstReferenceTimestampMeta @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("reference", &self.reference)
         .field("timestamp", &self.timestamp)
         .field("duration", &self.duration)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstRegistryClass {
    pub parent_class: GstObjectClass,
}

impl ::std::fmt::Debug for GstRegistryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstRegistryClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GstRegistryPrivate(c_void);

impl ::std::fmt::Debug for GstRegistryPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstRegistryPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstSample(c_void);

impl ::std::fmt::Debug for GstSample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSample @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstSegment {
    pub flags: GstSegmentFlags,
    pub rate: c_double,
    pub applied_rate: c_double,
    pub format: GstFormat,
    pub base: u64,
    pub offset: u64,
    pub start: u64,
    pub stop: u64,
    pub time: u64,
    pub position: u64,
    pub duration: u64,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstSegment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSegment @ {:?}", self as *const _))
         .field("flags", &self.flags)
         .field("rate", &self.rate)
         .field("applied_rate", &self.applied_rate)
         .field("format", &self.format)
         .field("base", &self.base)
         .field("offset", &self.offset)
         .field("start", &self.start)
         .field("stop", &self.stop)
         .field("time", &self.time)
         .field("position", &self.position)
         .field("duration", &self.duration)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstStaticCaps {
    pub caps: *mut GstCaps,
    pub string: *const c_char,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStaticCaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStaticCaps @ {:?}", self as *const _))
         .field("caps", &self.caps)
         .field("string", &self.string)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstStaticPadTemplate {
    pub name_template: *const c_char,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub static_caps: GstStaticCaps,
}

impl ::std::fmt::Debug for GstStaticPadTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStaticPadTemplate @ {:?}", self as *const _))
         .field("name_template", &self.name_template)
         .field("direction", &self.direction)
         .field("presence", &self.presence)
         .field("static_caps", &self.static_caps)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstStreamClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStreamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStreamClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstStreamCollectionClass {
    pub parent_class: GstObjectClass,
    pub stream_notify: Option<unsafe extern "C" fn(*mut GstStreamCollection, *mut GstStream, *mut gobject::GParamSpec)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStreamCollectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStreamCollectionClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("stream_notify", &self.stream_notify)
         .finish()
    }
}

#[repr(C)]
pub struct GstStreamCollectionPrivate(c_void);

impl ::std::fmt::Debug for GstStreamCollectionPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStreamCollectionPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstStreamPrivate(c_void);

impl ::std::fmt::Debug for GstStreamPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStreamPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstStructure {
    pub type_: GType,
    pub name: glib::GQuark,
}

impl ::std::fmt::Debug for GstStructure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStructure @ {:?}", self as *const _))
         .field("type_", &self.type_)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstSystemClockClass {
    pub parent_class: GstClockClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstSystemClockClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSystemClockClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GstSystemClockPrivate(c_void);

impl ::std::fmt::Debug for GstSystemClockPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSystemClockPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTagList {
    pub mini_object: GstMiniObject,
}

impl ::std::fmt::Debug for GstTagList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTagList @ {:?}", self as *const _))
         .field("mini_object", &self.mini_object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTagSetterInterface {
    pub g_iface: gobject::GTypeInterface,
}

impl ::std::fmt::Debug for GstTagSetterInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTagSetterInterface @ {:?}", self as *const _))
         .field("g_iface", &self.g_iface)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTaskClass {
    pub parent_class: GstObjectClass,
    pub pool: *mut GstTaskPool,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTaskClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTaskClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTaskPoolClass {
    pub parent_class: GstObjectClass,
    pub prepare: Option<unsafe extern "C" fn(*mut GstTaskPool, *mut *mut glib::GError)>,
    pub cleanup: Option<unsafe extern "C" fn(*mut GstTaskPool)>,
    pub push: Option<unsafe extern "C" fn(*mut GstTaskPool, GstTaskPoolFunction, gpointer, *mut *mut glib::GError) -> gpointer>,
    pub join: Option<unsafe extern "C" fn(*mut GstTaskPool, gpointer)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTaskPoolClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTaskPoolClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .field("prepare", &self.prepare)
         .field("cleanup", &self.cleanup)
         .field("push", &self.push)
         .field("join", &self.join)
         .finish()
    }
}

#[repr(C)]
pub struct GstTaskPrivate(c_void);

impl ::std::fmt::Debug for GstTaskPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTaskPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTimedValue {
    pub timestamp: GstClockTime,
    pub value: c_double,
}

impl ::std::fmt::Debug for GstTimedValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTimedValue @ {:?}", self as *const _))
         .field("timestamp", &self.timestamp)
         .field("value", &self.value)
         .finish()
    }
}

#[repr(C)]
pub struct GstToc(c_void);

impl ::std::fmt::Debug for GstToc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstToc @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstTocEntry(c_void);

impl ::std::fmt::Debug for GstTocEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTocEntry @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTocSetterInterface {
    pub g_iface: gobject::GTypeInterface,
}

impl ::std::fmt::Debug for GstTocSetterInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTocSetterInterface @ {:?}", self as *const _))
         .field("g_iface", &self.g_iface)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTracerClass {
    pub parent_class: GstObjectClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTracerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracerClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GstTracerFactoryClass(c_void);

impl ::std::fmt::Debug for GstTracerFactoryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracerFactoryClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstTracerPrivate(c_void);

impl ::std::fmt::Debug for GstTracerPrivate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracerPrivate @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstTracerRecordClass(c_void);

impl ::std::fmt::Debug for GstTracerRecordClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracerRecordClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTypeFind {
    pub peek: Option<unsafe extern "C" fn(gpointer, i64, c_uint) -> *const u8>,
    pub suggest: Option<unsafe extern "C" fn(gpointer, c_uint, *mut GstCaps)>,
    pub data: gpointer,
    pub get_length: Option<unsafe extern "C" fn(gpointer) -> u64>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTypeFind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTypeFind @ {:?}", self as *const _))
         .field("peek", &self.peek)
         .field("suggest", &self.suggest)
         .field("data", &self.data)
         .field("get_length", &self.get_length)
         .finish()
    }
}

#[repr(C)]
pub struct GstTypeFindFactoryClass(c_void);

impl ::std::fmt::Debug for GstTypeFindFactoryClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTypeFindFactoryClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstURIHandlerInterface {
    pub parent: gobject::GTypeInterface,
    pub get_type: Option<unsafe extern "C" fn(GType) -> GstURIType>,
    pub get_protocols: Option<unsafe extern "C" fn(GType) -> *const *const c_char>,
    pub get_uri: Option<unsafe extern "C" fn(*mut GstURIHandler) -> *mut c_char>,
    pub set_uri: Option<unsafe extern "C" fn(*mut GstURIHandler, *const c_char, *mut *mut glib::GError) -> gboolean>,
}

impl ::std::fmt::Debug for GstURIHandlerInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstURIHandlerInterface @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get_type", &self.get_type)
         .field("get_protocols", &self.get_protocols)
         .field("get_uri", &self.get_uri)
         .field("set_uri", &self.set_uri)
         .finish()
    }
}

#[repr(C)]
pub struct GstUri(c_void);

impl ::std::fmt::Debug for GstUri {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstUri @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstValueTable {
    pub type_: GType,
    pub compare: GstValueCompareFunc,
    pub serialize: GstValueSerializeFunc,
    pub deserialize: GstValueDeserializeFunc,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstValueTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstValueTable @ {:?}", self as *const _))
         .field("type_", &self.type_)
         .field("compare", &self.compare)
         .field("serialize", &self.serialize)
         .field("deserialize", &self.deserialize)
         .finish()
    }
}

// Classes
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstAllocator {
    pub object: GstObject,
    pub mem_type: *const c_char,
    pub mem_map: GstMemoryMapFunction,
    pub mem_unmap: GstMemoryUnmapFunction,
    pub mem_copy: GstMemoryCopyFunction,
    pub mem_share: GstMemoryShareFunction,
    pub mem_is_span: GstMemoryIsSpanFunction,
    pub mem_map_full: GstMemoryMapFullFunction,
    pub mem_unmap_full: GstMemoryUnmapFullFunction,
    pub _gst_reserved: [gpointer; 2],
    pub priv_: *mut GstAllocatorPrivate,
}

impl ::std::fmt::Debug for GstAllocator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAllocator @ {:?}", self as *const _))
         .field("object", &self.object)
         .field("mem_type", &self.mem_type)
         .field("mem_map", &self.mem_map)
         .field("mem_unmap", &self.mem_unmap)
         .field("mem_copy", &self.mem_copy)
         .field("mem_share", &self.mem_share)
         .field("mem_is_span", &self.mem_is_span)
         .field("mem_map_full", &self.mem_map_full)
         .field("mem_unmap_full", &self.mem_unmap_full)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstBin {
    pub element: GstElement,
    pub numchildren: c_int,
    pub children: *mut glib::GList,
    pub children_cookie: u32,
    pub child_bus: *mut GstBus,
    pub messages: *mut glib::GList,
    pub polling: gboolean,
    pub state_dirty: gboolean,
    pub clock_dirty: gboolean,
    pub provided_clock: *mut GstClock,
    pub clock_provider: *mut GstElement,
    pub priv_: *mut GstBinPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBin @ {:?}", self as *const _))
         .field("element", &self.element)
         .field("numchildren", &self.numchildren)
         .field("children", &self.children)
         .field("children_cookie", &self.children_cookie)
         .field("child_bus", &self.child_bus)
         .field("messages", &self.messages)
         .field("polling", &self.polling)
         .field("state_dirty", &self.state_dirty)
         .field("clock_dirty", &self.clock_dirty)
         .field("provided_clock", &self.provided_clock)
         .field("clock_provider", &self.clock_provider)
         .finish()
    }
}

#[repr(C)]
pub struct GstBitmask(c_void);

impl ::std::fmt::Debug for GstBitmask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBitmask @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstBufferPool {
    pub object: GstObject,
    pub flushing: c_int,
    pub priv_: *mut GstBufferPoolPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBufferPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBufferPool @ {:?}", self as *const _))
         .field("object", &self.object)
         .field("flushing", &self.flushing)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstBus {
    pub object: GstObject,
    pub priv_: *mut GstBusPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstBus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstBus @ {:?}", self as *const _))
         .field("object", &self.object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstClock {
    pub object: GstObject,
    pub priv_: *mut GstClockPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstClock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstClock @ {:?}", self as *const _))
         .field("object", &self.object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstControlBinding {
    pub parent: GstObject,
    pub name: *mut c_char,
    pub pspec: *mut gobject::GParamSpec,
    pub object: *mut GstObject,
    pub disabled: gboolean,
    pub ABI: GstControlBinding_ABI,
}

impl ::std::fmt::Debug for GstControlBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlBinding @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("name", &self.name)
         .field("pspec", &self.pspec)
         .field("ABI", &self.ABI)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstControlSource {
    pub parent: GstObject,
    pub get_value: GstControlSourceGetValue,
    pub get_value_array: GstControlSourceGetValueArray,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstControlSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstControlSource @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get_value", &self.get_value)
         .field("get_value_array", &self.get_value_array)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstDevice {
    pub parent: GstObject,
    pub priv_: *mut GstDevicePrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDevice @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstDeviceMonitor {
    pub parent: GstObject,
    pub priv_: *mut GstDeviceMonitorPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceMonitor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceMonitor @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstDeviceProvider {
    pub parent: GstObject,
    pub devices: *mut glib::GList,
    pub priv_: *mut GstDeviceProviderPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDeviceProvider {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceProvider @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("devices", &self.devices)
         .finish()
    }
}

#[repr(C)]
pub struct GstDeviceProviderFactory(c_void);

impl ::std::fmt::Debug for GstDeviceProviderFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDeviceProviderFactory @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstDoubleRange(c_void);

impl ::std::fmt::Debug for GstDoubleRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDoubleRange @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstDynamicTypeFactory(c_void);

impl ::std::fmt::Debug for GstDynamicTypeFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDynamicTypeFactory @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstElement {
    pub object: GstObject,
    pub state_lock: glib::GRecMutex,
    pub state_cond: glib::GCond,
    pub state_cookie: u32,
    pub target_state: GstState,
    pub current_state: GstState,
    pub next_state: GstState,
    pub pending_state: GstState,
    pub last_return: GstStateChangeReturn,
    pub bus: *mut GstBus,
    pub clock: *mut GstClock,
    pub base_time: GstClockTimeDiff,
    pub start_time: GstClockTime,
    pub numpads: u16,
    pub pads: *mut glib::GList,
    pub numsrcpads: u16,
    pub srcpads: *mut glib::GList,
    pub numsinkpads: u16,
    pub sinkpads: *mut glib::GList,
    pub pads_cookie: u32,
    pub contexts: *mut glib::GList,
    pub _gst_reserved: [gpointer; 3],
}

impl ::std::fmt::Debug for GstElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstElement @ {:?}", self as *const _))
         .field("object", &self.object)
         .field("state_lock", &self.state_lock)
         .field("state_cond", &self.state_cond)
         .field("state_cookie", &self.state_cookie)
         .field("target_state", &self.target_state)
         .field("current_state", &self.current_state)
         .field("next_state", &self.next_state)
         .field("pending_state", &self.pending_state)
         .field("last_return", &self.last_return)
         .field("bus", &self.bus)
         .field("clock", &self.clock)
         .field("base_time", &self.base_time)
         .field("start_time", &self.start_time)
         .field("numpads", &self.numpads)
         .field("pads", &self.pads)
         .field("numsrcpads", &self.numsrcpads)
         .field("srcpads", &self.srcpads)
         .field("numsinkpads", &self.numsinkpads)
         .field("sinkpads", &self.sinkpads)
         .field("pads_cookie", &self.pads_cookie)
         .field("contexts", &self.contexts)
         .finish()
    }
}

#[repr(C)]
pub struct GstElementFactory(c_void);

impl ::std::fmt::Debug for GstElementFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstElementFactory @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstFlagSet(c_void);

impl ::std::fmt::Debug for GstFlagSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstFlagSet @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstFraction(c_void);

impl ::std::fmt::Debug for GstFraction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstFraction @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstFractionRange(c_void);

impl ::std::fmt::Debug for GstFractionRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstFractionRange @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstGhostPad {
    pub pad: GstProxyPad,
    pub priv_: *mut GstGhostPadPrivate,
}

impl ::std::fmt::Debug for GstGhostPad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstGhostPad @ {:?}", self as *const _))
         .field("pad", &self.pad)
         .finish()
    }
}

#[repr(C)]
pub struct GstInt64Range(c_void);

impl ::std::fmt::Debug for GstInt64Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstInt64Range @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstIntRange(c_void);

impl ::std::fmt::Debug for GstIntRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstIntRange @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstObject {
    pub object: gobject::GInitiallyUnowned,
    pub lock: glib::GMutex,
    pub name: *mut c_char,
    pub parent: *mut GstObject,
    pub flags: u32,
    pub control_bindings: *mut glib::GList,
    pub control_rate: u64,
    pub last_sync: u64,
    pub _gst_reserved: gpointer,
}

impl ::std::fmt::Debug for GstObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstObject @ {:?}", self as *const _))
         .field("object", &self.object)
         .field("lock", &self.lock)
         .field("name", &self.name)
         .field("parent", &self.parent)
         .field("flags", &self.flags)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPad {
    pub object: GstObject,
    pub element_private: gpointer,
    pub padtemplate: *mut GstPadTemplate,
    pub direction: GstPadDirection,
    pub stream_rec_lock: glib::GRecMutex,
    pub task: *mut GstTask,
    pub block_cond: glib::GCond,
    pub probes: glib::GHookList,
    pub mode: GstPadMode,
    pub activatefunc: GstPadActivateFunction,
    pub activatedata: gpointer,
    pub activatenotify: glib::GDestroyNotify,
    pub activatemodefunc: GstPadActivateModeFunction,
    pub activatemodedata: gpointer,
    pub activatemodenotify: glib::GDestroyNotify,
    pub peer: *mut GstPad,
    pub linkfunc: GstPadLinkFunction,
    pub linkdata: gpointer,
    pub linknotify: glib::GDestroyNotify,
    pub unlinkfunc: GstPadUnlinkFunction,
    pub unlinkdata: gpointer,
    pub unlinknotify: glib::GDestroyNotify,
    pub chainfunc: GstPadChainFunction,
    pub chaindata: gpointer,
    pub chainnotify: glib::GDestroyNotify,
    pub chainlistfunc: GstPadChainListFunction,
    pub chainlistdata: gpointer,
    pub chainlistnotify: glib::GDestroyNotify,
    pub getrangefunc: GstPadGetRangeFunction,
    pub getrangedata: gpointer,
    pub getrangenotify: glib::GDestroyNotify,
    pub eventfunc: GstPadEventFunction,
    pub eventdata: gpointer,
    pub eventnotify: glib::GDestroyNotify,
    pub offset: i64,
    pub queryfunc: GstPadQueryFunction,
    pub querydata: gpointer,
    pub querynotify: glib::GDestroyNotify,
    pub iterintlinkfunc: GstPadIterIntLinkFunction,
    pub iterintlinkdata: gpointer,
    pub iterintlinknotify: glib::GDestroyNotify,
    pub num_probes: c_int,
    pub num_blocked: c_int,
    pub priv_: *mut GstPadPrivate,
    pub ABI: GstPad_ABI,
}

impl ::std::fmt::Debug for GstPad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPad @ {:?}", self as *const _))
         .field("object", &self.object)
         .field("element_private", &self.element_private)
         .field("padtemplate", &self.padtemplate)
         .field("direction", &self.direction)
         .field("ABI", &self.ABI)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPadTemplate {
    pub object: GstObject,
    pub name_template: *mut c_char,
    pub direction: GstPadDirection,
    pub presence: GstPadPresence,
    pub caps: *mut GstCaps,
    pub ABI: GstPadTemplate_ABI,
}

impl ::std::fmt::Debug for GstPadTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPadTemplate @ {:?}", self as *const _))
         .field("object", &self.object)
         .field("name_template", &self.name_template)
         .field("direction", &self.direction)
         .field("presence", &self.presence)
         .field("caps", &self.caps)
         .field("ABI", &self.ABI)
         .finish()
    }
}

#[repr(C)]
pub struct GstParamArray(c_void);

impl ::std::fmt::Debug for GstParamArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParamArray @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstParamFraction(c_void);

impl ::std::fmt::Debug for GstParamFraction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstParamFraction @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstPipeline {
    pub bin: GstBin,
    pub fixed_clock: *mut GstClock,
    pub stream_time: GstClockTime,
    pub delay: GstClockTime,
    pub priv_: *mut GstPipelinePrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstPipeline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPipeline @ {:?}", self as *const _))
         .field("bin", &self.bin)
         .field("fixed_clock", &self.fixed_clock)
         .field("stream_time", &self.stream_time)
         .field("delay", &self.delay)
         .finish()
    }
}

#[repr(C)]
pub struct GstPlugin(c_void);

impl ::std::fmt::Debug for GstPlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPlugin @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstPluginFeature(c_void);

impl ::std::fmt::Debug for GstPluginFeature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstPluginFeature @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstProxyPad {
    pub pad: GstPad,
    pub priv_: *mut GstProxyPadPrivate,
}

impl ::std::fmt::Debug for GstProxyPad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstProxyPad @ {:?}", self as *const _))
         .field("pad", &self.pad)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstRegistry {
    pub object: GstObject,
    pub priv_: *mut GstRegistryPrivate,
}

impl ::std::fmt::Debug for GstRegistry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstRegistry @ {:?}", self as *const _))
         .field("object", &self.object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstStream {
    pub object: GstObject,
    pub stream_id: *const c_char,
    pub priv_: *mut GstStreamPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStream @ {:?}", self as *const _))
         .field("stream_id", &self.stream_id)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstStreamCollection {
    pub object: GstObject,
    pub upstream_id: *mut c_char,
    pub priv_: *mut GstStreamCollectionPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstStreamCollection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStreamCollection @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstSystemClock {
    pub clock: GstClock,
    pub priv_: *mut GstSystemClockPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstSystemClock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstSystemClock @ {:?}", self as *const _))
         .field("clock", &self.clock)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTask {
    pub object: GstObject,
    pub state: GstTaskState,
    pub cond: glib::GCond,
    pub lock: *mut glib::GRecMutex,
    pub func: GstTaskFunction,
    pub user_data: gpointer,
    pub notify: glib::GDestroyNotify,
    pub running: gboolean,
    pub thread: *mut glib::GThread,
    pub priv_: *mut GstTaskPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTask @ {:?}", self as *const _))
         .field("object", &self.object)
         .field("state", &self.state)
         .field("cond", &self.cond)
         .field("lock", &self.lock)
         .field("func", &self.func)
         .field("user_data", &self.user_data)
         .field("notify", &self.notify)
         .field("running", &self.running)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTaskPool {
    pub object: GstObject,
    pub pool: *mut glib::GThreadPool,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTaskPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTaskPool @ {:?}", self as *const _))
         .field("object", &self.object)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct GstTracer {
    pub parent: GstObject,
    pub priv_: *mut GstTracerPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstTracer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracer @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
pub struct GstTracerFactory(c_void);

impl ::std::fmt::Debug for GstTracerFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracerFactory @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstTracerRecord(c_void);

impl ::std::fmt::Debug for GstTracerRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTracerRecord @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstTypeFindFactory(c_void);

impl ::std::fmt::Debug for GstTypeFindFactory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstTypeFindFactory @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstValueArray(c_void);

impl ::std::fmt::Debug for GstValueArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstValueArray @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct GstValueList(c_void);

impl ::std::fmt::Debug for GstValueList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstValueList @ {:?}", self as *const _))
         .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct GstChildProxy(c_void);

impl ::std::fmt::Debug for GstChildProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstChildProxy @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstPreset(c_void);

impl ::std::fmt::Debug for GstPreset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstPreset @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstTagSetter(c_void);

impl ::std::fmt::Debug for GstTagSetter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstTagSetter @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstTocSetter(c_void);

impl ::std::fmt::Debug for GstTocSetter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstTocSetter @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct GstURIHandler(c_void);

impl ::std::fmt::Debug for GstURIHandler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstURIHandler @ {:?}", self as *const _)
    }
}


extern "C" {

    //=========================================================================
    // GstBufferingMode
    //=========================================================================
    pub fn gst_buffering_mode_get_type() -> GType;

    //=========================================================================
    // GstBusSyncReply
    //=========================================================================
    pub fn gst_bus_sync_reply_get_type() -> GType;

    //=========================================================================
    // GstCapsIntersectMode
    //=========================================================================
    pub fn gst_caps_intersect_mode_get_type() -> GType;

    //=========================================================================
    // GstClockEntryType
    //=========================================================================
    pub fn gst_clock_entry_type_get_type() -> GType;

    //=========================================================================
    // GstClockReturn
    //=========================================================================
    pub fn gst_clock_return_get_type() -> GType;

    //=========================================================================
    // GstClockType
    //=========================================================================
    pub fn gst_clock_type_get_type() -> GType;

    //=========================================================================
    // GstCoreError
    //=========================================================================
    pub fn gst_core_error_get_type() -> GType;
    pub fn gst_core_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstDebugColorMode
    //=========================================================================
    pub fn gst_debug_color_mode_get_type() -> GType;

    //=========================================================================
    // GstDebugLevel
    //=========================================================================
    pub fn gst_debug_level_get_type() -> GType;
    pub fn gst_debug_level_get_name(level: GstDebugLevel) -> *const c_char;

    //=========================================================================
    // GstEventType
    //=========================================================================
    pub fn gst_event_type_get_type() -> GType;
    pub fn gst_event_type_get_flags(type_: GstEventType) -> GstEventTypeFlags;
    pub fn gst_event_type_get_name(type_: GstEventType) -> *const c_char;
    pub fn gst_event_type_to_quark(type_: GstEventType) -> glib::GQuark;

    //=========================================================================
    // GstFlowReturn
    //=========================================================================
    pub fn gst_flow_return_get_type() -> GType;

    //=========================================================================
    // GstFormat
    //=========================================================================
    pub fn gst_format_get_type() -> GType;
    pub fn gst_format_get_by_nick(nick: *const c_char) -> GstFormat;
    pub fn gst_format_get_details(format: GstFormat) -> *const GstFormatDefinition;
    pub fn gst_format_get_name(format: GstFormat) -> *const c_char;
    pub fn gst_format_iterate_definitions() -> *mut GstIterator;
    pub fn gst_format_register(nick: *const c_char, description: *const c_char) -> GstFormat;
    pub fn gst_format_to_quark(format: GstFormat) -> glib::GQuark;

    //=========================================================================
    // GstIteratorItem
    //=========================================================================
    pub fn gst_iterator_item_get_type() -> GType;

    //=========================================================================
    // GstIteratorResult
    //=========================================================================
    pub fn gst_iterator_result_get_type() -> GType;

    //=========================================================================
    // GstLibraryError
    //=========================================================================
    pub fn gst_library_error_get_type() -> GType;
    pub fn gst_library_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstPadDirection
    //=========================================================================
    pub fn gst_pad_direction_get_type() -> GType;

    //=========================================================================
    // GstPadLinkReturn
    //=========================================================================
    pub fn gst_pad_link_return_get_type() -> GType;

    //=========================================================================
    // GstPadMode
    //=========================================================================
    pub fn gst_pad_mode_get_type() -> GType;
    pub fn gst_pad_mode_get_name(mode: GstPadMode) -> *const c_char;

    //=========================================================================
    // GstPadPresence
    //=========================================================================
    pub fn gst_pad_presence_get_type() -> GType;

    //=========================================================================
    // GstPadProbeReturn
    //=========================================================================
    pub fn gst_pad_probe_return_get_type() -> GType;

    //=========================================================================
    // GstParseError
    //=========================================================================
    pub fn gst_parse_error_get_type() -> GType;
    pub fn gst_parse_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstPluginError
    //=========================================================================
    pub fn gst_plugin_error_get_type() -> GType;
    pub fn gst_plugin_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstProgressType
    //=========================================================================
    pub fn gst_progress_type_get_type() -> GType;

    //=========================================================================
    // GstPromiseResult
    //=========================================================================
    pub fn gst_promise_result_get_type() -> GType;

    //=========================================================================
    // GstQOSType
    //=========================================================================
    pub fn gst_qos_type_get_type() -> GType;

    //=========================================================================
    // GstQueryType
    //=========================================================================
    pub fn gst_query_type_get_type() -> GType;
    pub fn gst_query_type_get_flags(type_: GstQueryType) -> GstQueryTypeFlags;
    pub fn gst_query_type_get_name(type_: GstQueryType) -> *const c_char;
    pub fn gst_query_type_to_quark(type_: GstQueryType) -> glib::GQuark;

    //=========================================================================
    // GstRank
    //=========================================================================
    pub fn gst_rank_get_type() -> GType;

    //=========================================================================
    // GstResourceError
    //=========================================================================
    pub fn gst_resource_error_get_type() -> GType;
    pub fn gst_resource_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstSearchMode
    //=========================================================================
    pub fn gst_search_mode_get_type() -> GType;

    //=========================================================================
    // GstSeekType
    //=========================================================================
    pub fn gst_seek_type_get_type() -> GType;

    //=========================================================================
    // GstState
    //=========================================================================
    pub fn gst_state_get_type() -> GType;

    //=========================================================================
    // GstStateChange
    //=========================================================================
    pub fn gst_state_change_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_state_change_get_name(transition: GstStateChange) -> *const c_char;

    //=========================================================================
    // GstStateChangeReturn
    //=========================================================================
    pub fn gst_state_change_return_get_type() -> GType;

    //=========================================================================
    // GstStreamError
    //=========================================================================
    pub fn gst_stream_error_get_type() -> GType;
    pub fn gst_stream_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstStreamStatusType
    //=========================================================================
    pub fn gst_stream_status_type_get_type() -> GType;

    //=========================================================================
    // GstStructureChangeType
    //=========================================================================
    pub fn gst_structure_change_type_get_type() -> GType;

    //=========================================================================
    // GstTagFlag
    //=========================================================================
    pub fn gst_tag_flag_get_type() -> GType;

    //=========================================================================
    // GstTagMergeMode
    //=========================================================================
    pub fn gst_tag_merge_mode_get_type() -> GType;

    //=========================================================================
    // GstTagScope
    //=========================================================================
    pub fn gst_tag_scope_get_type() -> GType;

    //=========================================================================
    // GstTaskState
    //=========================================================================
    pub fn gst_task_state_get_type() -> GType;

    //=========================================================================
    // GstTocEntryType
    //=========================================================================
    pub fn gst_toc_entry_type_get_type() -> GType;
    pub fn gst_toc_entry_type_get_nick(type_: GstTocEntryType) -> *const c_char;

    //=========================================================================
    // GstTocLoopType
    //=========================================================================
    pub fn gst_toc_loop_type_get_type() -> GType;

    //=========================================================================
    // GstTocScope
    //=========================================================================
    pub fn gst_toc_scope_get_type() -> GType;

    //=========================================================================
    // GstTracerValueScope
    //=========================================================================
    pub fn gst_tracer_value_scope_get_type() -> GType;

    //=========================================================================
    // GstTypeFindProbability
    //=========================================================================
    pub fn gst_type_find_probability_get_type() -> GType;

    //=========================================================================
    // GstURIError
    //=========================================================================
    pub fn gst_uri_error_get_type() -> GType;
    pub fn gst_uri_error_quark() -> glib::GQuark;

    //=========================================================================
    // GstURIType
    //=========================================================================
    pub fn gst_uri_type_get_type() -> GType;

    //=========================================================================
    // GstAllocatorFlags
    //=========================================================================
    pub fn gst_allocator_flags_get_type() -> GType;

    //=========================================================================
    // GstBinFlags
    //=========================================================================
    pub fn gst_bin_flags_get_type() -> GType;

    //=========================================================================
    // GstBufferCopyFlags
    //=========================================================================
    pub fn gst_buffer_copy_flags_get_type() -> GType;

    //=========================================================================
    // GstBufferFlags
    //=========================================================================
    pub fn gst_buffer_flags_get_type() -> GType;

    //=========================================================================
    // GstBufferPoolAcquireFlags
    //=========================================================================
    pub fn gst_buffer_pool_acquire_flags_get_type() -> GType;

    //=========================================================================
    // GstBusFlags
    //=========================================================================
    pub fn gst_bus_flags_get_type() -> GType;

    //=========================================================================
    // GstCapsFlags
    //=========================================================================
    pub fn gst_caps_flags_get_type() -> GType;

    //=========================================================================
    // GstClockFlags
    //=========================================================================
    pub fn gst_clock_flags_get_type() -> GType;

    //=========================================================================
    // GstDebugColorFlags
    //=========================================================================
    pub fn gst_debug_color_flags_get_type() -> GType;

    //=========================================================================
    // GstDebugGraphDetails
    //=========================================================================
    pub fn gst_debug_graph_details_get_type() -> GType;

    //=========================================================================
    // GstElementFlags
    //=========================================================================
    pub fn gst_element_flags_get_type() -> GType;

    //=========================================================================
    // GstEventTypeFlags
    //=========================================================================
    pub fn gst_event_type_flags_get_type() -> GType;

    //=========================================================================
    // GstLockFlags
    //=========================================================================
    pub fn gst_lock_flags_get_type() -> GType;

    //=========================================================================
    // GstMapFlags
    //=========================================================================
    pub fn gst_map_flags_get_type() -> GType;

    //=========================================================================
    // GstMemoryFlags
    //=========================================================================
    pub fn gst_memory_flags_get_type() -> GType;

    //=========================================================================
    // GstMessageType
    //=========================================================================
    pub fn gst_message_type_get_type() -> GType;
    pub fn gst_message_type_get_name(type_: GstMessageType) -> *const c_char;
    pub fn gst_message_type_to_quark(type_: GstMessageType) -> glib::GQuark;

    //=========================================================================
    // GstMetaFlags
    //=========================================================================
    pub fn gst_meta_flags_get_type() -> GType;

    //=========================================================================
    // GstMiniObjectFlags
    //=========================================================================
    pub fn gst_mini_object_flags_get_type() -> GType;

    //=========================================================================
    // GstObjectFlags
    //=========================================================================
    pub fn gst_object_flags_get_type() -> GType;

    //=========================================================================
    // GstPadFlags
    //=========================================================================
    pub fn gst_pad_flags_get_type() -> GType;

    //=========================================================================
    // GstPadLinkCheck
    //=========================================================================
    pub fn gst_pad_link_check_get_type() -> GType;

    //=========================================================================
    // GstPadProbeType
    //=========================================================================
    pub fn gst_pad_probe_type_get_type() -> GType;

    //=========================================================================
    // GstPadTemplateFlags
    //=========================================================================
    pub fn gst_pad_template_flags_get_type() -> GType;

    //=========================================================================
    // GstParseFlags
    //=========================================================================
    pub fn gst_parse_flags_get_type() -> GType;

    //=========================================================================
    // GstPipelineFlags
    //=========================================================================
    pub fn gst_pipeline_flags_get_type() -> GType;

    //=========================================================================
    // GstPluginDependencyFlags
    //=========================================================================
    pub fn gst_plugin_dependency_flags_get_type() -> GType;

    //=========================================================================
    // GstPluginFlags
    //=========================================================================
    pub fn gst_plugin_flags_get_type() -> GType;

    //=========================================================================
    // GstQueryTypeFlags
    //=========================================================================
    pub fn gst_query_type_flags_get_type() -> GType;

    //=========================================================================
    // GstSchedulingFlags
    //=========================================================================
    pub fn gst_scheduling_flags_get_type() -> GType;

    //=========================================================================
    // GstSeekFlags
    //=========================================================================
    pub fn gst_seek_flags_get_type() -> GType;

    //=========================================================================
    // GstSegmentFlags
    //=========================================================================
    pub fn gst_segment_flags_get_type() -> GType;

    //=========================================================================
    // GstStackTraceFlags
    //=========================================================================
    pub fn gst_stack_trace_flags_get_type() -> GType;

    //=========================================================================
    // GstStreamFlags
    //=========================================================================
    pub fn gst_stream_flags_get_type() -> GType;

    //=========================================================================
    // GstStreamType
    //=========================================================================
    pub fn gst_stream_type_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_type_get_name(stype: GstStreamType) -> *const c_char;

    //=========================================================================
    // GstTracerValueFlags
    //=========================================================================
    pub fn gst_tracer_value_flags_get_type() -> GType;

    //=========================================================================
    // GstAllocationParams
    //=========================================================================
    pub fn gst_allocation_params_get_type() -> GType;
    pub fn gst_allocation_params_copy(params: *const GstAllocationParams) -> *mut GstAllocationParams;
    pub fn gst_allocation_params_free(params: *mut GstAllocationParams);
    pub fn gst_allocation_params_init(params: *mut GstAllocationParams);

    //=========================================================================
    // GstAtomicQueue
    //=========================================================================
    pub fn gst_atomic_queue_get_type() -> GType;
    pub fn gst_atomic_queue_new(initial_size: c_uint) -> *mut GstAtomicQueue;
    pub fn gst_atomic_queue_length(queue: *mut GstAtomicQueue) -> c_uint;
    pub fn gst_atomic_queue_peek(queue: *mut GstAtomicQueue) -> gpointer;
    pub fn gst_atomic_queue_pop(queue: *mut GstAtomicQueue) -> gpointer;
    pub fn gst_atomic_queue_push(queue: *mut GstAtomicQueue, data: gpointer);
    pub fn gst_atomic_queue_ref(queue: *mut GstAtomicQueue);
    pub fn gst_atomic_queue_unref(queue: *mut GstAtomicQueue);

    //=========================================================================
    // GstBuffer
    //=========================================================================
    pub fn gst_buffer_get_type() -> GType;
    pub fn gst_buffer_new() -> *mut GstBuffer;
    pub fn gst_buffer_new_allocate(allocator: *mut GstAllocator, size: size_t, params: *mut GstAllocationParams) -> *mut GstBuffer;
    pub fn gst_buffer_new_wrapped(data: gpointer, size: size_t) -> *mut GstBuffer;
    pub fn gst_buffer_new_wrapped_full(flags: GstMemoryFlags, data: gpointer, maxsize: size_t, offset: size_t, size: size_t, user_data: gpointer, notify: glib::GDestroyNotify) -> *mut GstBuffer;
    pub fn gst_buffer_add_meta(buffer: *mut GstBuffer, info: *const GstMetaInfo, params: gpointer) -> *mut GstMeta;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_buffer_add_parent_buffer_meta(buffer: *mut GstBuffer, ref_: *mut GstBuffer) -> *mut GstParentBufferMeta;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_buffer_add_protection_meta(buffer: *mut GstBuffer, info: *mut GstStructure) -> *mut GstProtectionMeta;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_buffer_add_reference_timestamp_meta(buffer: *mut GstBuffer, reference: *mut GstCaps, timestamp: GstClockTime, duration: GstClockTime) -> *mut GstReferenceTimestampMeta;
    pub fn gst_buffer_append(buf1: *mut GstBuffer, buf2: *mut GstBuffer) -> *mut GstBuffer;
    pub fn gst_buffer_append_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
    pub fn gst_buffer_append_region(buf1: *mut GstBuffer, buf2: *mut GstBuffer, offset: ssize_t, size: ssize_t) -> *mut GstBuffer;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_buffer_copy_deep(buf: *const GstBuffer) -> *mut GstBuffer;
    pub fn gst_buffer_copy_into(dest: *mut GstBuffer, src: *mut GstBuffer, flags: GstBufferCopyFlags, offset: size_t, size: size_t) -> gboolean;
    pub fn gst_buffer_copy_region(parent: *mut GstBuffer, flags: GstBufferCopyFlags, offset: size_t, size: size_t) -> *mut GstBuffer;
    pub fn gst_buffer_extract(buffer: *mut GstBuffer, offset: size_t, dest: gpointer, size: size_t) -> size_t;
    #[cfg(any(feature = "v1_0_10", feature = "dox"))]
    pub fn gst_buffer_extract_dup(buffer: *mut GstBuffer, offset: size_t, size: size_t, dest: *mut u8, dest_size: *mut size_t);
    pub fn gst_buffer_fill(buffer: *mut GstBuffer, offset: size_t, src: gconstpointer, size: size_t) -> size_t;
    pub fn gst_buffer_find_memory(buffer: *mut GstBuffer, offset: size_t, size: size_t, idx: *mut c_uint, length: *mut c_uint, skip: *mut size_t) -> gboolean;
    pub fn gst_buffer_foreach_meta(buffer: *mut GstBuffer, func: GstBufferForeachMetaFunc, user_data: gpointer) -> gboolean;
    pub fn gst_buffer_get_all_memory(buffer: *mut GstBuffer) -> *mut GstMemory;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_buffer_get_flags(buffer: *mut GstBuffer) -> GstBufferFlags;
    pub fn gst_buffer_get_memory(buffer: *mut GstBuffer, idx: c_uint) -> *mut GstMemory;
    pub fn gst_buffer_get_memory_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int) -> *mut GstMemory;
    pub fn gst_buffer_get_meta(buffer: *mut GstBuffer, api: GType) -> *mut GstMeta;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_buffer_get_n_meta(buffer: *mut GstBuffer, api_type: GType) -> c_uint;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_buffer_get_reference_timestamp_meta(buffer: *mut GstBuffer, reference: *mut GstCaps) -> *mut GstReferenceTimestampMeta;
    pub fn gst_buffer_get_size(buffer: *mut GstBuffer) -> size_t;
    pub fn gst_buffer_get_sizes(buffer: *mut GstBuffer, offset: *mut size_t, maxsize: *mut size_t) -> size_t;
    pub fn gst_buffer_get_sizes_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int, offset: *mut size_t, maxsize: *mut size_t) -> size_t;
    pub fn gst_buffer_has_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
    pub fn gst_buffer_insert_memory(buffer: *mut GstBuffer, idx: c_int, mem: *mut GstMemory);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_buffer_is_all_memory_writable(buffer: *mut GstBuffer) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_buffer_is_memory_range_writable(buffer: *mut GstBuffer, idx: c_uint, length: c_int) -> gboolean;
    pub fn gst_buffer_iterate_meta(buffer: *mut GstBuffer, state: *mut gpointer) -> *mut GstMeta;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_buffer_iterate_meta_filtered(buffer: *mut GstBuffer, state: *mut gpointer, meta_api_type: GType) -> *mut GstMeta;
    pub fn gst_buffer_map(buffer: *mut GstBuffer, info: *mut GstMapInfo, flags: GstMapFlags) -> gboolean;
    pub fn gst_buffer_map_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int, info: *mut GstMapInfo, flags: GstMapFlags) -> gboolean;
    pub fn gst_buffer_memcmp(buffer: *mut GstBuffer, offset: size_t, mem: gconstpointer, size: size_t) -> c_int;
    pub fn gst_buffer_memset(buffer: *mut GstBuffer, offset: size_t, val: u8, size: size_t) -> size_t;
    pub fn gst_buffer_n_memory(buffer: *mut GstBuffer) -> c_uint;
    pub fn gst_buffer_peek_memory(buffer: *mut GstBuffer, idx: c_uint) -> *mut GstMemory;
    pub fn gst_buffer_prepend_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
    pub fn gst_buffer_remove_all_memory(buffer: *mut GstBuffer);
    pub fn gst_buffer_remove_memory(buffer: *mut GstBuffer, idx: c_uint);
    pub fn gst_buffer_remove_memory_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int);
    pub fn gst_buffer_remove_meta(buffer: *mut GstBuffer, meta: *mut GstMeta) -> gboolean;
    pub fn gst_buffer_replace_all_memory(buffer: *mut GstBuffer, mem: *mut GstMemory);
    pub fn gst_buffer_replace_memory(buffer: *mut GstBuffer, idx: c_uint, mem: *mut GstMemory);
    pub fn gst_buffer_replace_memory_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int, mem: *mut GstMemory);
    pub fn gst_buffer_resize(buffer: *mut GstBuffer, offset: ssize_t, size: ssize_t);
    pub fn gst_buffer_resize_range(buffer: *mut GstBuffer, idx: c_uint, length: c_int, offset: ssize_t, size: ssize_t) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_buffer_set_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
    pub fn gst_buffer_set_size(buffer: *mut GstBuffer, size: ssize_t);
    pub fn gst_buffer_unmap(buffer: *mut GstBuffer, info: *mut GstMapInfo);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_buffer_unset_flags(buffer: *mut GstBuffer, flags: GstBufferFlags) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_buffer_get_max_memory() -> c_uint;

    //=========================================================================
    // GstBufferList
    //=========================================================================
    pub fn gst_buffer_list_get_type() -> GType;
    pub fn gst_buffer_list_new() -> *mut GstBufferList;
    pub fn gst_buffer_list_new_sized(size: c_uint) -> *mut GstBufferList;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_buffer_list_calculate_size(list: *mut GstBufferList) -> size_t;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_buffer_list_copy_deep(list: *const GstBufferList) -> *mut GstBufferList;
    pub fn gst_buffer_list_foreach(list: *mut GstBufferList, func: GstBufferListFunc, user_data: gpointer) -> gboolean;
    pub fn gst_buffer_list_get(list: *mut GstBufferList, idx: c_uint) -> *mut GstBuffer;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_buffer_list_get_writable(list: *mut GstBufferList, idx: c_uint) -> *mut GstBuffer;
    pub fn gst_buffer_list_insert(list: *mut GstBufferList, idx: c_int, buffer: *mut GstBuffer);
    pub fn gst_buffer_list_length(list: *mut GstBufferList) -> c_uint;
    pub fn gst_buffer_list_remove(list: *mut GstBufferList, idx: c_uint, length: c_uint);

    //=========================================================================
    // GstCaps
    //=========================================================================
    pub fn gst_caps_get_type() -> GType;
    pub fn gst_caps_new_any() -> *mut GstCaps;
    pub fn gst_caps_new_empty() -> *mut GstCaps;
    pub fn gst_caps_new_empty_simple(media_type: *const c_char) -> *mut GstCaps;
    pub fn gst_caps_new_full(struct1: *mut GstStructure, ...) -> *mut GstCaps;
    //pub fn gst_caps_new_full_valist(structure: *mut GstStructure, var_args: /*Unimplemented*/va_list) -> *mut GstCaps;
    pub fn gst_caps_new_simple(media_type: *const c_char, fieldname: *const c_char, ...) -> *mut GstCaps;
    pub fn gst_caps_append(caps1: *mut GstCaps, caps2: *mut GstCaps);
    pub fn gst_caps_append_structure(caps: *mut GstCaps, structure: *mut GstStructure);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_append_structure_full(caps: *mut GstCaps, structure: *mut GstStructure, features: *mut GstCapsFeatures);
    pub fn gst_caps_can_intersect(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_copy_nth(caps: *const GstCaps, nth: c_uint) -> *mut GstCaps;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_caps_filter_and_map_in_place(caps: *mut GstCaps, func: GstCapsFilterMapFunc, user_data: gpointer);
    pub fn gst_caps_fixate(caps: *mut GstCaps) -> *mut GstCaps;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_caps_foreach(caps: *const GstCaps, func: GstCapsForeachFunc, user_data: gpointer) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_get_features(caps: *const GstCaps, index: c_uint) -> *mut GstCapsFeatures;
    pub fn gst_caps_get_size(caps: *const GstCaps) -> c_uint;
    pub fn gst_caps_get_structure(caps: *const GstCaps, index: c_uint) -> *mut GstStructure;
    pub fn gst_caps_intersect(caps1: *mut GstCaps, caps2: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_intersect_full(caps1: *mut GstCaps, caps2: *mut GstCaps, mode: GstCapsIntersectMode) -> *mut GstCaps;
    pub fn gst_caps_is_always_compatible(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_any(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_empty(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_equal(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_equal_fixed(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_fixed(caps: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_strictly_equal(caps1: *const GstCaps, caps2: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_subset(subset: *const GstCaps, superset: *const GstCaps) -> gboolean;
    pub fn gst_caps_is_subset_structure(caps: *const GstCaps, structure: *const GstStructure) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_is_subset_structure_full(caps: *const GstCaps, structure: *const GstStructure, features: *const GstCapsFeatures) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_caps_map_in_place(caps: *mut GstCaps, func: GstCapsMapFunc, user_data: gpointer) -> gboolean;
    pub fn gst_caps_merge(caps1: *mut GstCaps, caps2: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_merge_structure(caps: *mut GstCaps, structure: *mut GstStructure) -> *mut GstCaps;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_merge_structure_full(caps: *mut GstCaps, structure: *mut GstStructure, features: *mut GstCapsFeatures) -> *mut GstCaps;
    pub fn gst_caps_normalize(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_remove_structure(caps: *mut GstCaps, idx: c_uint);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_set_features(caps: *mut GstCaps, index: c_uint, features: *mut GstCapsFeatures);
    pub fn gst_caps_set_simple(caps: *mut GstCaps, field: *const c_char, ...);
    //pub fn gst_caps_set_simple_valist(caps: *mut GstCaps, field: *const c_char, varargs: /*Unimplemented*/va_list);
    pub fn gst_caps_set_value(caps: *mut GstCaps, field: *const c_char, value: *const gobject::GValue);
    pub fn gst_caps_simplify(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_steal_structure(caps: *mut GstCaps, index: c_uint) -> *mut GstStructure;
    pub fn gst_caps_subtract(minuend: *mut GstCaps, subtrahend: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_to_string(caps: *const GstCaps) -> *mut c_char;
    pub fn gst_caps_truncate(caps: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_caps_from_string(string: *const c_char) -> *mut GstCaps;

    //=========================================================================
    // GstCapsFeatures
    //=========================================================================
    pub fn gst_caps_features_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_new(feature1: *const c_char, ...) -> *mut GstCapsFeatures;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_new_any() -> *mut GstCapsFeatures;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_new_empty() -> *mut GstCapsFeatures;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_new_id(feature1: glib::GQuark, ...) -> *mut GstCapsFeatures;
    //#[cfg(any(feature = "v1_2", feature = "dox"))]
    //pub fn gst_caps_features_new_id_valist(feature1: glib::GQuark, varargs: /*Unimplemented*/va_list) -> *mut GstCapsFeatures;
    //#[cfg(any(feature = "v1_2", feature = "dox"))]
    //pub fn gst_caps_features_new_valist(feature1: *const c_char, varargs: /*Unimplemented*/va_list) -> *mut GstCapsFeatures;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_add(features: *mut GstCapsFeatures, feature: *const c_char);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_add_id(features: *mut GstCapsFeatures, feature: glib::GQuark);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_contains(features: *const GstCapsFeatures, feature: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_contains_id(features: *const GstCapsFeatures, feature: glib::GQuark) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_copy(features: *const GstCapsFeatures) -> *mut GstCapsFeatures;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_free(features: *mut GstCapsFeatures);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_get_nth(features: *const GstCapsFeatures, i: c_uint) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_get_nth_id(features: *const GstCapsFeatures, i: c_uint) -> glib::GQuark;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_get_size(features: *const GstCapsFeatures) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_is_any(features: *const GstCapsFeatures) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_is_equal(features1: *const GstCapsFeatures, features2: *const GstCapsFeatures) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_remove(features: *mut GstCapsFeatures, feature: *const c_char);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_remove_id(features: *mut GstCapsFeatures, feature: glib::GQuark);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_set_parent_refcount(features: *mut GstCapsFeatures, refcount: *mut c_int) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_to_string(features: *const GstCapsFeatures) -> *mut c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_caps_features_from_string(features: *const c_char) -> *mut GstCapsFeatures;

    //=========================================================================
    // GstContext
    //=========================================================================
    pub fn gst_context_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_context_new(context_type: *const c_char, persistent: gboolean) -> *mut GstContext;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_context_get_context_type(context: *const GstContext) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_context_get_structure(context: *const GstContext) -> *const GstStructure;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_context_has_context_type(context: *const GstContext, context_type: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_context_is_persistent(context: *const GstContext) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_context_writable_structure(context: *mut GstContext) -> *mut GstStructure;

    //=========================================================================
    // GstDateTime
    //=========================================================================
    pub fn gst_date_time_get_type() -> GType;
    pub fn gst_date_time_new(tzoffset: c_float, year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_g_date_time(dt: *mut glib::GDateTime) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_iso8601_string(string: *const c_char) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_unix_epoch_local_time(secs: i64) -> *mut GstDateTime;
    pub fn gst_date_time_new_from_unix_epoch_utc(secs: i64) -> *mut GstDateTime;
    pub fn gst_date_time_new_local_time(year: c_int, month: c_int, day: c_int, hour: c_int, minute: c_int, seconds: c_double) -> *mut GstDateTime;
    pub fn gst_date_time_new_now_local_time() -> *mut GstDateTime;
    pub fn gst_date_time_new_now_utc() -> *mut GstDateTime;
    pub fn gst_date_time_new_y(year: c_int) -> *mut GstDateTime;
    pub fn gst_date_time_new_ym(year: c_int, month: c_int) -> *mut GstDateTime;
    pub fn gst_date_time_new_ymd(year: c_int, month: c_int, day: c_int) -> *mut GstDateTime;
    pub fn gst_date_time_get_day(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_hour(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_microsecond(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_minute(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_month(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_second(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_get_time_zone_offset(datetime: *const GstDateTime) -> c_float;
    pub fn gst_date_time_get_year(datetime: *const GstDateTime) -> c_int;
    pub fn gst_date_time_has_day(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_month(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_second(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_time(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_has_year(datetime: *const GstDateTime) -> gboolean;
    pub fn gst_date_time_ref(datetime: *mut GstDateTime) -> *mut GstDateTime;
    pub fn gst_date_time_to_g_date_time(datetime: *mut GstDateTime) -> *mut glib::GDateTime;
    pub fn gst_date_time_to_iso8601_string(datetime: *mut GstDateTime) -> *mut c_char;
    pub fn gst_date_time_unref(datetime: *mut GstDateTime);

    //=========================================================================
    // GstDebugCategory
    //=========================================================================
    pub fn gst_debug_category_free(category: *mut GstDebugCategory);
    pub fn gst_debug_category_get_color(category: *mut GstDebugCategory) -> c_uint;
    pub fn gst_debug_category_get_description(category: *mut GstDebugCategory) -> *const c_char;
    pub fn gst_debug_category_get_name(category: *mut GstDebugCategory) -> *const c_char;
    pub fn gst_debug_category_get_threshold(category: *mut GstDebugCategory) -> GstDebugLevel;
    pub fn gst_debug_category_reset_threshold(category: *mut GstDebugCategory);
    pub fn gst_debug_category_set_threshold(category: *mut GstDebugCategory, level: GstDebugLevel);

    //=========================================================================
    // GstDebugMessage
    //=========================================================================
    pub fn gst_debug_message_get(message: *mut GstDebugMessage) -> *const c_char;

    //=========================================================================
    // GstDeviceProviderClass
    //=========================================================================
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_class_add_metadata(klass: *mut GstDeviceProviderClass, key: *const c_char, value: *const c_char);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_class_add_static_metadata(klass: *mut GstDeviceProviderClass, key: *const c_char, value: *const c_char);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_class_get_metadata(klass: *mut GstDeviceProviderClass, key: *const c_char) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_class_set_metadata(klass: *mut GstDeviceProviderClass, longname: *const c_char, classification: *const c_char, description: *const c_char, author: *const c_char);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_class_set_static_metadata(klass: *mut GstDeviceProviderClass, longname: *const c_char, classification: *const c_char, description: *const c_char, author: *const c_char);

    //=========================================================================
    // GstElementClass
    //=========================================================================
    pub fn gst_element_class_add_metadata(klass: *mut GstElementClass, key: *const c_char, value: *const c_char);
    pub fn gst_element_class_add_pad_template(klass: *mut GstElementClass, templ: *mut GstPadTemplate);
    pub fn gst_element_class_add_static_metadata(klass: *mut GstElementClass, key: *const c_char, value: *const c_char);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_element_class_add_static_pad_template(klass: *mut GstElementClass, static_templ: *mut GstStaticPadTemplate);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_element_class_add_static_pad_template_with_gtype(klass: *mut GstElementClass, static_templ: *mut GstStaticPadTemplate, pad_type: GType);
    pub fn gst_element_class_get_metadata(klass: *mut GstElementClass, key: *const c_char) -> *const c_char;
    pub fn gst_element_class_get_pad_template(element_class: *mut GstElementClass, name: *const c_char) -> *mut GstPadTemplate;
    pub fn gst_element_class_get_pad_template_list(element_class: *mut GstElementClass) -> *mut glib::GList;
    pub fn gst_element_class_set_metadata(klass: *mut GstElementClass, longname: *const c_char, classification: *const c_char, description: *const c_char, author: *const c_char);
    pub fn gst_element_class_set_static_metadata(klass: *mut GstElementClass, longname: *const c_char, classification: *const c_char, description: *const c_char, author: *const c_char);

    //=========================================================================
    // GstEvent
    //=========================================================================
    pub fn gst_event_get_type() -> GType;
    pub fn gst_event_new_buffer_size(format: GstFormat, minsize: i64, maxsize: i64, async: gboolean) -> *mut GstEvent;
    pub fn gst_event_new_caps(caps: *mut GstCaps) -> *mut GstEvent;
    pub fn gst_event_new_custom(type_: GstEventType, structure: *mut GstStructure) -> *mut GstEvent;
    pub fn gst_event_new_eos() -> *mut GstEvent;
    pub fn gst_event_new_flush_start() -> *mut GstEvent;
    pub fn gst_event_new_flush_stop(reset_time: gboolean) -> *mut GstEvent;
    pub fn gst_event_new_gap(timestamp: GstClockTime, duration: GstClockTime) -> *mut GstEvent;
    pub fn gst_event_new_latency(latency: GstClockTime) -> *mut GstEvent;
    pub fn gst_event_new_navigation(structure: *mut GstStructure) -> *mut GstEvent;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_event_new_protection(system_id: *const c_char, data: *mut GstBuffer, origin: *const c_char) -> *mut GstEvent;
    pub fn gst_event_new_qos(type_: GstQOSType, proportion: c_double, diff: GstClockTimeDiff, timestamp: GstClockTime) -> *mut GstEvent;
    pub fn gst_event_new_reconfigure() -> *mut GstEvent;
    pub fn gst_event_new_seek(rate: c_double, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: i64, stop_type: GstSeekType, stop: i64) -> *mut GstEvent;
    pub fn gst_event_new_segment(segment: *const GstSegment) -> *mut GstEvent;
    pub fn gst_event_new_segment_done(format: GstFormat, position: i64) -> *mut GstEvent;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_event_new_select_streams(streams: *mut glib::GList) -> *mut GstEvent;
    pub fn gst_event_new_sink_message(name: *const c_char, msg: *mut GstMessage) -> *mut GstEvent;
    pub fn gst_event_new_step(format: GstFormat, amount: u64, rate: c_double, flush: gboolean, intermediate: gboolean) -> *mut GstEvent;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_event_new_stream_collection(collection: *mut GstStreamCollection) -> *mut GstEvent;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_event_new_stream_group_done(group_id: c_uint) -> *mut GstEvent;
    pub fn gst_event_new_stream_start(stream_id: *const c_char) -> *mut GstEvent;
    pub fn gst_event_new_tag(taglist: *mut GstTagList) -> *mut GstEvent;
    pub fn gst_event_new_toc(toc: *mut GstToc, updated: gboolean) -> *mut GstEvent;
    pub fn gst_event_new_toc_select(uid: *const c_char) -> *mut GstEvent;
    pub fn gst_event_copy_segment(event: *mut GstEvent, segment: *mut GstSegment);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_event_get_running_time_offset(event: *mut GstEvent) -> i64;
    pub fn gst_event_get_seqnum(event: *mut GstEvent) -> u32;
    pub fn gst_event_get_structure(event: *mut GstEvent) -> *const GstStructure;
    pub fn gst_event_has_name(event: *mut GstEvent, name: *const c_char) -> gboolean;
    pub fn gst_event_parse_buffer_size(event: *mut GstEvent, format: *mut GstFormat, minsize: *mut i64, maxsize: *mut i64, async: *mut gboolean);
    pub fn gst_event_parse_caps(event: *mut GstEvent, caps: *mut *mut GstCaps);
    pub fn gst_event_parse_flush_stop(event: *mut GstEvent, reset_time: *mut gboolean);
    pub fn gst_event_parse_gap(event: *mut GstEvent, timestamp: *mut GstClockTime, duration: *mut GstClockTime);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_event_parse_group_id(event: *mut GstEvent, group_id: *mut c_uint) -> gboolean;
    pub fn gst_event_parse_latency(event: *mut GstEvent, latency: *mut GstClockTime);
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_event_parse_protection(event: *mut GstEvent, system_id: *mut *const c_char, data: *mut *mut GstBuffer, origin: *mut *const c_char);
    pub fn gst_event_parse_qos(event: *mut GstEvent, type_: *mut GstQOSType, proportion: *mut c_double, diff: *mut GstClockTimeDiff, timestamp: *mut GstClockTime);
    pub fn gst_event_parse_seek(event: *mut GstEvent, rate: *mut c_double, format: *mut GstFormat, flags: *mut GstSeekFlags, start_type: *mut GstSeekType, start: *mut i64, stop_type: *mut GstSeekType, stop: *mut i64);
    pub fn gst_event_parse_segment(event: *mut GstEvent, segment: *mut *const GstSegment);
    pub fn gst_event_parse_segment_done(event: *mut GstEvent, format: *mut GstFormat, position: *mut i64);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_event_parse_select_streams(event: *mut GstEvent, streams: *mut *mut glib::GList);
    pub fn gst_event_parse_sink_message(event: *mut GstEvent, msg: *mut *mut GstMessage);
    pub fn gst_event_parse_step(event: *mut GstEvent, format: *mut GstFormat, amount: *mut u64, rate: *mut c_double, flush: *mut gboolean, intermediate: *mut gboolean);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_event_parse_stream(event: *mut GstEvent, stream: *mut *mut GstStream);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_event_parse_stream_collection(event: *mut GstEvent, collection: *mut *mut GstStreamCollection);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_event_parse_stream_flags(event: *mut GstEvent, flags: *mut GstStreamFlags);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_event_parse_stream_group_done(event: *mut GstEvent, group_id: *mut c_uint);
    pub fn gst_event_parse_stream_start(event: *mut GstEvent, stream_id: *mut *const c_char);
    pub fn gst_event_parse_tag(event: *mut GstEvent, taglist: *mut *mut GstTagList);
    pub fn gst_event_parse_toc(event: *mut GstEvent, toc: *mut *mut GstToc, updated: *mut gboolean);
    pub fn gst_event_parse_toc_select(event: *mut GstEvent, uid: *mut *mut c_char);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_event_set_group_id(event: *mut GstEvent, group_id: c_uint);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_event_set_running_time_offset(event: *mut GstEvent, offset: i64);
    pub fn gst_event_set_seqnum(event: *mut GstEvent, seqnum: u32);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_event_set_stream(event: *mut GstEvent, stream: *mut GstStream);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_event_set_stream_flags(event: *mut GstEvent, flags: GstStreamFlags);
    pub fn gst_event_writable_structure(event: *mut GstEvent) -> *mut GstStructure;

    //=========================================================================
    // GstIterator
    //=========================================================================
    pub fn gst_iterator_get_type() -> GType;
    pub fn gst_iterator_new(size: c_uint, type_: GType, lock: *mut glib::GMutex, master_cookie: *mut u32, copy: GstIteratorCopyFunction, next: GstIteratorNextFunction, item: GstIteratorItemFunction, resync: GstIteratorResyncFunction, free: GstIteratorFreeFunction) -> *mut GstIterator;
    pub fn gst_iterator_new_list(type_: GType, lock: *mut glib::GMutex, master_cookie: *mut u32, list: *mut *mut glib::GList, owner: *mut gobject::GObject, item: GstIteratorItemFunction) -> *mut GstIterator;
    pub fn gst_iterator_new_single(type_: GType, object: *const gobject::GValue) -> *mut GstIterator;
    pub fn gst_iterator_copy(it: *const GstIterator) -> *mut GstIterator;
    pub fn gst_iterator_filter(it: *mut GstIterator, func: glib::GCompareFunc, user_data: *const gobject::GValue) -> *mut GstIterator;
    pub fn gst_iterator_find_custom(it: *mut GstIterator, func: glib::GCompareFunc, elem: *mut gobject::GValue, user_data: gpointer) -> gboolean;
    pub fn gst_iterator_fold(it: *mut GstIterator, func: GstIteratorFoldFunction, ret: *mut gobject::GValue, user_data: gpointer) -> GstIteratorResult;
    pub fn gst_iterator_foreach(it: *mut GstIterator, func: GstIteratorForeachFunction, user_data: gpointer) -> GstIteratorResult;
    pub fn gst_iterator_free(it: *mut GstIterator);
    pub fn gst_iterator_next(it: *mut GstIterator, elem: *mut gobject::GValue) -> GstIteratorResult;
    pub fn gst_iterator_push(it: *mut GstIterator, other: *mut GstIterator);
    pub fn gst_iterator_resync(it: *mut GstIterator);

    //=========================================================================
    // GstMemory
    //=========================================================================
    pub fn gst_memory_get_type() -> GType;
    pub fn gst_memory_new_wrapped(flags: GstMemoryFlags, data: gpointer, maxsize: size_t, offset: size_t, size: size_t, user_data: gpointer, notify: glib::GDestroyNotify) -> *mut GstMemory;
    pub fn gst_memory_copy(mem: *mut GstMemory, offset: ssize_t, size: ssize_t) -> *mut GstMemory;
    pub fn gst_memory_get_sizes(mem: *mut GstMemory, offset: *mut size_t, maxsize: *mut size_t) -> size_t;
    pub fn gst_memory_init(mem: *mut GstMemory, flags: GstMemoryFlags, allocator: *mut GstAllocator, parent: *mut GstMemory, maxsize: size_t, align: size_t, offset: size_t, size: size_t);
    pub fn gst_memory_is_span(mem1: *mut GstMemory, mem2: *mut GstMemory, offset: *mut size_t) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_memory_is_type(mem: *mut GstMemory, mem_type: *const c_char) -> gboolean;
    pub fn gst_memory_make_mapped(mem: *mut GstMemory, info: *mut GstMapInfo, flags: GstMapFlags) -> *mut GstMemory;
    pub fn gst_memory_map(mem: *mut GstMemory, info: *mut GstMapInfo, flags: GstMapFlags) -> gboolean;
    pub fn gst_memory_resize(mem: *mut GstMemory, offset: ssize_t, size: size_t);
    pub fn gst_memory_share(mem: *mut GstMemory, offset: ssize_t, size: ssize_t) -> *mut GstMemory;
    pub fn gst_memory_unmap(mem: *mut GstMemory, info: *mut GstMapInfo);

    //=========================================================================
    // GstMessage
    //=========================================================================
    pub fn gst_message_get_type() -> GType;
    pub fn gst_message_new_application(src: *mut GstObject, structure: *mut GstStructure) -> *mut GstMessage;
    pub fn gst_message_new_async_done(src: *mut GstObject, running_time: GstClockTime) -> *mut GstMessage;
    pub fn gst_message_new_async_start(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_buffering(src: *mut GstObject, percent: c_int) -> *mut GstMessage;
    pub fn gst_message_new_clock_lost(src: *mut GstObject, clock: *mut GstClock) -> *mut GstMessage;
    pub fn gst_message_new_clock_provide(src: *mut GstObject, clock: *mut GstClock, ready: gboolean) -> *mut GstMessage;
    pub fn gst_message_new_custom(type_: GstMessageType, src: *mut GstObject, structure: *mut GstStructure) -> *mut GstMessage;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_message_new_device_added(src: *mut GstObject, device: *mut GstDevice) -> *mut GstMessage;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_message_new_device_removed(src: *mut GstObject, device: *mut GstDevice) -> *mut GstMessage;
    pub fn gst_message_new_duration_changed(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_element(src: *mut GstObject, structure: *mut GstStructure) -> *mut GstMessage;
    pub fn gst_message_new_eos(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_error(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char) -> *mut GstMessage;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_new_error_with_details(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char, details: *mut GstStructure) -> *mut GstMessage;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_message_new_have_context(src: *mut GstObject, context: *mut GstContext) -> *mut GstMessage;
    pub fn gst_message_new_info(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char) -> *mut GstMessage;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_new_info_with_details(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char, details: *mut GstStructure) -> *mut GstMessage;
    pub fn gst_message_new_latency(src: *mut GstObject) -> *mut GstMessage;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_message_new_need_context(src: *mut GstObject, context_type: *const c_char) -> *mut GstMessage;
    pub fn gst_message_new_new_clock(src: *mut GstObject, clock: *mut GstClock) -> *mut GstMessage;
    pub fn gst_message_new_progress(src: *mut GstObject, type_: GstProgressType, code: *const c_char, text: *const c_char) -> *mut GstMessage;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_new_property_notify(src: *mut GstObject, property_name: *const c_char, val: *mut gobject::GValue) -> *mut GstMessage;
    pub fn gst_message_new_qos(src: *mut GstObject, live: gboolean, running_time: u64, stream_time: u64, timestamp: u64, duration: u64) -> *mut GstMessage;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_new_redirect(src: *mut GstObject, location: *const c_char, tag_list: *mut GstTagList, entry_struct: *const GstStructure) -> *mut GstMessage;
    pub fn gst_message_new_request_state(src: *mut GstObject, state: GstState) -> *mut GstMessage;
    pub fn gst_message_new_reset_time(src: *mut GstObject, running_time: GstClockTime) -> *mut GstMessage;
    pub fn gst_message_new_segment_done(src: *mut GstObject, format: GstFormat, position: i64) -> *mut GstMessage;
    pub fn gst_message_new_segment_start(src: *mut GstObject, format: GstFormat, position: i64) -> *mut GstMessage;
    pub fn gst_message_new_state_changed(src: *mut GstObject, oldstate: GstState, newstate: GstState, pending: GstState) -> *mut GstMessage;
    pub fn gst_message_new_state_dirty(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_step_done(src: *mut GstObject, format: GstFormat, amount: u64, rate: c_double, flush: gboolean, intermediate: gboolean, duration: u64, eos: gboolean) -> *mut GstMessage;
    pub fn gst_message_new_step_start(src: *mut GstObject, active: gboolean, format: GstFormat, amount: u64, rate: c_double, flush: gboolean, intermediate: gboolean) -> *mut GstMessage;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_new_stream_collection(src: *mut GstObject, collection: *mut GstStreamCollection) -> *mut GstMessage;
    pub fn gst_message_new_stream_start(src: *mut GstObject) -> *mut GstMessage;
    pub fn gst_message_new_stream_status(src: *mut GstObject, type_: GstStreamStatusType, owner: *mut GstElement) -> *mut GstMessage;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_new_streams_selected(src: *mut GstObject, collection: *mut GstStreamCollection) -> *mut GstMessage;
    pub fn gst_message_new_structure_change(src: *mut GstObject, type_: GstStructureChangeType, owner: *mut GstElement, busy: gboolean) -> *mut GstMessage;
    pub fn gst_message_new_tag(src: *mut GstObject, tag_list: *mut GstTagList) -> *mut GstMessage;
    pub fn gst_message_new_toc(src: *mut GstObject, toc: *mut GstToc, updated: gboolean) -> *mut GstMessage;
    pub fn gst_message_new_warning(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char) -> *mut GstMessage;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_new_warning_with_details(src: *mut GstObject, error: *mut glib::GError, debug: *const c_char, details: *mut GstStructure) -> *mut GstMessage;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_add_redirect_entry(message: *mut GstMessage, location: *const c_char, tag_list: *mut GstTagList, entry_struct: *const GstStructure);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_get_num_redirect_entries(message: *mut GstMessage) -> size_t;
    pub fn gst_message_get_seqnum(message: *mut GstMessage) -> u32;
    pub fn gst_message_get_stream_status_object(message: *mut GstMessage) -> *const gobject::GValue;
    pub fn gst_message_get_structure(message: *mut GstMessage) -> *const GstStructure;
    pub fn gst_message_has_name(message: *mut GstMessage, name: *const c_char) -> gboolean;
    pub fn gst_message_parse_async_done(message: *mut GstMessage, running_time: *mut GstClockTime);
    pub fn gst_message_parse_buffering(message: *mut GstMessage, percent: *mut c_int);
    pub fn gst_message_parse_buffering_stats(message: *mut GstMessage, mode: *mut GstBufferingMode, avg_in: *mut c_int, avg_out: *mut c_int, buffering_left: *mut i64);
    pub fn gst_message_parse_clock_lost(message: *mut GstMessage, clock: *mut *mut GstClock);
    pub fn gst_message_parse_clock_provide(message: *mut GstMessage, clock: *mut *mut GstClock, ready: *mut gboolean);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_message_parse_context_type(message: *mut GstMessage, context_type: *mut *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_message_parse_device_added(message: *mut GstMessage, device: *mut *mut GstDevice);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_message_parse_device_removed(message: *mut GstMessage, device: *mut *mut GstDevice);
    pub fn gst_message_parse_error(message: *mut GstMessage, gerror: *mut *mut glib::GError, debug: *mut *mut c_char);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_parse_error_details(message: *mut GstMessage, structure: *mut *const GstStructure);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_message_parse_group_id(message: *mut GstMessage, group_id: *mut c_uint) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_message_parse_have_context(message: *mut GstMessage, context: *mut *mut GstContext);
    pub fn gst_message_parse_info(message: *mut GstMessage, gerror: *mut *mut glib::GError, debug: *mut *mut c_char);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_parse_info_details(message: *mut GstMessage, structure: *mut *const GstStructure);
    pub fn gst_message_parse_new_clock(message: *mut GstMessage, clock: *mut *mut GstClock);
    pub fn gst_message_parse_progress(message: *mut GstMessage, type_: *mut GstProgressType, code: *mut *mut c_char, text: *mut *mut c_char);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_parse_property_notify(message: *mut GstMessage, object: *mut *mut GstObject, property_name: *mut *const c_char, property_value: *mut *const gobject::GValue);
    pub fn gst_message_parse_qos(message: *mut GstMessage, live: *mut gboolean, running_time: *mut u64, stream_time: *mut u64, timestamp: *mut u64, duration: *mut u64);
    pub fn gst_message_parse_qos_stats(message: *mut GstMessage, format: *mut GstFormat, processed: *mut u64, dropped: *mut u64);
    pub fn gst_message_parse_qos_values(message: *mut GstMessage, jitter: *mut i64, proportion: *mut c_double, quality: *mut c_int);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_parse_redirect_entry(message: *mut GstMessage, entry_index: size_t, location: *mut *const c_char, tag_list: *mut *mut GstTagList, entry_struct: *mut *const GstStructure);
    pub fn gst_message_parse_request_state(message: *mut GstMessage, state: *mut GstState);
    pub fn gst_message_parse_reset_time(message: *mut GstMessage, running_time: *mut GstClockTime);
    pub fn gst_message_parse_segment_done(message: *mut GstMessage, format: *mut GstFormat, position: *mut i64);
    pub fn gst_message_parse_segment_start(message: *mut GstMessage, format: *mut GstFormat, position: *mut i64);
    pub fn gst_message_parse_state_changed(message: *mut GstMessage, oldstate: *mut GstState, newstate: *mut GstState, pending: *mut GstState);
    pub fn gst_message_parse_step_done(message: *mut GstMessage, format: *mut GstFormat, amount: *mut u64, rate: *mut c_double, flush: *mut gboolean, intermediate: *mut gboolean, duration: *mut u64, eos: *mut gboolean);
    pub fn gst_message_parse_step_start(message: *mut GstMessage, active: *mut gboolean, format: *mut GstFormat, amount: *mut u64, rate: *mut c_double, flush: *mut gboolean, intermediate: *mut gboolean);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_parse_stream_collection(message: *mut GstMessage, collection: *mut *mut GstStreamCollection);
    pub fn gst_message_parse_stream_status(message: *mut GstMessage, type_: *mut GstStreamStatusType, owner: *mut *mut GstElement);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_parse_streams_selected(message: *mut GstMessage, collection: *mut *mut GstStreamCollection);
    pub fn gst_message_parse_structure_change(message: *mut GstMessage, type_: *mut GstStructureChangeType, owner: *mut *mut GstElement, busy: *mut gboolean);
    pub fn gst_message_parse_tag(message: *mut GstMessage, tag_list: *mut *mut GstTagList);
    pub fn gst_message_parse_toc(message: *mut GstMessage, toc: *mut *mut GstToc, updated: *mut gboolean);
    pub fn gst_message_parse_warning(message: *mut GstMessage, gerror: *mut *mut glib::GError, debug: *mut *mut c_char);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_parse_warning_details(message: *mut GstMessage, structure: *mut *const GstStructure);
    pub fn gst_message_set_buffering_stats(message: *mut GstMessage, mode: GstBufferingMode, avg_in: c_int, avg_out: c_int, buffering_left: i64);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_message_set_group_id(message: *mut GstMessage, group_id: c_uint);
    pub fn gst_message_set_qos_stats(message: *mut GstMessage, format: GstFormat, processed: u64, dropped: u64);
    pub fn gst_message_set_qos_values(message: *mut GstMessage, jitter: i64, proportion: c_double, quality: c_int);
    pub fn gst_message_set_seqnum(message: *mut GstMessage, seqnum: u32);
    pub fn gst_message_set_stream_status_object(message: *mut GstMessage, object: *const gobject::GValue);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_streams_selected_add(message: *mut GstMessage, stream: *mut GstStream);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_streams_selected_get_size(message: *mut GstMessage) -> c_uint;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_message_streams_selected_get_stream(message: *mut GstMessage, idx: c_uint) -> *mut GstStream;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_message_writable_structure(message: *mut GstMessage) -> *mut GstStructure;

    //=========================================================================
    // GstMeta
    //=========================================================================
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_meta_api_type_get_tags(api: GType) -> *mut *mut c_char;
    pub fn gst_meta_api_type_has_tag(api: GType, tag: glib::GQuark) -> gboolean;
    pub fn gst_meta_api_type_register(api: *const c_char, tags: *mut *mut c_char) -> GType;
    pub fn gst_meta_get_info(impl_: *const c_char) -> *const GstMetaInfo;
    pub fn gst_meta_register(api: GType, impl_: *const c_char, size: size_t, init_func: GstMetaInitFunction, free_func: GstMetaFreeFunction, transform_func: GstMetaTransformFunction) -> *const GstMetaInfo;

    //=========================================================================
    // GstMiniObject
    //=========================================================================
    pub fn gst_mini_object_copy(mini_object: *const GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_get_qdata(object: *mut GstMiniObject, quark: glib::GQuark) -> gpointer;
    pub fn gst_mini_object_init(mini_object: *mut GstMiniObject, flags: c_uint, type_: GType, copy_func: GstMiniObjectCopyFunction, dispose_func: GstMiniObjectDisposeFunction, free_func: GstMiniObjectFreeFunction);
    pub fn gst_mini_object_is_writable(mini_object: *const GstMiniObject) -> gboolean;
    pub fn gst_mini_object_lock(object: *mut GstMiniObject, flags: GstLockFlags) -> gboolean;
    pub fn gst_mini_object_make_writable(mini_object: *mut GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_ref(mini_object: *mut GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_set_qdata(object: *mut GstMiniObject, quark: glib::GQuark, data: gpointer, destroy: glib::GDestroyNotify);
    pub fn gst_mini_object_steal_qdata(object: *mut GstMiniObject, quark: glib::GQuark) -> gpointer;
    pub fn gst_mini_object_unlock(object: *mut GstMiniObject, flags: GstLockFlags);
    pub fn gst_mini_object_unref(mini_object: *mut GstMiniObject);
    pub fn gst_mini_object_weak_ref(object: *mut GstMiniObject, notify: GstMiniObjectNotify, data: gpointer);
    pub fn gst_mini_object_weak_unref(object: *mut GstMiniObject, notify: GstMiniObjectNotify, data: gpointer);
    pub fn gst_mini_object_replace(olddata: *mut *mut GstMiniObject, newdata: *mut GstMiniObject) -> gboolean;
    pub fn gst_mini_object_steal(olddata: *mut *mut GstMiniObject) -> *mut GstMiniObject;
    pub fn gst_mini_object_take(olddata: *mut *mut GstMiniObject, newdata: *mut GstMiniObject) -> gboolean;

    //=========================================================================
    // GstPadProbeInfo
    //=========================================================================
    pub fn gst_pad_probe_info_get_buffer(info: *mut GstPadProbeInfo) -> *mut GstBuffer;
    pub fn gst_pad_probe_info_get_buffer_list(info: *mut GstPadProbeInfo) -> *mut GstBufferList;
    pub fn gst_pad_probe_info_get_event(info: *mut GstPadProbeInfo) -> *mut GstEvent;
    pub fn gst_pad_probe_info_get_query(info: *mut GstPadProbeInfo) -> *mut GstQuery;

    //=========================================================================
    // GstParentBufferMeta
    //=========================================================================
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_parent_buffer_meta_get_info() -> *const GstMetaInfo;

    //=========================================================================
    // GstParseContext
    //=========================================================================
    pub fn gst_parse_context_get_type() -> GType;
    pub fn gst_parse_context_new() -> *mut GstParseContext;
    pub fn gst_parse_context_copy(context: *const GstParseContext) -> *mut GstParseContext;
    pub fn gst_parse_context_free(context: *mut GstParseContext);
    pub fn gst_parse_context_get_missing_elements(context: *mut GstParseContext) -> *mut *mut c_char;

    //=========================================================================
    // GstPoll
    //=========================================================================
    pub fn gst_poll_add_fd(set: *mut GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_can_read(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_can_write(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_ctl_read(set: *mut GstPoll, fd: *mut GstPollFD, active: gboolean) -> gboolean;
    pub fn gst_poll_fd_ctl_write(set: *mut GstPoll, fd: *mut GstPollFD, active: gboolean) -> gboolean;
    pub fn gst_poll_fd_has_closed(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_has_error(set: *const GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_fd_ignored(set: *mut GstPoll, fd: *mut GstPollFD);
    pub fn gst_poll_free(set: *mut GstPoll);
    pub fn gst_poll_get_read_gpollfd(set: *mut GstPoll, fd: *mut glib::GPollFD);
    pub fn gst_poll_read_control(set: *mut GstPoll) -> gboolean;
    pub fn gst_poll_remove_fd(set: *mut GstPoll, fd: *mut GstPollFD) -> gboolean;
    pub fn gst_poll_restart(set: *mut GstPoll);
    pub fn gst_poll_set_controllable(set: *mut GstPoll, controllable: gboolean) -> gboolean;
    pub fn gst_poll_set_flushing(set: *mut GstPoll, flushing: gboolean);
    pub fn gst_poll_wait(set: *mut GstPoll, timeout: GstClockTime) -> c_int;
    pub fn gst_poll_write_control(set: *mut GstPoll) -> gboolean;
    pub fn gst_poll_new(controllable: gboolean) -> *mut GstPoll;
    pub fn gst_poll_new_timer() -> *mut GstPoll;

    //=========================================================================
    // GstPollFD
    //=========================================================================
    pub fn gst_poll_fd_init(fd: *mut GstPollFD);

    //=========================================================================
    // GstPromise
    //=========================================================================
    pub fn gst_promise_get_type() -> GType;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_promise_new() -> *mut GstPromise;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_promise_new_with_change_func(func: GstPromiseChangeFunc, user_data: gpointer, notify: glib::GDestroyNotify) -> *mut GstPromise;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_promise_expire(promise: *mut GstPromise);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_promise_get_reply(promise: *mut GstPromise) -> *const GstStructure;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_promise_interrupt(promise: *mut GstPromise);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_promise_reply(promise: *mut GstPromise, s: *mut GstStructure);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_promise_wait(promise: *mut GstPromise) -> GstPromiseResult;

    //=========================================================================
    // GstProtectionMeta
    //=========================================================================
    pub fn gst_protection_meta_get_info() -> *const GstMetaInfo;

    //=========================================================================
    // GstQuery
    //=========================================================================
    pub fn gst_query_get_type() -> GType;
    pub fn gst_query_new_accept_caps(caps: *mut GstCaps) -> *mut GstQuery;
    pub fn gst_query_new_allocation(caps: *mut GstCaps, need_pool: gboolean) -> *mut GstQuery;
    pub fn gst_query_new_buffering(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_caps(filter: *mut GstCaps) -> *mut GstQuery;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_query_new_context(context_type: *const c_char) -> *mut GstQuery;
    pub fn gst_query_new_convert(src_format: GstFormat, value: i64, dest_format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_custom(type_: GstQueryType, structure: *mut GstStructure) -> *mut GstQuery;
    pub fn gst_query_new_drain() -> *mut GstQuery;
    pub fn gst_query_new_duration(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_formats() -> *mut GstQuery;
    pub fn gst_query_new_latency() -> *mut GstQuery;
    pub fn gst_query_new_position(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_scheduling() -> *mut GstQuery;
    pub fn gst_query_new_seeking(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_segment(format: GstFormat) -> *mut GstQuery;
    pub fn gst_query_new_uri() -> *mut GstQuery;
    pub fn gst_query_add_allocation_meta(query: *mut GstQuery, api: GType, params: *const GstStructure);
    pub fn gst_query_add_allocation_param(query: *mut GstQuery, allocator: *mut GstAllocator, params: *const GstAllocationParams);
    pub fn gst_query_add_allocation_pool(query: *mut GstQuery, pool: *mut GstBufferPool, size: c_uint, min_buffers: c_uint, max_buffers: c_uint);
    pub fn gst_query_add_buffering_range(query: *mut GstQuery, start: i64, stop: i64) -> gboolean;
    pub fn gst_query_add_scheduling_mode(query: *mut GstQuery, mode: GstPadMode);
    pub fn gst_query_find_allocation_meta(query: *mut GstQuery, api: GType, index: *mut c_uint) -> gboolean;
    pub fn gst_query_get_n_allocation_metas(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_allocation_params(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_allocation_pools(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_buffering_ranges(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_n_scheduling_modes(query: *mut GstQuery) -> c_uint;
    pub fn gst_query_get_structure(query: *mut GstQuery) -> *const GstStructure;
    pub fn gst_query_has_scheduling_mode(query: *mut GstQuery, mode: GstPadMode) -> gboolean;
    pub fn gst_query_has_scheduling_mode_with_flags(query: *mut GstQuery, mode: GstPadMode, flags: GstSchedulingFlags) -> gboolean;
    pub fn gst_query_parse_accept_caps(query: *mut GstQuery, caps: *mut *mut GstCaps);
    pub fn gst_query_parse_accept_caps_result(query: *mut GstQuery, result: *mut gboolean);
    pub fn gst_query_parse_allocation(query: *mut GstQuery, caps: *mut *mut GstCaps, need_pool: *mut gboolean);
    pub fn gst_query_parse_buffering_percent(query: *mut GstQuery, busy: *mut gboolean, percent: *mut c_int);
    pub fn gst_query_parse_buffering_range(query: *mut GstQuery, format: *mut GstFormat, start: *mut i64, stop: *mut i64, estimated_total: *mut i64);
    pub fn gst_query_parse_buffering_stats(query: *mut GstQuery, mode: *mut GstBufferingMode, avg_in: *mut c_int, avg_out: *mut c_int, buffering_left: *mut i64);
    pub fn gst_query_parse_caps(query: *mut GstQuery, filter: *mut *mut GstCaps);
    pub fn gst_query_parse_caps_result(query: *mut GstQuery, caps: *mut *mut GstCaps);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_query_parse_context(query: *mut GstQuery, context: *mut *mut GstContext);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_query_parse_context_type(query: *mut GstQuery, context_type: *mut *const c_char) -> gboolean;
    pub fn gst_query_parse_convert(query: *mut GstQuery, src_format: *mut GstFormat, src_value: *mut i64, dest_format: *mut GstFormat, dest_value: *mut i64);
    pub fn gst_query_parse_duration(query: *mut GstQuery, format: *mut GstFormat, duration: *mut i64);
    pub fn gst_query_parse_latency(query: *mut GstQuery, live: *mut gboolean, min_latency: *mut GstClockTime, max_latency: *mut GstClockTime);
    pub fn gst_query_parse_n_formats(query: *mut GstQuery, n_formats: *mut c_uint);
    pub fn gst_query_parse_nth_allocation_meta(query: *mut GstQuery, index: c_uint, params: *mut *const GstStructure) -> GType;
    pub fn gst_query_parse_nth_allocation_param(query: *mut GstQuery, index: c_uint, allocator: *mut *mut GstAllocator, params: *mut GstAllocationParams);
    pub fn gst_query_parse_nth_allocation_pool(query: *mut GstQuery, index: c_uint, pool: *mut *mut GstBufferPool, size: *mut c_uint, min_buffers: *mut c_uint, max_buffers: *mut c_uint);
    pub fn gst_query_parse_nth_buffering_range(query: *mut GstQuery, index: c_uint, start: *mut i64, stop: *mut i64) -> gboolean;
    pub fn gst_query_parse_nth_format(query: *mut GstQuery, nth: c_uint, format: *mut GstFormat);
    pub fn gst_query_parse_nth_scheduling_mode(query: *mut GstQuery, index: c_uint) -> GstPadMode;
    pub fn gst_query_parse_position(query: *mut GstQuery, format: *mut GstFormat, cur: *mut i64);
    pub fn gst_query_parse_scheduling(query: *mut GstQuery, flags: *mut GstSchedulingFlags, minsize: *mut c_int, maxsize: *mut c_int, align: *mut c_int);
    pub fn gst_query_parse_seeking(query: *mut GstQuery, format: *mut GstFormat, seekable: *mut gboolean, segment_start: *mut i64, segment_end: *mut i64);
    pub fn gst_query_parse_segment(query: *mut GstQuery, rate: *mut c_double, format: *mut GstFormat, start_value: *mut i64, stop_value: *mut i64);
    pub fn gst_query_parse_uri(query: *mut GstQuery, uri: *mut *mut c_char);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_query_parse_uri_redirection(query: *mut GstQuery, uri: *mut *mut c_char);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_query_parse_uri_redirection_permanent(query: *mut GstQuery, permanent: *mut gboolean);
    pub fn gst_query_remove_nth_allocation_meta(query: *mut GstQuery, index: c_uint);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_query_remove_nth_allocation_param(query: *mut GstQuery, index: c_uint);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_query_remove_nth_allocation_pool(query: *mut GstQuery, index: c_uint);
    pub fn gst_query_set_accept_caps_result(query: *mut GstQuery, result: gboolean);
    pub fn gst_query_set_buffering_percent(query: *mut GstQuery, busy: gboolean, percent: c_int);
    pub fn gst_query_set_buffering_range(query: *mut GstQuery, format: GstFormat, start: i64, stop: i64, estimated_total: i64);
    pub fn gst_query_set_buffering_stats(query: *mut GstQuery, mode: GstBufferingMode, avg_in: c_int, avg_out: c_int, buffering_left: i64);
    pub fn gst_query_set_caps_result(query: *mut GstQuery, caps: *mut GstCaps);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_query_set_context(query: *mut GstQuery, context: *mut GstContext);
    pub fn gst_query_set_convert(query: *mut GstQuery, src_format: GstFormat, src_value: i64, dest_format: GstFormat, dest_value: i64);
    pub fn gst_query_set_duration(query: *mut GstQuery, format: GstFormat, duration: i64);
    pub fn gst_query_set_formats(query: *mut GstQuery, n_formats: c_int, ...);
    pub fn gst_query_set_formatsv(query: *mut GstQuery, n_formats: c_int, formats: *mut GstFormat);
    pub fn gst_query_set_latency(query: *mut GstQuery, live: gboolean, min_latency: GstClockTime, max_latency: GstClockTime);
    pub fn gst_query_set_nth_allocation_param(query: *mut GstQuery, index: c_uint, allocator: *mut GstAllocator, params: *const GstAllocationParams);
    pub fn gst_query_set_nth_allocation_pool(query: *mut GstQuery, index: c_uint, pool: *mut GstBufferPool, size: c_uint, min_buffers: c_uint, max_buffers: c_uint);
    pub fn gst_query_set_position(query: *mut GstQuery, format: GstFormat, cur: i64);
    pub fn gst_query_set_scheduling(query: *mut GstQuery, flags: GstSchedulingFlags, minsize: c_int, maxsize: c_int, align: c_int);
    pub fn gst_query_set_seeking(query: *mut GstQuery, format: GstFormat, seekable: gboolean, segment_start: i64, segment_end: i64);
    pub fn gst_query_set_segment(query: *mut GstQuery, rate: c_double, format: GstFormat, start_value: i64, stop_value: i64);
    pub fn gst_query_set_uri(query: *mut GstQuery, uri: *const c_char);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_query_set_uri_redirection(query: *mut GstQuery, uri: *const c_char);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_query_set_uri_redirection_permanent(query: *mut GstQuery, permanent: gboolean);
    pub fn gst_query_writable_structure(query: *mut GstQuery) -> *mut GstStructure;

    //=========================================================================
    // GstReferenceTimestampMeta
    //=========================================================================
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_reference_timestamp_meta_get_info() -> *const GstMetaInfo;

    //=========================================================================
    // GstSample
    //=========================================================================
    pub fn gst_sample_get_type() -> GType;
    pub fn gst_sample_new(buffer: *mut GstBuffer, caps: *mut GstCaps, segment: *const GstSegment, info: *mut GstStructure) -> *mut GstSample;
    pub fn gst_sample_get_buffer(sample: *mut GstSample) -> *mut GstBuffer;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_sample_get_buffer_list(sample: *mut GstSample) -> *mut GstBufferList;
    pub fn gst_sample_get_caps(sample: *mut GstSample) -> *mut GstCaps;
    pub fn gst_sample_get_info(sample: *mut GstSample) -> *const GstStructure;
    pub fn gst_sample_get_segment(sample: *mut GstSample) -> *mut GstSegment;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_sample_set_buffer_list(sample: *mut GstSample, buffer_list: *mut GstBufferList);

    //=========================================================================
    // GstSegment
    //=========================================================================
    pub fn gst_segment_get_type() -> GType;
    pub fn gst_segment_new() -> *mut GstSegment;
    pub fn gst_segment_clip(segment: *const GstSegment, format: GstFormat, start: u64, stop: u64, clip_start: *mut u64, clip_stop: *mut u64) -> gboolean;
    pub fn gst_segment_copy(segment: *const GstSegment) -> *mut GstSegment;
    pub fn gst_segment_copy_into(src: *const GstSegment, dest: *mut GstSegment);
    pub fn gst_segment_do_seek(segment: *mut GstSegment, rate: c_double, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: u64, stop_type: GstSeekType, stop: u64, update: *mut gboolean) -> gboolean;
    pub fn gst_segment_free(segment: *mut GstSegment);
    pub fn gst_segment_init(segment: *mut GstSegment, format: GstFormat);
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_segment_is_equal(s0: *const GstSegment, s1: *const GstSegment) -> gboolean;
    #[cfg(any(feature = "v1_2_3", feature = "dox"))]
    pub fn gst_segment_offset_running_time(segment: *mut GstSegment, format: GstFormat, offset: i64) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_segment_position_from_running_time(segment: *const GstSegment, format: GstFormat, running_time: u64) -> u64;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_segment_position_from_running_time_full(segment: *const GstSegment, format: GstFormat, running_time: u64, position: *mut u64) -> c_int;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_segment_position_from_stream_time(segment: *const GstSegment, format: GstFormat, stream_time: u64) -> u64;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_segment_position_from_stream_time_full(segment: *const GstSegment, format: GstFormat, stream_time: u64, position: *mut u64) -> c_int;
    pub fn gst_segment_set_running_time(segment: *mut GstSegment, format: GstFormat, running_time: u64) -> gboolean;
    pub fn gst_segment_to_position(segment: *const GstSegment, format: GstFormat, running_time: u64) -> u64;
    pub fn gst_segment_to_running_time(segment: *const GstSegment, format: GstFormat, position: u64) -> u64;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_segment_to_running_time_full(segment: *const GstSegment, format: GstFormat, position: u64, running_time: *mut u64) -> c_int;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_segment_to_stream_time(segment: *const GstSegment, format: GstFormat, position: u64) -> u64;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_segment_to_stream_time_full(segment: *const GstSegment, format: GstFormat, position: u64, stream_time: *mut u64) -> c_int;

    //=========================================================================
    // GstStaticCaps
    //=========================================================================
    pub fn gst_static_caps_cleanup(static_caps: *mut GstStaticCaps);
    pub fn gst_static_caps_get(static_caps: *mut GstStaticCaps) -> *mut GstCaps;

    //=========================================================================
    // GstStaticPadTemplate
    //=========================================================================
    pub fn gst_static_pad_template_get(pad_template: *mut GstStaticPadTemplate) -> *mut GstPadTemplate;
    pub fn gst_static_pad_template_get_caps(templ: *mut GstStaticPadTemplate) -> *mut GstCaps;

    //=========================================================================
    // GstStructure
    //=========================================================================
    pub fn gst_structure_get_type() -> GType;
    pub fn gst_structure_new(name: *const c_char, firstfield: *const c_char, ...) -> *mut GstStructure;
    pub fn gst_structure_new_empty(name: *const c_char) -> *mut GstStructure;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_structure_new_from_string(string: *const c_char) -> *mut GstStructure;
    pub fn gst_structure_new_id(name_quark: glib::GQuark, field_quark: glib::GQuark, ...) -> *mut GstStructure;
    pub fn gst_structure_new_id_empty(quark: glib::GQuark) -> *mut GstStructure;
    //pub fn gst_structure_new_valist(name: *const c_char, firstfield: *const c_char, varargs: /*Unimplemented*/va_list) -> *mut GstStructure;
    pub fn gst_structure_can_intersect(struct1: *const GstStructure, struct2: *const GstStructure) -> gboolean;
    pub fn gst_structure_copy(structure: *const GstStructure) -> *mut GstStructure;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_structure_filter_and_map_in_place(structure: *mut GstStructure, func: GstStructureFilterMapFunc, user_data: gpointer);
    pub fn gst_structure_fixate(structure: *mut GstStructure);
    pub fn gst_structure_fixate_field(structure: *mut GstStructure, field_name: *const c_char) -> gboolean;
    pub fn gst_structure_fixate_field_boolean(structure: *mut GstStructure, field_name: *const c_char, target: gboolean) -> gboolean;
    pub fn gst_structure_fixate_field_nearest_double(structure: *mut GstStructure, field_name: *const c_char, target: c_double) -> gboolean;
    pub fn gst_structure_fixate_field_nearest_fraction(structure: *mut GstStructure, field_name: *const c_char, target_numerator: c_int, target_denominator: c_int) -> gboolean;
    pub fn gst_structure_fixate_field_nearest_int(structure: *mut GstStructure, field_name: *const c_char, target: c_int) -> gboolean;
    pub fn gst_structure_fixate_field_string(structure: *mut GstStructure, field_name: *const c_char, target: *const c_char) -> gboolean;
    pub fn gst_structure_foreach(structure: *const GstStructure, func: GstStructureForeachFunc, user_data: gpointer) -> gboolean;
    pub fn gst_structure_free(structure: *mut GstStructure);
    pub fn gst_structure_get(structure: *const GstStructure, first_fieldname: *const c_char, ...) -> gboolean;
    pub fn gst_structure_get_array(structure: *mut GstStructure, fieldname: *const c_char, array: *mut *mut gobject::GValueArray) -> gboolean;
    pub fn gst_structure_get_boolean(structure: *const GstStructure, fieldname: *const c_char, value: *mut gboolean) -> gboolean;
    pub fn gst_structure_get_clock_time(structure: *const GstStructure, fieldname: *const c_char, value: *mut GstClockTime) -> gboolean;
    pub fn gst_structure_get_date(structure: *const GstStructure, fieldname: *const c_char, value: *mut *mut glib::GDate) -> gboolean;
    pub fn gst_structure_get_date_time(structure: *const GstStructure, fieldname: *const c_char, value: *mut *mut GstDateTime) -> gboolean;
    pub fn gst_structure_get_double(structure: *const GstStructure, fieldname: *const c_char, value: *mut c_double) -> gboolean;
    pub fn gst_structure_get_enum(structure: *const GstStructure, fieldname: *const c_char, enumtype: GType, value: *mut c_int) -> gboolean;
    pub fn gst_structure_get_field_type(structure: *const GstStructure, fieldname: *const c_char) -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_structure_get_flagset(structure: *const GstStructure, fieldname: *const c_char, value_flags: *mut c_uint, value_mask: *mut c_uint) -> gboolean;
    pub fn gst_structure_get_fraction(structure: *const GstStructure, fieldname: *const c_char, value_numerator: *mut c_int, value_denominator: *mut c_int) -> gboolean;
    pub fn gst_structure_get_int(structure: *const GstStructure, fieldname: *const c_char, value: *mut c_int) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_structure_get_int64(structure: *const GstStructure, fieldname: *const c_char, value: *mut i64) -> gboolean;
    pub fn gst_structure_get_list(structure: *mut GstStructure, fieldname: *const c_char, array: *mut *mut gobject::GValueArray) -> gboolean;
    pub fn gst_structure_get_name(structure: *const GstStructure) -> *const c_char;
    pub fn gst_structure_get_name_id(structure: *const GstStructure) -> glib::GQuark;
    pub fn gst_structure_get_string(structure: *const GstStructure, fieldname: *const c_char) -> *const c_char;
    pub fn gst_structure_get_uint(structure: *const GstStructure, fieldname: *const c_char, value: *mut c_uint) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_structure_get_uint64(structure: *const GstStructure, fieldname: *const c_char, value: *mut u64) -> gboolean;
    //pub fn gst_structure_get_valist(structure: *const GstStructure, first_fieldname: *const c_char, args: /*Unimplemented*/va_list) -> gboolean;
    pub fn gst_structure_get_value(structure: *const GstStructure, fieldname: *const c_char) -> *const gobject::GValue;
    pub fn gst_structure_has_field(structure: *const GstStructure, fieldname: *const c_char) -> gboolean;
    pub fn gst_structure_has_field_typed(structure: *const GstStructure, fieldname: *const c_char, type_: GType) -> gboolean;
    pub fn gst_structure_has_name(structure: *const GstStructure, name: *const c_char) -> gboolean;
    pub fn gst_structure_id_get(structure: *const GstStructure, first_field_id: glib::GQuark, ...) -> gboolean;
    //pub fn gst_structure_id_get_valist(structure: *const GstStructure, first_field_id: glib::GQuark, args: /*Unimplemented*/va_list) -> gboolean;
    pub fn gst_structure_id_get_value(structure: *const GstStructure, field: glib::GQuark) -> *const gobject::GValue;
    pub fn gst_structure_id_has_field(structure: *const GstStructure, field: glib::GQuark) -> gboolean;
    pub fn gst_structure_id_has_field_typed(structure: *const GstStructure, field: glib::GQuark, type_: GType) -> gboolean;
    pub fn gst_structure_id_set(structure: *mut GstStructure, fieldname: glib::GQuark, ...);
    //pub fn gst_structure_id_set_valist(structure: *mut GstStructure, fieldname: glib::GQuark, varargs: /*Unimplemented*/va_list);
    pub fn gst_structure_id_set_value(structure: *mut GstStructure, field: glib::GQuark, value: *const gobject::GValue);
    pub fn gst_structure_id_take_value(structure: *mut GstStructure, field: glib::GQuark, value: *mut gobject::GValue);
    pub fn gst_structure_intersect(struct1: *const GstStructure, struct2: *const GstStructure) -> *mut GstStructure;
    pub fn gst_structure_is_equal(structure1: *const GstStructure, structure2: *const GstStructure) -> gboolean;
    pub fn gst_structure_is_subset(subset: *const GstStructure, superset: *const GstStructure) -> gboolean;
    pub fn gst_structure_map_in_place(structure: *mut GstStructure, func: GstStructureMapFunc, user_data: gpointer) -> gboolean;
    pub fn gst_structure_n_fields(structure: *const GstStructure) -> c_int;
    pub fn gst_structure_nth_field_name(structure: *const GstStructure, index: c_uint) -> *const c_char;
    pub fn gst_structure_remove_all_fields(structure: *mut GstStructure);
    pub fn gst_structure_remove_field(structure: *mut GstStructure, fieldname: *const c_char);
    pub fn gst_structure_remove_fields(structure: *mut GstStructure, fieldname: *const c_char, ...);
    //pub fn gst_structure_remove_fields_valist(structure: *mut GstStructure, fieldname: *const c_char, varargs: /*Unimplemented*/va_list);
    pub fn gst_structure_set(structure: *mut GstStructure, fieldname: *const c_char, ...);
    pub fn gst_structure_set_array(structure: *mut GstStructure, fieldname: *const c_char, array: *const gobject::GValueArray);
    pub fn gst_structure_set_list(structure: *mut GstStructure, fieldname: *const c_char, array: *const gobject::GValueArray);
    pub fn gst_structure_set_name(structure: *mut GstStructure, name: *const c_char);
    pub fn gst_structure_set_parent_refcount(structure: *mut GstStructure, refcount: *mut c_int) -> gboolean;
    //pub fn gst_structure_set_valist(structure: *mut GstStructure, fieldname: *const c_char, varargs: /*Unimplemented*/va_list);
    pub fn gst_structure_set_value(structure: *mut GstStructure, fieldname: *const c_char, value: *const gobject::GValue);
    pub fn gst_structure_take_value(structure: *mut GstStructure, fieldname: *const c_char, value: *mut gobject::GValue);
    pub fn gst_structure_to_string(structure: *const GstStructure) -> *mut c_char;
    pub fn gst_structure_from_string(string: *const c_char, end: *mut *mut c_char) -> *mut GstStructure;

    //=========================================================================
    // GstTagList
    //=========================================================================
    pub fn gst_tag_list_get_type() -> GType;
    pub fn gst_tag_list_new(tag: *const c_char, ...) -> *mut GstTagList;
    pub fn gst_tag_list_new_empty() -> *mut GstTagList;
    pub fn gst_tag_list_new_from_string(str: *const c_char) -> *mut GstTagList;
    //pub fn gst_tag_list_new_valist(var_args: /*Unimplemented*/va_list) -> *mut GstTagList;
    pub fn gst_tag_list_add(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, ...);
    //pub fn gst_tag_list_add_valist(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    //pub fn gst_tag_list_add_valist_values(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gst_tag_list_add_value(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, value: *const gobject::GValue);
    pub fn gst_tag_list_add_values(list: *mut GstTagList, mode: GstTagMergeMode, tag: *const c_char, ...);
    pub fn gst_tag_list_foreach(list: *const GstTagList, func: GstTagForeachFunc, user_data: gpointer);
    pub fn gst_tag_list_get_boolean(list: *const GstTagList, tag: *const c_char, value: *mut gboolean) -> gboolean;
    pub fn gst_tag_list_get_boolean_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut gboolean) -> gboolean;
    pub fn gst_tag_list_get_date(list: *const GstTagList, tag: *const c_char, value: *mut *mut glib::GDate) -> gboolean;
    pub fn gst_tag_list_get_date_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut *mut glib::GDate) -> gboolean;
    pub fn gst_tag_list_get_date_time(list: *const GstTagList, tag: *const c_char, value: *mut *mut GstDateTime) -> gboolean;
    pub fn gst_tag_list_get_date_time_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut *mut GstDateTime) -> gboolean;
    pub fn gst_tag_list_get_double(list: *const GstTagList, tag: *const c_char, value: *mut c_double) -> gboolean;
    pub fn gst_tag_list_get_double_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut c_double) -> gboolean;
    pub fn gst_tag_list_get_float(list: *const GstTagList, tag: *const c_char, value: *mut c_float) -> gboolean;
    pub fn gst_tag_list_get_float_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut c_float) -> gboolean;
    pub fn gst_tag_list_get_int(list: *const GstTagList, tag: *const c_char, value: *mut c_int) -> gboolean;
    pub fn gst_tag_list_get_int64(list: *const GstTagList, tag: *const c_char, value: *mut i64) -> gboolean;
    pub fn gst_tag_list_get_int64_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut i64) -> gboolean;
    pub fn gst_tag_list_get_int_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut c_int) -> gboolean;
    pub fn gst_tag_list_get_pointer(list: *const GstTagList, tag: *const c_char, value: *mut gpointer) -> gboolean;
    pub fn gst_tag_list_get_pointer_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut gpointer) -> gboolean;
    pub fn gst_tag_list_get_sample(list: *const GstTagList, tag: *const c_char, sample: *mut *mut GstSample) -> gboolean;
    pub fn gst_tag_list_get_sample_index(list: *const GstTagList, tag: *const c_char, index: c_uint, sample: *mut *mut GstSample) -> gboolean;
    pub fn gst_tag_list_get_scope(list: *const GstTagList) -> GstTagScope;
    pub fn gst_tag_list_get_string(list: *const GstTagList, tag: *const c_char, value: *mut *mut c_char) -> gboolean;
    pub fn gst_tag_list_get_string_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut *mut c_char) -> gboolean;
    pub fn gst_tag_list_get_tag_size(list: *const GstTagList, tag: *const c_char) -> c_uint;
    pub fn gst_tag_list_get_uint(list: *const GstTagList, tag: *const c_char, value: *mut c_uint) -> gboolean;
    pub fn gst_tag_list_get_uint64(list: *const GstTagList, tag: *const c_char, value: *mut u64) -> gboolean;
    pub fn gst_tag_list_get_uint64_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut u64) -> gboolean;
    pub fn gst_tag_list_get_uint_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut c_uint) -> gboolean;
    pub fn gst_tag_list_get_value_index(list: *const GstTagList, tag: *const c_char, index: c_uint) -> *const gobject::GValue;
    pub fn gst_tag_list_insert(into: *mut GstTagList, from: *const GstTagList, mode: GstTagMergeMode);
    pub fn gst_tag_list_is_empty(list: *const GstTagList) -> gboolean;
    pub fn gst_tag_list_is_equal(list1: *const GstTagList, list2: *const GstTagList) -> gboolean;
    pub fn gst_tag_list_merge(list1: *const GstTagList, list2: *const GstTagList, mode: GstTagMergeMode) -> *mut GstTagList;
    pub fn gst_tag_list_n_tags(list: *const GstTagList) -> c_int;
    pub fn gst_tag_list_nth_tag_name(list: *const GstTagList, index: c_uint) -> *const c_char;
    pub fn gst_tag_list_peek_string_index(list: *const GstTagList, tag: *const c_char, index: c_uint, value: *mut *const c_char) -> gboolean;
    pub fn gst_tag_list_remove_tag(list: *mut GstTagList, tag: *const c_char);
    pub fn gst_tag_list_set_scope(list: *mut GstTagList, scope: GstTagScope);
    pub fn gst_tag_list_to_string(list: *const GstTagList) -> *mut c_char;
    pub fn gst_tag_list_copy_value(dest: *mut gobject::GValue, list: *const GstTagList, tag: *const c_char) -> gboolean;

    //=========================================================================
    // GstToc
    //=========================================================================
    pub fn gst_toc_get_type() -> GType;
    pub fn gst_toc_new(scope: GstTocScope) -> *mut GstToc;
    pub fn gst_toc_append_entry(toc: *mut GstToc, entry: *mut GstTocEntry);
    pub fn gst_toc_dump(toc: *mut GstToc);
    pub fn gst_toc_find_entry(toc: *const GstToc, uid: *const c_char) -> *mut GstTocEntry;
    pub fn gst_toc_get_entries(toc: *const GstToc) -> *mut glib::GList;
    pub fn gst_toc_get_scope(toc: *const GstToc) -> GstTocScope;
    pub fn gst_toc_get_tags(toc: *const GstToc) -> *mut GstTagList;
    pub fn gst_toc_merge_tags(toc: *mut GstToc, tags: *mut GstTagList, mode: GstTagMergeMode);
    pub fn gst_toc_set_tags(toc: *mut GstToc, tags: *mut GstTagList);

    //=========================================================================
    // GstTocEntry
    //=========================================================================
    pub fn gst_toc_entry_get_type() -> GType;
    pub fn gst_toc_entry_new(type_: GstTocEntryType, uid: *const c_char) -> *mut GstTocEntry;
    pub fn gst_toc_entry_append_sub_entry(entry: *mut GstTocEntry, subentry: *mut GstTocEntry);
    pub fn gst_toc_entry_get_entry_type(entry: *const GstTocEntry) -> GstTocEntryType;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_toc_entry_get_loop(entry: *const GstTocEntry, loop_type: *mut GstTocLoopType, repeat_count: *mut c_int) -> gboolean;
    pub fn gst_toc_entry_get_parent(entry: *mut GstTocEntry) -> *mut GstTocEntry;
    pub fn gst_toc_entry_get_start_stop_times(entry: *const GstTocEntry, start: *mut i64, stop: *mut i64) -> gboolean;
    pub fn gst_toc_entry_get_sub_entries(entry: *const GstTocEntry) -> *mut glib::GList;
    pub fn gst_toc_entry_get_tags(entry: *const GstTocEntry) -> *mut GstTagList;
    pub fn gst_toc_entry_get_toc(entry: *mut GstTocEntry) -> *mut GstToc;
    pub fn gst_toc_entry_get_uid(entry: *const GstTocEntry) -> *const c_char;
    pub fn gst_toc_entry_is_alternative(entry: *const GstTocEntry) -> gboolean;
    pub fn gst_toc_entry_is_sequence(entry: *const GstTocEntry) -> gboolean;
    pub fn gst_toc_entry_merge_tags(entry: *mut GstTocEntry, tags: *mut GstTagList, mode: GstTagMergeMode);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_toc_entry_set_loop(entry: *mut GstTocEntry, loop_type: GstTocLoopType, repeat_count: c_int);
    pub fn gst_toc_entry_set_start_stop_times(entry: *mut GstTocEntry, start: i64, stop: i64);
    pub fn gst_toc_entry_set_tags(entry: *mut GstTocEntry, tags: *mut GstTagList);

    //=========================================================================
    // GstTypeFind
    //=========================================================================
    pub fn gst_type_find_get_length(find: *mut GstTypeFind) -> u64;
    pub fn gst_type_find_peek(find: *mut GstTypeFind, offset: i64, size: c_uint) -> *mut u8;
    pub fn gst_type_find_suggest(find: *mut GstTypeFind, probability: c_uint, caps: *mut GstCaps);
    pub fn gst_type_find_suggest_simple(find: *mut GstTypeFind, probability: c_uint, media_type: *const c_char, fieldname: *const c_char, ...);
    pub fn gst_type_find_register(plugin: *mut GstPlugin, name: *const c_char, rank: c_uint, func: GstTypeFindFunction, extensions: *const c_char, possible_caps: *mut GstCaps, data: gpointer, data_notify: glib::GDestroyNotify) -> gboolean;

    //=========================================================================
    // GstUri
    //=========================================================================
    pub fn gst_uri_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_new(scheme: *const c_char, userinfo: *const c_char, host: *const c_char, port: c_uint, path: *const c_char, query: *const c_char, fragment: *const c_char) -> *mut GstUri;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_append_path(uri: *mut GstUri, relative_path: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_append_path_segment(uri: *mut GstUri, path_segment: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_equal(first: *const GstUri, second: *const GstUri) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_from_string_with_base(base: *mut GstUri, uri: *const c_char) -> *mut GstUri;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_fragment(uri: *const GstUri) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_host(uri: *const GstUri) -> *const c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_uri_get_media_fragment_table(uri: *const GstUri) -> *mut glib::GHashTable;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_path(uri: *const GstUri) -> *mut c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_path_segments(uri: *const GstUri) -> *mut glib::GList;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_path_string(uri: *const GstUri) -> *mut c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_port(uri: *const GstUri) -> c_uint;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_query_keys(uri: *const GstUri) -> *mut glib::GList;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_query_string(uri: *const GstUri) -> *mut c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_query_table(uri: *const GstUri) -> *mut glib::GHashTable;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_query_value(uri: *const GstUri, query_key: *const c_char) -> *const c_char;
    pub fn gst_uri_get_scheme(uri: *const GstUri) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_get_userinfo(uri: *const GstUri) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_is_normalized(uri: *const GstUri) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_is_writable(uri: *const GstUri) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_join(base_uri: *mut GstUri, ref_uri: *mut GstUri) -> *mut GstUri;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_make_writable(uri: *mut GstUri) -> *mut GstUri;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_new_with_base(base: *mut GstUri, scheme: *const c_char, userinfo: *const c_char, host: *const c_char, port: c_uint, path: *const c_char, query: *const c_char, fragment: *const c_char) -> *mut GstUri;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_normalize(uri: *mut GstUri) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_query_has_key(uri: *const GstUri, query_key: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_remove_query_key(uri: *mut GstUri, query_key: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_fragment(uri: *mut GstUri, fragment: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_host(uri: *mut GstUri, host: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_path(uri: *mut GstUri, path: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_path_segments(uri: *mut GstUri, path_segments: *mut glib::GList) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_path_string(uri: *mut GstUri, path: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_port(uri: *mut GstUri, port: c_uint) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_query_string(uri: *mut GstUri, query: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_query_table(uri: *mut GstUri, query_table: *mut glib::GHashTable) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_query_value(uri: *mut GstUri, query_key: *const c_char, query_value: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_scheme(uri: *mut GstUri, scheme: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_set_userinfo(uri: *mut GstUri, userinfo: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_to_string(uri: *const GstUri) -> *mut c_char;
    pub fn gst_uri_construct(protocol: *const c_char, location: *const c_char) -> *mut c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_from_string(uri: *const c_char) -> *mut GstUri;
    pub fn gst_uri_get_location(uri: *const c_char) -> *mut c_char;
    pub fn gst_uri_get_protocol(uri: *const c_char) -> *mut c_char;
    pub fn gst_uri_has_protocol(uri: *const c_char, protocol: *const c_char) -> gboolean;
    pub fn gst_uri_is_valid(uri: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_uri_join_strings(base_uri: *const c_char, ref_uri: *const c_char) -> *mut c_char;
    pub fn gst_uri_protocol_is_supported(type_: GstURIType, protocol: *const c_char) -> gboolean;
    pub fn gst_uri_protocol_is_valid(protocol: *const c_char) -> gboolean;

    //=========================================================================
    // GstAllocator
    //=========================================================================
    pub fn gst_allocator_get_type() -> GType;
    pub fn gst_allocator_find(name: *const c_char) -> *mut GstAllocator;
    pub fn gst_allocator_register(name: *const c_char, allocator: *mut GstAllocator);
    pub fn gst_allocator_alloc(allocator: *mut GstAllocator, size: size_t, params: *mut GstAllocationParams) -> *mut GstMemory;
    pub fn gst_allocator_free(allocator: *mut GstAllocator, memory: *mut GstMemory);
    pub fn gst_allocator_set_default(allocator: *mut GstAllocator);

    //=========================================================================
    // GstBin
    //=========================================================================
    pub fn gst_bin_get_type() -> GType;
    pub fn gst_bin_new(name: *const c_char) -> *mut GstElement;
    pub fn gst_bin_add(bin: *mut GstBin, element: *mut GstElement) -> gboolean;
    pub fn gst_bin_add_many(bin: *mut GstBin, element_1: *mut GstElement, ...);
    pub fn gst_bin_find_unlinked_pad(bin: *mut GstBin, direction: GstPadDirection) -> *mut GstPad;
    pub fn gst_bin_get_by_interface(bin: *mut GstBin, iface: GType) -> *mut GstElement;
    pub fn gst_bin_get_by_name(bin: *mut GstBin, name: *const c_char) -> *mut GstElement;
    pub fn gst_bin_get_by_name_recurse_up(bin: *mut GstBin, name: *const c_char) -> *mut GstElement;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_bin_get_suppressed_flags(bin: *mut GstBin) -> GstElementFlags;
    pub fn gst_bin_iterate_all_by_interface(bin: *mut GstBin, iface: GType) -> *mut GstIterator;
    pub fn gst_bin_iterate_elements(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_recurse(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sinks(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sorted(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_iterate_sources(bin: *mut GstBin) -> *mut GstIterator;
    pub fn gst_bin_recalculate_latency(bin: *mut GstBin) -> gboolean;
    pub fn gst_bin_remove(bin: *mut GstBin, element: *mut GstElement) -> gboolean;
    pub fn gst_bin_remove_many(bin: *mut GstBin, element_1: *mut GstElement, ...);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_bin_set_suppressed_flags(bin: *mut GstBin, flags: GstElementFlags);
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_bin_sync_children_states(bin: *mut GstBin) -> gboolean;

    //=========================================================================
    // GstBitmask
    //=========================================================================
    pub fn gst_bitmask_get_type() -> GType;

    //=========================================================================
    // GstBufferPool
    //=========================================================================
    pub fn gst_buffer_pool_get_type() -> GType;
    pub fn gst_buffer_pool_new() -> *mut GstBufferPool;
    pub fn gst_buffer_pool_config_add_option(config: *mut GstStructure, option: *const c_char);
    pub fn gst_buffer_pool_config_get_allocator(config: *mut GstStructure, allocator: *mut *mut GstAllocator, params: *mut GstAllocationParams) -> gboolean;
    pub fn gst_buffer_pool_config_get_option(config: *mut GstStructure, index: c_uint) -> *const c_char;
    pub fn gst_buffer_pool_config_get_params(config: *mut GstStructure, caps: *mut *mut GstCaps, size: *mut c_uint, min_buffers: *mut c_uint, max_buffers: *mut c_uint) -> gboolean;
    pub fn gst_buffer_pool_config_has_option(config: *mut GstStructure, option: *const c_char) -> gboolean;
    pub fn gst_buffer_pool_config_n_options(config: *mut GstStructure) -> c_uint;
    pub fn gst_buffer_pool_config_set_allocator(config: *mut GstStructure, allocator: *mut GstAllocator, params: *const GstAllocationParams);
    pub fn gst_buffer_pool_config_set_params(config: *mut GstStructure, caps: *mut GstCaps, size: c_uint, min_buffers: c_uint, max_buffers: c_uint);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_buffer_pool_config_validate_params(config: *mut GstStructure, caps: *mut GstCaps, size: c_uint, min_buffers: c_uint, max_buffers: c_uint) -> gboolean;
    pub fn gst_buffer_pool_acquire_buffer(pool: *mut GstBufferPool, buffer: *mut *mut GstBuffer, params: *mut GstBufferPoolAcquireParams) -> GstFlowReturn;
    pub fn gst_buffer_pool_get_config(pool: *mut GstBufferPool) -> *mut GstStructure;
    pub fn gst_buffer_pool_get_options(pool: *mut GstBufferPool) -> *mut *mut c_char;
    pub fn gst_buffer_pool_has_option(pool: *mut GstBufferPool, option: *const c_char) -> gboolean;
    pub fn gst_buffer_pool_is_active(pool: *mut GstBufferPool) -> gboolean;
    pub fn gst_buffer_pool_release_buffer(pool: *mut GstBufferPool, buffer: *mut GstBuffer);
    pub fn gst_buffer_pool_set_active(pool: *mut GstBufferPool, active: gboolean) -> gboolean;
    pub fn gst_buffer_pool_set_config(pool: *mut GstBufferPool, config: *mut GstStructure) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_buffer_pool_set_flushing(pool: *mut GstBufferPool, flushing: gboolean);

    //=========================================================================
    // GstBus
    //=========================================================================
    pub fn gst_bus_get_type() -> GType;
    pub fn gst_bus_new() -> *mut GstBus;
    pub fn gst_bus_add_signal_watch(bus: *mut GstBus);
    pub fn gst_bus_add_signal_watch_full(bus: *mut GstBus, priority: c_int);
    pub fn gst_bus_add_watch(bus: *mut GstBus, func: GstBusFunc, user_data: gpointer) -> c_uint;
    pub fn gst_bus_add_watch_full(bus: *mut GstBus, priority: c_int, func: GstBusFunc, user_data: gpointer, notify: glib::GDestroyNotify) -> c_uint;
    pub fn gst_bus_async_signal_func(bus: *mut GstBus, message: *mut GstMessage, data: gpointer) -> gboolean;
    pub fn gst_bus_create_watch(bus: *mut GstBus) -> *mut glib::GSource;
    pub fn gst_bus_disable_sync_message_emission(bus: *mut GstBus);
    pub fn gst_bus_enable_sync_message_emission(bus: *mut GstBus);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_bus_get_pollfd(bus: *mut GstBus, fd: *mut glib::GPollFD);
    pub fn gst_bus_have_pending(bus: *mut GstBus) -> gboolean;
    pub fn gst_bus_peek(bus: *mut GstBus) -> *mut GstMessage;
    pub fn gst_bus_poll(bus: *mut GstBus, events: GstMessageType, timeout: GstClockTime) -> *mut GstMessage;
    pub fn gst_bus_pop(bus: *mut GstBus) -> *mut GstMessage;
    pub fn gst_bus_pop_filtered(bus: *mut GstBus, types: GstMessageType) -> *mut GstMessage;
    pub fn gst_bus_post(bus: *mut GstBus, message: *mut GstMessage) -> gboolean;
    pub fn gst_bus_remove_signal_watch(bus: *mut GstBus);
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_bus_remove_watch(bus: *mut GstBus) -> gboolean;
    pub fn gst_bus_set_flushing(bus: *mut GstBus, flushing: gboolean);
    pub fn gst_bus_set_sync_handler(bus: *mut GstBus, func: GstBusSyncHandler, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_bus_sync_signal_handler(bus: *mut GstBus, message: *mut GstMessage, data: gpointer) -> GstBusSyncReply;
    pub fn gst_bus_timed_pop(bus: *mut GstBus, timeout: GstClockTime) -> *mut GstMessage;
    pub fn gst_bus_timed_pop_filtered(bus: *mut GstBus, timeout: GstClockTime, types: GstMessageType) -> *mut GstMessage;

    //=========================================================================
    // GstClock
    //=========================================================================
    pub fn gst_clock_get_type() -> GType;
    pub fn gst_clock_id_compare_func(id1: gconstpointer, id2: gconstpointer) -> c_int;
    pub fn gst_clock_id_get_time(id: GstClockID) -> GstClockTime;
    pub fn gst_clock_id_ref(id: GstClockID) -> GstClockID;
    pub fn gst_clock_id_unref(id: GstClockID);
    pub fn gst_clock_id_unschedule(id: GstClockID);
    pub fn gst_clock_id_wait(id: GstClockID, jitter: *mut GstClockTimeDiff) -> GstClockReturn;
    pub fn gst_clock_id_wait_async(id: GstClockID, func: GstClockCallback, user_data: gpointer, destroy_data: glib::GDestroyNotify) -> GstClockReturn;
    pub fn gst_clock_add_observation(clock: *mut GstClock, slave: GstClockTime, master: GstClockTime, r_squared: *mut c_double) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_clock_add_observation_unapplied(clock: *mut GstClock, slave: GstClockTime, master: GstClockTime, r_squared: *mut c_double, internal: *mut GstClockTime, external: *mut GstClockTime, rate_num: *mut GstClockTime, rate_denom: *mut GstClockTime) -> gboolean;
    pub fn gst_clock_adjust_unlocked(clock: *mut GstClock, internal: GstClockTime) -> GstClockTime;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_clock_adjust_with_calibration(clock: *mut GstClock, internal_target: GstClockTime, cinternal: GstClockTime, cexternal: GstClockTime, cnum: GstClockTime, cdenom: GstClockTime) -> GstClockTime;
    pub fn gst_clock_get_calibration(clock: *mut GstClock, internal: *mut GstClockTime, external: *mut GstClockTime, rate_num: *mut GstClockTime, rate_denom: *mut GstClockTime);
    pub fn gst_clock_get_internal_time(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_master(clock: *mut GstClock) -> *mut GstClock;
    pub fn gst_clock_get_resolution(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_time(clock: *mut GstClock) -> GstClockTime;
    pub fn gst_clock_get_timeout(clock: *mut GstClock) -> GstClockTime;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_clock_is_synced(clock: *mut GstClock) -> gboolean;
    pub fn gst_clock_new_periodic_id(clock: *mut GstClock, start_time: GstClockTime, interval: GstClockTime) -> GstClockID;
    pub fn gst_clock_new_single_shot_id(clock: *mut GstClock, time: GstClockTime) -> GstClockID;
    pub fn gst_clock_periodic_id_reinit(clock: *mut GstClock, id: GstClockID, start_time: GstClockTime, interval: GstClockTime) -> gboolean;
    pub fn gst_clock_set_calibration(clock: *mut GstClock, internal: GstClockTime, external: GstClockTime, rate_num: GstClockTime, rate_denom: GstClockTime);
    pub fn gst_clock_set_master(clock: *mut GstClock, master: *mut GstClock) -> gboolean;
    pub fn gst_clock_set_resolution(clock: *mut GstClock, resolution: GstClockTime) -> GstClockTime;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_clock_set_synced(clock: *mut GstClock, synced: gboolean);
    pub fn gst_clock_set_timeout(clock: *mut GstClock, timeout: GstClockTime);
    pub fn gst_clock_single_shot_id_reinit(clock: *mut GstClock, id: GstClockID, time: GstClockTime) -> gboolean;
    pub fn gst_clock_unadjust_unlocked(clock: *mut GstClock, external: GstClockTime) -> GstClockTime;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_clock_unadjust_with_calibration(clock: *mut GstClock, external_target: GstClockTime, cinternal: GstClockTime, cexternal: GstClockTime, cnum: GstClockTime, cdenom: GstClockTime) -> GstClockTime;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_clock_wait_for_sync(clock: *mut GstClock, timeout: GstClockTime) -> gboolean;

    //=========================================================================
    // GstControlBinding
    //=========================================================================
    pub fn gst_control_binding_get_type() -> GType;
    pub fn gst_control_binding_get_g_value_array(binding: *mut GstControlBinding, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: *mut gobject::GValue) -> gboolean;
    pub fn gst_control_binding_get_value(binding: *mut GstControlBinding, timestamp: GstClockTime) -> *mut gobject::GValue;
    pub fn gst_control_binding_get_value_array(binding: *mut GstControlBinding, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: gpointer) -> gboolean;
    pub fn gst_control_binding_is_disabled(binding: *mut GstControlBinding) -> gboolean;
    pub fn gst_control_binding_set_disabled(binding: *mut GstControlBinding, disabled: gboolean);
    pub fn gst_control_binding_sync_values(binding: *mut GstControlBinding, object: *mut GstObject, timestamp: GstClockTime, last_sync: GstClockTime) -> gboolean;

    //=========================================================================
    // GstControlSource
    //=========================================================================
    pub fn gst_control_source_get_type() -> GType;
    pub fn gst_control_source_get_value(self_: *mut GstControlSource, timestamp: GstClockTime, value: *mut c_double) -> gboolean;
    pub fn gst_control_source_get_value_array(self_: *mut GstControlSource, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: *mut c_double) -> gboolean;

    //=========================================================================
    // GstDevice
    //=========================================================================
    pub fn gst_device_get_type() -> GType;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_create_element(device: *mut GstDevice, name: *const c_char) -> *mut GstElement;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_get_caps(device: *mut GstDevice) -> *mut GstCaps;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_get_device_class(device: *mut GstDevice) -> *mut c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_get_display_name(device: *mut GstDevice) -> *mut c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_device_get_properties(device: *mut GstDevice) -> *mut GstStructure;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_has_classes(device: *mut GstDevice, classes: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_has_classesv(device: *mut GstDevice, classes: *mut *mut c_char) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_reconfigure_element(device: *mut GstDevice, element: *mut GstElement) -> gboolean;

    //=========================================================================
    // GstDeviceMonitor
    //=========================================================================
    pub fn gst_device_monitor_get_type() -> GType;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_monitor_new() -> *mut GstDeviceMonitor;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_monitor_add_filter(monitor: *mut GstDeviceMonitor, classes: *const c_char, caps: *mut GstCaps) -> c_uint;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_monitor_get_bus(monitor: *mut GstDeviceMonitor) -> *mut GstBus;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_monitor_get_devices(monitor: *mut GstDeviceMonitor) -> *mut glib::GList;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_device_monitor_get_providers(monitor: *mut GstDeviceMonitor) -> *mut *mut c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_device_monitor_get_show_all_devices(monitor: *mut GstDeviceMonitor) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_monitor_remove_filter(monitor: *mut GstDeviceMonitor, filter_id: c_uint) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_device_monitor_set_show_all_devices(monitor: *mut GstDeviceMonitor, show_all: gboolean);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_monitor_start(monitor: *mut GstDeviceMonitor) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_monitor_stop(monitor: *mut GstDeviceMonitor);

    //=========================================================================
    // GstDeviceProvider
    //=========================================================================
    pub fn gst_device_provider_get_type() -> GType;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_register(plugin: *mut GstPlugin, name: *const c_char, rank: c_uint, type_: GType) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_can_monitor(provider: *mut GstDeviceProvider) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_device_add(provider: *mut GstDeviceProvider, device: *mut GstDevice);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_device_remove(provider: *mut GstDeviceProvider, device: *mut GstDevice);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_get_bus(provider: *mut GstDeviceProvider) -> *mut GstBus;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_get_devices(provider: *mut GstDeviceProvider) -> *mut glib::GList;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_get_factory(provider: *mut GstDeviceProvider) -> *mut GstDeviceProviderFactory;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_device_provider_get_hidden_providers(provider: *mut GstDeviceProvider) -> *mut *mut c_char;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_device_provider_get_metadata(provider: *mut GstDeviceProvider, key: *const c_char) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_device_provider_hide_provider(provider: *mut GstDeviceProvider, name: *const c_char);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_start(provider: *mut GstDeviceProvider) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_stop(provider: *mut GstDeviceProvider);
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_device_provider_unhide_provider(provider: *mut GstDeviceProvider, name: *const c_char);

    //=========================================================================
    // GstDeviceProviderFactory
    //=========================================================================
    pub fn gst_device_provider_factory_get_type() -> GType;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_factory_find(name: *const c_char) -> *mut GstDeviceProviderFactory;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_factory_get_by_name(factoryname: *const c_char) -> *mut GstDeviceProvider;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_factory_list_get_device_providers(minrank: GstRank) -> *mut glib::GList;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_factory_get(factory: *mut GstDeviceProviderFactory) -> *mut GstDeviceProvider;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_factory_get_device_provider_type(factory: *mut GstDeviceProviderFactory) -> GType;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_factory_get_metadata(factory: *mut GstDeviceProviderFactory, key: *const c_char) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_factory_get_metadata_keys(factory: *mut GstDeviceProviderFactory) -> *mut *mut c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_factory_has_classes(factory: *mut GstDeviceProviderFactory, classes: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_device_provider_factory_has_classesv(factory: *mut GstDeviceProviderFactory, classes: *mut *mut c_char) -> gboolean;

    //=========================================================================
    // GstDoubleRange
    //=========================================================================
    pub fn gst_double_range_get_type() -> GType;

    //=========================================================================
    // GstDynamicTypeFactory
    //=========================================================================
    pub fn gst_dynamic_type_factory_get_type() -> GType;
    pub fn gst_dynamic_type_factory_load(factoryname: *const c_char) -> GType;

    //=========================================================================
    // GstElement
    //=========================================================================
    pub fn gst_element_get_type() -> GType;
    pub fn gst_element_make_from_uri(type_: GstURIType, uri: *const c_char, elementname: *const c_char, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_element_register(plugin: *mut GstPlugin, name: *const c_char, rank: c_uint, type_: GType) -> gboolean;
    pub fn gst_element_state_change_return_get_name(state_ret: GstStateChangeReturn) -> *const c_char;
    pub fn gst_element_state_get_name(state: GstState) -> *const c_char;
    pub fn gst_element_abort_state(element: *mut GstElement);
    pub fn gst_element_add_pad(element: *mut GstElement, pad: *mut GstPad) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_element_add_property_deep_notify_watch(element: *mut GstElement, property_name: *const c_char, include_value: gboolean) -> c_ulong;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_element_add_property_notify_watch(element: *mut GstElement, property_name: *const c_char, include_value: gboolean) -> c_ulong;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_element_call_async(element: *mut GstElement, func: GstElementCallAsyncFunc, user_data: gpointer, destroy_notify: glib::GDestroyNotify);
    pub fn gst_element_change_state(element: *mut GstElement, transition: GstStateChange) -> GstStateChangeReturn;
    pub fn gst_element_continue_state(element: *mut GstElement, ret: GstStateChangeReturn) -> GstStateChangeReturn;
    pub fn gst_element_create_all_pads(element: *mut GstElement);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_element_foreach_pad(element: *mut GstElement, func: GstElementForeachPadFunc, user_data: gpointer) -> gboolean;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_element_foreach_sink_pad(element: *mut GstElement, func: GstElementForeachPadFunc, user_data: gpointer) -> gboolean;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_element_foreach_src_pad(element: *mut GstElement, func: GstElementForeachPadFunc, user_data: gpointer) -> gboolean;
    pub fn gst_element_get_base_time(element: *mut GstElement) -> GstClockTime;
    pub fn gst_element_get_bus(element: *mut GstElement) -> *mut GstBus;
    pub fn gst_element_get_clock(element: *mut GstElement) -> *mut GstClock;
    pub fn gst_element_get_compatible_pad(element: *mut GstElement, pad: *mut GstPad, caps: *mut GstCaps) -> *mut GstPad;
    pub fn gst_element_get_compatible_pad_template(element: *mut GstElement, compattempl: *mut GstPadTemplate) -> *mut GstPadTemplate;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_element_get_context(element: *mut GstElement, context_type: *const c_char) -> *mut GstContext;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_element_get_context_unlocked(element: *mut GstElement, context_type: *const c_char) -> *mut GstContext;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_element_get_contexts(element: *mut GstElement) -> *mut glib::GList;
    pub fn gst_element_get_factory(element: *mut GstElement) -> *mut GstElementFactory;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_element_get_metadata(element: *mut GstElement, key: *const c_char) -> *const c_char;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_element_get_pad_template(element: *mut GstElement, name: *const c_char) -> *mut GstPadTemplate;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_element_get_pad_template_list(element: *mut GstElement) -> *mut glib::GList;
    pub fn gst_element_get_request_pad(element: *mut GstElement, name: *const c_char) -> *mut GstPad;
    pub fn gst_element_get_start_time(element: *mut GstElement) -> GstClockTime;
    pub fn gst_element_get_state(element: *mut GstElement, state: *mut GstState, pending: *mut GstState, timeout: GstClockTime) -> GstStateChangeReturn;
    pub fn gst_element_get_static_pad(element: *mut GstElement, name: *const c_char) -> *mut GstPad;
    pub fn gst_element_is_locked_state(element: *mut GstElement) -> gboolean;
    pub fn gst_element_iterate_pads(element: *mut GstElement) -> *mut GstIterator;
    pub fn gst_element_iterate_sink_pads(element: *mut GstElement) -> *mut GstIterator;
    pub fn gst_element_iterate_src_pads(element: *mut GstElement) -> *mut GstIterator;
    pub fn gst_element_link(src: *mut GstElement, dest: *mut GstElement) -> gboolean;
    pub fn gst_element_link_filtered(src: *mut GstElement, dest: *mut GstElement, filter: *mut GstCaps) -> gboolean;
    pub fn gst_element_link_many(element_1: *mut GstElement, element_2: *mut GstElement, ...) -> gboolean;
    pub fn gst_element_link_pads(src: *mut GstElement, srcpadname: *const c_char, dest: *mut GstElement, destpadname: *const c_char) -> gboolean;
    pub fn gst_element_link_pads_filtered(src: *mut GstElement, srcpadname: *const c_char, dest: *mut GstElement, destpadname: *const c_char, filter: *mut GstCaps) -> gboolean;
    pub fn gst_element_link_pads_full(src: *mut GstElement, srcpadname: *const c_char, dest: *mut GstElement, destpadname: *const c_char, flags: GstPadLinkCheck) -> gboolean;
    pub fn gst_element_lost_state(element: *mut GstElement);
    pub fn gst_element_message_full(element: *mut GstElement, type_: GstMessageType, domain: glib::GQuark, code: c_int, text: *mut c_char, debug: *mut c_char, file: *const c_char, function: *const c_char, line: c_int);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_element_message_full_with_details(element: *mut GstElement, type_: GstMessageType, domain: glib::GQuark, code: c_int, text: *mut c_char, debug: *mut c_char, file: *const c_char, function: *const c_char, line: c_int, structure: *mut GstStructure);
    pub fn gst_element_no_more_pads(element: *mut GstElement);
    pub fn gst_element_post_message(element: *mut GstElement, message: *mut GstMessage) -> gboolean;
    pub fn gst_element_provide_clock(element: *mut GstElement) -> *mut GstClock;
    pub fn gst_element_query(element: *mut GstElement, query: *mut GstQuery) -> gboolean;
    pub fn gst_element_query_convert(element: *mut GstElement, src_format: GstFormat, src_val: i64, dest_format: GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_element_query_duration(element: *mut GstElement, format: GstFormat, duration: *mut i64) -> gboolean;
    pub fn gst_element_query_position(element: *mut GstElement, format: GstFormat, cur: *mut i64) -> gboolean;
    pub fn gst_element_release_request_pad(element: *mut GstElement, pad: *mut GstPad);
    pub fn gst_element_remove_pad(element: *mut GstElement, pad: *mut GstPad) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_element_remove_property_notify_watch(element: *mut GstElement, watch_id: c_ulong);
    pub fn gst_element_request_pad(element: *mut GstElement, templ: *mut GstPadTemplate, name: *const c_char, caps: *const GstCaps) -> *mut GstPad;
    pub fn gst_element_seek(element: *mut GstElement, rate: c_double, format: GstFormat, flags: GstSeekFlags, start_type: GstSeekType, start: i64, stop_type: GstSeekType, stop: i64) -> gboolean;
    pub fn gst_element_seek_simple(element: *mut GstElement, format: GstFormat, seek_flags: GstSeekFlags, seek_pos: i64) -> gboolean;
    pub fn gst_element_send_event(element: *mut GstElement, event: *mut GstEvent) -> gboolean;
    pub fn gst_element_set_base_time(element: *mut GstElement, time: GstClockTime);
    pub fn gst_element_set_bus(element: *mut GstElement, bus: *mut GstBus);
    pub fn gst_element_set_clock(element: *mut GstElement, clock: *mut GstClock) -> gboolean;
    pub fn gst_element_set_context(element: *mut GstElement, context: *mut GstContext);
    pub fn gst_element_set_locked_state(element: *mut GstElement, locked_state: gboolean) -> gboolean;
    pub fn gst_element_set_start_time(element: *mut GstElement, time: GstClockTime);
    pub fn gst_element_set_state(element: *mut GstElement, state: GstState) -> GstStateChangeReturn;
    pub fn gst_element_sync_state_with_parent(element: *mut GstElement) -> gboolean;
    pub fn gst_element_unlink(src: *mut GstElement, dest: *mut GstElement);
    pub fn gst_element_unlink_many(element_1: *mut GstElement, element_2: *mut GstElement, ...);
    pub fn gst_element_unlink_pads(src: *mut GstElement, srcpadname: *const c_char, dest: *mut GstElement, destpadname: *const c_char);

    //=========================================================================
    // GstElementFactory
    //=========================================================================
    pub fn gst_element_factory_get_type() -> GType;
    pub fn gst_element_factory_find(name: *const c_char) -> *mut GstElementFactory;
    pub fn gst_element_factory_list_filter(list: *mut glib::GList, caps: *const GstCaps, direction: GstPadDirection, subsetonly: gboolean) -> *mut glib::GList;
    pub fn gst_element_factory_list_get_elements(type_: GstElementFactoryListType, minrank: GstRank) -> *mut glib::GList;
    pub fn gst_element_factory_make(factoryname: *const c_char, name: *const c_char) -> *mut GstElement;
    pub fn gst_element_factory_can_sink_all_caps(factory: *mut GstElementFactory, caps: *const GstCaps) -> gboolean;
    pub fn gst_element_factory_can_sink_any_caps(factory: *mut GstElementFactory, caps: *const GstCaps) -> gboolean;
    pub fn gst_element_factory_can_src_all_caps(factory: *mut GstElementFactory, caps: *const GstCaps) -> gboolean;
    pub fn gst_element_factory_can_src_any_caps(factory: *mut GstElementFactory, caps: *const GstCaps) -> gboolean;
    pub fn gst_element_factory_create(factory: *mut GstElementFactory, name: *const c_char) -> *mut GstElement;
    pub fn gst_element_factory_get_element_type(factory: *mut GstElementFactory) -> GType;
    pub fn gst_element_factory_get_metadata(factory: *mut GstElementFactory, key: *const c_char) -> *const c_char;
    pub fn gst_element_factory_get_metadata_keys(factory: *mut GstElementFactory) -> *mut *mut c_char;
    pub fn gst_element_factory_get_num_pad_templates(factory: *mut GstElementFactory) -> c_uint;
    pub fn gst_element_factory_get_static_pad_templates(factory: *mut GstElementFactory) -> *const glib::GList;
    pub fn gst_element_factory_get_uri_protocols(factory: *mut GstElementFactory) -> *mut *mut c_char;
    pub fn gst_element_factory_get_uri_type(factory: *mut GstElementFactory) -> GstURIType;
    pub fn gst_element_factory_has_interface(factory: *mut GstElementFactory, interfacename: *const c_char) -> gboolean;
    pub fn gst_element_factory_list_is_type(factory: *mut GstElementFactory, type_: GstElementFactoryListType) -> gboolean;

    //=========================================================================
    // GstFlagSet
    //=========================================================================
    pub fn gst_flagset_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_flagset_register(flags_type: GType) -> GType;

    //=========================================================================
    // GstFraction
    //=========================================================================
    pub fn gst_fraction_get_type() -> GType;

    //=========================================================================
    // GstFractionRange
    //=========================================================================
    pub fn gst_fraction_range_get_type() -> GType;

    //=========================================================================
    // GstGhostPad
    //=========================================================================
    pub fn gst_ghost_pad_get_type() -> GType;
    pub fn gst_ghost_pad_new(name: *const c_char, target: *mut GstPad) -> *mut GstPad;
    pub fn gst_ghost_pad_new_from_template(name: *const c_char, target: *mut GstPad, templ: *mut GstPadTemplate) -> *mut GstPad;
    pub fn gst_ghost_pad_new_no_target(name: *const c_char, dir: GstPadDirection) -> *mut GstPad;
    pub fn gst_ghost_pad_new_no_target_from_template(name: *const c_char, templ: *mut GstPadTemplate) -> *mut GstPad;
    pub fn gst_ghost_pad_activate_mode_default(pad: *mut GstPad, parent: *mut GstObject, mode: GstPadMode, active: gboolean) -> gboolean;
    pub fn gst_ghost_pad_internal_activate_mode_default(pad: *mut GstPad, parent: *mut GstObject, mode: GstPadMode, active: gboolean) -> gboolean;
    pub fn gst_ghost_pad_construct(gpad: *mut GstGhostPad) -> gboolean;
    pub fn gst_ghost_pad_get_target(gpad: *mut GstGhostPad) -> *mut GstPad;
    pub fn gst_ghost_pad_set_target(gpad: *mut GstGhostPad, newtarget: *mut GstPad) -> gboolean;

    //=========================================================================
    // GstInt64Range
    //=========================================================================
    pub fn gst_int64_range_get_type() -> GType;

    //=========================================================================
    // GstIntRange
    //=========================================================================
    pub fn gst_int_range_get_type() -> GType;

    //=========================================================================
    // GstObject
    //=========================================================================
    pub fn gst_object_get_type() -> GType;
    pub fn gst_object_check_uniqueness(list: *mut glib::GList, name: *const c_char) -> gboolean;
    pub fn gst_object_default_deep_notify(object: *mut gobject::GObject, orig: *mut GstObject, pspec: *mut gobject::GParamSpec, excluded_props: *mut *mut c_char);
    pub fn gst_object_ref_sink(object: gpointer) -> gpointer;
    pub fn gst_object_replace(oldobj: *mut *mut GstObject, newobj: *mut GstObject) -> gboolean;
    pub fn gst_object_add_control_binding(object: *mut GstObject, binding: *mut GstControlBinding) -> gboolean;
    pub fn gst_object_default_error(source: *mut GstObject, error: *const glib::GError, debug: *const c_char);
    pub fn gst_object_get_control_binding(object: *mut GstObject, property_name: *const c_char) -> *mut GstControlBinding;
    pub fn gst_object_get_control_rate(object: *mut GstObject) -> GstClockTime;
    pub fn gst_object_get_g_value_array(object: *mut GstObject, property_name: *const c_char, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: *mut gobject::GValue) -> gboolean;
    pub fn gst_object_get_name(object: *mut GstObject) -> *mut c_char;
    pub fn gst_object_get_parent(object: *mut GstObject) -> *mut GstObject;
    pub fn gst_object_get_path_string(object: *mut GstObject) -> *mut c_char;
    pub fn gst_object_get_value(object: *mut GstObject, property_name: *const c_char, timestamp: GstClockTime) -> *mut gobject::GValue;
    pub fn gst_object_get_value_array(object: *mut GstObject, property_name: *const c_char, timestamp: GstClockTime, interval: GstClockTime, n_values: c_uint, values: gpointer) -> gboolean;
    pub fn gst_object_has_active_control_bindings(object: *mut GstObject) -> gboolean;
    pub fn gst_object_has_ancestor(object: *mut GstObject, ancestor: *mut GstObject) -> gboolean;
    pub fn gst_object_has_as_ancestor(object: *mut GstObject, ancestor: *mut GstObject) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_object_has_as_parent(object: *mut GstObject, parent: *mut GstObject) -> gboolean;
    pub fn gst_object_ref(object: *mut GstObject) -> *mut GstObject;
    pub fn gst_object_remove_control_binding(object: *mut GstObject, binding: *mut GstControlBinding) -> gboolean;
    pub fn gst_object_set_control_binding_disabled(object: *mut GstObject, property_name: *const c_char, disabled: gboolean);
    pub fn gst_object_set_control_bindings_disabled(object: *mut GstObject, disabled: gboolean);
    pub fn gst_object_set_control_rate(object: *mut GstObject, control_rate: GstClockTime);
    pub fn gst_object_set_name(object: *mut GstObject, name: *const c_char) -> gboolean;
    pub fn gst_object_set_parent(object: *mut GstObject, parent: *mut GstObject) -> gboolean;
    pub fn gst_object_suggest_next_sync(object: *mut GstObject) -> GstClockTime;
    pub fn gst_object_sync_values(object: *mut GstObject, timestamp: GstClockTime) -> gboolean;
    pub fn gst_object_unparent(object: *mut GstObject);
    pub fn gst_object_unref(object: *mut GstObject);

    //=========================================================================
    // GstPad
    //=========================================================================
    pub fn gst_pad_get_type() -> GType;
    pub fn gst_pad_new(name: *const c_char, direction: GstPadDirection) -> *mut GstPad;
    pub fn gst_pad_new_from_static_template(templ: *mut GstStaticPadTemplate, name: *const c_char) -> *mut GstPad;
    pub fn gst_pad_new_from_template(templ: *mut GstPadTemplate, name: *const c_char) -> *mut GstPad;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_pad_link_get_name(ret: GstPadLinkReturn) -> *const c_char;
    pub fn gst_pad_activate_mode(pad: *mut GstPad, mode: GstPadMode, active: gboolean) -> gboolean;
    pub fn gst_pad_add_probe(pad: *mut GstPad, mask: GstPadProbeType, callback: GstPadProbeCallback, user_data: gpointer, destroy_data: glib::GDestroyNotify) -> c_ulong;
    pub fn gst_pad_can_link(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> gboolean;
    pub fn gst_pad_chain(pad: *mut GstPad, buffer: *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_chain_list(pad: *mut GstPad, list: *mut GstBufferList) -> GstFlowReturn;
    pub fn gst_pad_check_reconfigure(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_create_stream_id(pad: *mut GstPad, parent: *mut GstElement, stream_id: *const c_char) -> *mut c_char;
    pub fn gst_pad_create_stream_id_printf(pad: *mut GstPad, parent: *mut GstElement, stream_id: *const c_char, ...) -> *mut c_char;
    //pub fn gst_pad_create_stream_id_printf_valist(pad: *mut GstPad, parent: *mut GstElement, stream_id: *const c_char, var_args: /*Unimplemented*/va_list) -> *mut c_char;
    pub fn gst_pad_event_default(pad: *mut GstPad, parent: *mut GstObject, event: *mut GstEvent) -> gboolean;
    pub fn gst_pad_forward(pad: *mut GstPad, forward: GstPadForwardFunction, user_data: gpointer) -> gboolean;
    pub fn gst_pad_get_allowed_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_current_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_direction(pad: *mut GstPad) -> GstPadDirection;
    pub fn gst_pad_get_element_private(pad: *mut GstPad) -> gpointer;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_pad_get_last_flow_return(pad: *mut GstPad) -> GstFlowReturn;
    pub fn gst_pad_get_offset(pad: *mut GstPad) -> i64;
    pub fn gst_pad_get_pad_template(pad: *mut GstPad) -> *mut GstPadTemplate;
    pub fn gst_pad_get_pad_template_caps(pad: *mut GstPad) -> *mut GstCaps;
    pub fn gst_pad_get_parent_element(pad: *mut GstPad) -> *mut GstElement;
    pub fn gst_pad_get_peer(pad: *mut GstPad) -> *mut GstPad;
    pub fn gst_pad_get_range(pad: *mut GstPad, offset: u64, size: c_uint, buffer: *mut *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_get_sticky_event(pad: *mut GstPad, event_type: GstEventType, idx: c_uint) -> *mut GstEvent;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_pad_get_stream(pad: *mut GstPad) -> *mut GstStream;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_pad_get_stream_id(pad: *mut GstPad) -> *mut c_char;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_pad_get_task_state(pad: *mut GstPad) -> GstTaskState;
    pub fn gst_pad_has_current_caps(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_active(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_blocked(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_blocking(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_is_linked(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_iterate_internal_links(pad: *mut GstPad) -> *mut GstIterator;
    pub fn gst_pad_iterate_internal_links_default(pad: *mut GstPad, parent: *mut GstObject) -> *mut GstIterator;
    pub fn gst_pad_link(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> GstPadLinkReturn;
    pub fn gst_pad_link_full(srcpad: *mut GstPad, sinkpad: *mut GstPad, flags: GstPadLinkCheck) -> GstPadLinkReturn;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_pad_link_maybe_ghosting(src: *mut GstPad, sink: *mut GstPad) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_pad_link_maybe_ghosting_full(src: *mut GstPad, sink: *mut GstPad, flags: GstPadLinkCheck) -> gboolean;
    pub fn gst_pad_mark_reconfigure(pad: *mut GstPad);
    pub fn gst_pad_needs_reconfigure(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_pause_task(pad: *mut GstPad) -> gboolean;
    pub fn gst_pad_peer_query(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_peer_query_accept_caps(pad: *mut GstPad, caps: *mut GstCaps) -> gboolean;
    pub fn gst_pad_peer_query_caps(pad: *mut GstPad, filter: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_pad_peer_query_convert(pad: *mut GstPad, src_format: GstFormat, src_val: i64, dest_format: GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_pad_peer_query_duration(pad: *mut GstPad, format: GstFormat, duration: *mut i64) -> gboolean;
    pub fn gst_pad_peer_query_position(pad: *mut GstPad, format: GstFormat, cur: *mut i64) -> gboolean;
    pub fn gst_pad_proxy_query_accept_caps(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_proxy_query_caps(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_pull_range(pad: *mut GstPad, offset: u64, size: c_uint, buffer: *mut *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_push(pad: *mut GstPad, buffer: *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_pad_push_event(pad: *mut GstPad, event: *mut GstEvent) -> gboolean;
    pub fn gst_pad_push_list(pad: *mut GstPad, list: *mut GstBufferList) -> GstFlowReturn;
    pub fn gst_pad_query(pad: *mut GstPad, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_query_accept_caps(pad: *mut GstPad, caps: *mut GstCaps) -> gboolean;
    pub fn gst_pad_query_caps(pad: *mut GstPad, filter: *mut GstCaps) -> *mut GstCaps;
    pub fn gst_pad_query_convert(pad: *mut GstPad, src_format: GstFormat, src_val: i64, dest_format: GstFormat, dest_val: *mut i64) -> gboolean;
    pub fn gst_pad_query_default(pad: *mut GstPad, parent: *mut GstObject, query: *mut GstQuery) -> gboolean;
    pub fn gst_pad_query_duration(pad: *mut GstPad, format: GstFormat, duration: *mut i64) -> gboolean;
    pub fn gst_pad_query_position(pad: *mut GstPad, format: GstFormat, cur: *mut i64) -> gboolean;
    pub fn gst_pad_remove_probe(pad: *mut GstPad, id: c_ulong);
    pub fn gst_pad_send_event(pad: *mut GstPad, event: *mut GstEvent) -> gboolean;
    pub fn gst_pad_set_activate_function_full(pad: *mut GstPad, activate: GstPadActivateFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_activatemode_function_full(pad: *mut GstPad, activatemode: GstPadActivateModeFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_active(pad: *mut GstPad, active: gboolean) -> gboolean;
    pub fn gst_pad_set_chain_function_full(pad: *mut GstPad, chain: GstPadChainFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_chain_list_function_full(pad: *mut GstPad, chainlist: GstPadChainListFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_element_private(pad: *mut GstPad, priv_: gpointer);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_pad_set_event_full_function_full(pad: *mut GstPad, event: GstPadEventFullFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_event_function_full(pad: *mut GstPad, event: GstPadEventFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_getrange_function_full(pad: *mut GstPad, get: GstPadGetRangeFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_iterate_internal_links_function_full(pad: *mut GstPad, iterintlink: GstPadIterIntLinkFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_link_function_full(pad: *mut GstPad, link: GstPadLinkFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_offset(pad: *mut GstPad, offset: i64);
    pub fn gst_pad_set_query_function_full(pad: *mut GstPad, query: GstPadQueryFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_set_unlink_function_full(pad: *mut GstPad, unlink: GstPadUnlinkFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_pad_start_task(pad: *mut GstPad, func: GstTaskFunction, user_data: gpointer, notify: glib::GDestroyNotify) -> gboolean;
    pub fn gst_pad_sticky_events_foreach(pad: *mut GstPad, foreach_func: GstPadStickyEventsForeachFunction, user_data: gpointer);
    pub fn gst_pad_stop_task(pad: *mut GstPad) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_pad_store_sticky_event(pad: *mut GstPad, event: *mut GstEvent) -> GstFlowReturn;
    pub fn gst_pad_unlink(srcpad: *mut GstPad, sinkpad: *mut GstPad) -> gboolean;
    pub fn gst_pad_use_fixed_caps(pad: *mut GstPad);

    //=========================================================================
    // GstPadTemplate
    //=========================================================================
    pub fn gst_pad_template_get_type() -> GType;
    pub fn gst_pad_template_new(name_template: *const c_char, direction: GstPadDirection, presence: GstPadPresence, caps: *mut GstCaps) -> *mut GstPadTemplate;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_pad_template_new_from_static_pad_template_with_gtype(pad_template: *mut GstStaticPadTemplate, pad_type: GType) -> *mut GstPadTemplate;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_pad_template_new_with_gtype(name_template: *const c_char, direction: GstPadDirection, presence: GstPadPresence, caps: *mut GstCaps, pad_type: GType) -> *mut GstPadTemplate;
    pub fn gst_pad_template_get_caps(templ: *mut GstPadTemplate) -> *mut GstCaps;
    pub fn gst_pad_template_pad_created(templ: *mut GstPadTemplate, pad: *mut GstPad);

    //=========================================================================
    // GstParamArray
    //=========================================================================
    pub fn gst_param_spec_array_get_type() -> GType;

    //=========================================================================
    // GstParamFraction
    //=========================================================================
    pub fn gst_param_spec_fraction_get_type() -> GType;

    //=========================================================================
    // GstPipeline
    //=========================================================================
    pub fn gst_pipeline_get_type() -> GType;
    pub fn gst_pipeline_new(name: *const c_char) -> *mut GstElement;
    pub fn gst_pipeline_auto_clock(pipeline: *mut GstPipeline);
    pub fn gst_pipeline_get_auto_flush_bus(pipeline: *mut GstPipeline) -> gboolean;
    pub fn gst_pipeline_get_bus(pipeline: *mut GstPipeline) -> *mut GstBus;
    pub fn gst_pipeline_get_clock(pipeline: *mut GstPipeline) -> *mut GstClock;
    pub fn gst_pipeline_get_delay(pipeline: *mut GstPipeline) -> GstClockTime;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_pipeline_get_latency(pipeline: *mut GstPipeline) -> GstClockTime;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_pipeline_get_pipeline_clock(pipeline: *mut GstPipeline) -> *mut GstClock;
    pub fn gst_pipeline_set_auto_flush_bus(pipeline: *mut GstPipeline, auto_flush: gboolean);
    pub fn gst_pipeline_set_clock(pipeline: *mut GstPipeline, clock: *mut GstClock) -> gboolean;
    pub fn gst_pipeline_set_delay(pipeline: *mut GstPipeline, delay: GstClockTime);
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_pipeline_set_latency(pipeline: *mut GstPipeline, latency: GstClockTime);
    pub fn gst_pipeline_use_clock(pipeline: *mut GstPipeline, clock: *mut GstClock);

    //=========================================================================
    // GstPlugin
    //=========================================================================
    pub fn gst_plugin_get_type() -> GType;
    pub fn gst_plugin_list_free(list: *mut glib::GList);
    pub fn gst_plugin_load_by_name(name: *const c_char) -> *mut GstPlugin;
    pub fn gst_plugin_load_file(filename: *const c_char, error: *mut *mut glib::GError) -> *mut GstPlugin;
    pub fn gst_plugin_register_static(major_version: c_int, minor_version: c_int, name: *const c_char, description: *const c_char, init_func: GstPluginInitFunc, version: *const c_char, license: *const c_char, source: *const c_char, package: *const c_char, origin: *const c_char) -> gboolean;
    pub fn gst_plugin_register_static_full(major_version: c_int, minor_version: c_int, name: *const c_char, description: *const c_char, init_full_func: GstPluginInitFullFunc, version: *const c_char, license: *const c_char, source: *const c_char, package: *const c_char, origin: *const c_char, user_data: gpointer) -> gboolean;
    pub fn gst_plugin_add_dependency(plugin: *mut GstPlugin, env_vars: *mut *mut c_char, paths: *mut *mut c_char, names: *mut *mut c_char, flags: GstPluginDependencyFlags);
    pub fn gst_plugin_add_dependency_simple(plugin: *mut GstPlugin, env_vars: *const c_char, paths: *const c_char, names: *const c_char, flags: GstPluginDependencyFlags);
    pub fn gst_plugin_get_cache_data(plugin: *mut GstPlugin) -> *const GstStructure;
    pub fn gst_plugin_get_description(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_filename(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_license(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_name(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_origin(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_package(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_release_date_string(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_source(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_get_version(plugin: *mut GstPlugin) -> *const c_char;
    pub fn gst_plugin_is_loaded(plugin: *mut GstPlugin) -> gboolean;
    pub fn gst_plugin_load(plugin: *mut GstPlugin) -> *mut GstPlugin;
    pub fn gst_plugin_set_cache_data(plugin: *mut GstPlugin, cache_data: *mut GstStructure);

    //=========================================================================
    // GstPluginFeature
    //=========================================================================
    pub fn gst_plugin_feature_get_type() -> GType;
    pub fn gst_plugin_feature_list_copy(list: *mut glib::GList) -> *mut glib::GList;
    pub fn gst_plugin_feature_list_debug(list: *mut glib::GList);
    pub fn gst_plugin_feature_list_free(list: *mut glib::GList);
    pub fn gst_plugin_feature_rank_compare_func(p1: gconstpointer, p2: gconstpointer) -> c_int;
    pub fn gst_plugin_feature_check_version(feature: *mut GstPluginFeature, min_major: c_uint, min_minor: c_uint, min_micro: c_uint) -> gboolean;
    pub fn gst_plugin_feature_get_plugin(feature: *mut GstPluginFeature) -> *mut GstPlugin;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_plugin_feature_get_plugin_name(feature: *mut GstPluginFeature) -> *const c_char;
    pub fn gst_plugin_feature_get_rank(feature: *mut GstPluginFeature) -> c_uint;
    pub fn gst_plugin_feature_load(feature: *mut GstPluginFeature) -> *mut GstPluginFeature;
    pub fn gst_plugin_feature_set_rank(feature: *mut GstPluginFeature, rank: c_uint);

    //=========================================================================
    // GstProxyPad
    //=========================================================================
    pub fn gst_proxy_pad_get_type() -> GType;
    pub fn gst_proxy_pad_chain_default(pad: *mut GstPad, parent: *mut GstObject, buffer: *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_proxy_pad_chain_list_default(pad: *mut GstPad, parent: *mut GstObject, list: *mut GstBufferList) -> GstFlowReturn;
    pub fn gst_proxy_pad_getrange_default(pad: *mut GstPad, parent: *mut GstObject, offset: u64, size: c_uint, buffer: *mut *mut GstBuffer) -> GstFlowReturn;
    pub fn gst_proxy_pad_iterate_internal_links_default(pad: *mut GstPad, parent: *mut GstObject) -> *mut GstIterator;
    pub fn gst_proxy_pad_get_internal(pad: *mut GstProxyPad) -> *mut GstProxyPad;

    //=========================================================================
    // GstRegistry
    //=========================================================================
    pub fn gst_registry_get_type() -> GType;
    pub fn gst_registry_fork_is_enabled() -> gboolean;
    pub fn gst_registry_fork_set_enabled(enabled: gboolean);
    pub fn gst_registry_get() -> *mut GstRegistry;
    pub fn gst_registry_add_feature(registry: *mut GstRegistry, feature: *mut GstPluginFeature) -> gboolean;
    pub fn gst_registry_add_plugin(registry: *mut GstRegistry, plugin: *mut GstPlugin) -> gboolean;
    pub fn gst_registry_check_feature_version(registry: *mut GstRegistry, feature_name: *const c_char, min_major: c_uint, min_minor: c_uint, min_micro: c_uint) -> gboolean;
    pub fn gst_registry_feature_filter(registry: *mut GstRegistry, filter: GstPluginFeatureFilter, first: gboolean, user_data: gpointer) -> *mut glib::GList;
    pub fn gst_registry_find_feature(registry: *mut GstRegistry, name: *const c_char, type_: GType) -> *mut GstPluginFeature;
    pub fn gst_registry_find_plugin(registry: *mut GstRegistry, name: *const c_char) -> *mut GstPlugin;
    pub fn gst_registry_get_feature_list(registry: *mut GstRegistry, type_: GType) -> *mut glib::GList;
    pub fn gst_registry_get_feature_list_by_plugin(registry: *mut GstRegistry, name: *const c_char) -> *mut glib::GList;
    pub fn gst_registry_get_feature_list_cookie(registry: *mut GstRegistry) -> u32;
    pub fn gst_registry_get_plugin_list(registry: *mut GstRegistry) -> *mut glib::GList;
    pub fn gst_registry_lookup(registry: *mut GstRegistry, filename: *const c_char) -> *mut GstPlugin;
    pub fn gst_registry_lookup_feature(registry: *mut GstRegistry, name: *const c_char) -> *mut GstPluginFeature;
    pub fn gst_registry_plugin_filter(registry: *mut GstRegistry, filter: GstPluginFilter, first: gboolean, user_data: gpointer) -> *mut glib::GList;
    pub fn gst_registry_remove_feature(registry: *mut GstRegistry, feature: *mut GstPluginFeature);
    pub fn gst_registry_remove_plugin(registry: *mut GstRegistry, plugin: *mut GstPlugin);
    pub fn gst_registry_scan_path(registry: *mut GstRegistry, path: *const c_char) -> gboolean;

    //=========================================================================
    // GstStream
    //=========================================================================
    pub fn gst_stream_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_new(stream_id: *const c_char, caps: *mut GstCaps, type_: GstStreamType, flags: GstStreamFlags) -> *mut GstStream;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_get_caps(stream: *mut GstStream) -> *mut GstCaps;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_get_stream_flags(stream: *mut GstStream) -> GstStreamFlags;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_get_stream_id(stream: *mut GstStream) -> *const c_char;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_get_stream_type(stream: *mut GstStream) -> GstStreamType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_get_tags(stream: *mut GstStream) -> *mut GstTagList;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_set_caps(stream: *mut GstStream, caps: *mut GstCaps);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_set_stream_flags(stream: *mut GstStream, flags: GstStreamFlags);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_set_stream_type(stream: *mut GstStream, stream_type: GstStreamType);
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_set_tags(stream: *mut GstStream, tags: *mut GstTagList);

    //=========================================================================
    // GstStreamCollection
    //=========================================================================
    pub fn gst_stream_collection_get_type() -> GType;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_collection_new(upstream_id: *const c_char) -> *mut GstStreamCollection;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_collection_add_stream(collection: *mut GstStreamCollection, stream: *mut GstStream) -> gboolean;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_collection_get_size(collection: *mut GstStreamCollection) -> c_uint;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_collection_get_stream(collection: *mut GstStreamCollection, index: c_uint) -> *mut GstStream;
    #[cfg(any(feature = "v1_10", feature = "dox"))]
    pub fn gst_stream_collection_get_upstream_id(collection: *mut GstStreamCollection) -> *const c_char;

    //=========================================================================
    // GstSystemClock
    //=========================================================================
    pub fn gst_system_clock_get_type() -> GType;
    pub fn gst_system_clock_obtain() -> *mut GstClock;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn gst_system_clock_set_default(new_clock: *mut GstClock);

    //=========================================================================
    // GstTask
    //=========================================================================
    pub fn gst_task_get_type() -> GType;
    pub fn gst_task_new(func: GstTaskFunction, user_data: gpointer, notify: glib::GDestroyNotify) -> *mut GstTask;
    pub fn gst_task_cleanup_all();
    pub fn gst_task_get_pool(task: *mut GstTask) -> *mut GstTaskPool;
    pub fn gst_task_get_state(task: *mut GstTask) -> GstTaskState;
    pub fn gst_task_join(task: *mut GstTask) -> gboolean;
    pub fn gst_task_pause(task: *mut GstTask) -> gboolean;
    pub fn gst_task_set_enter_callback(task: *mut GstTask, enter_func: GstTaskThreadFunc, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_task_set_leave_callback(task: *mut GstTask, leave_func: GstTaskThreadFunc, user_data: gpointer, notify: glib::GDestroyNotify);
    pub fn gst_task_set_lock(task: *mut GstTask, mutex: *mut glib::GRecMutex);
    pub fn gst_task_set_pool(task: *mut GstTask, pool: *mut GstTaskPool);
    pub fn gst_task_set_state(task: *mut GstTask, state: GstTaskState) -> gboolean;
    pub fn gst_task_start(task: *mut GstTask) -> gboolean;
    pub fn gst_task_stop(task: *mut GstTask) -> gboolean;

    //=========================================================================
    // GstTaskPool
    //=========================================================================
    pub fn gst_task_pool_get_type() -> GType;
    pub fn gst_task_pool_new() -> *mut GstTaskPool;
    pub fn gst_task_pool_cleanup(pool: *mut GstTaskPool);
    pub fn gst_task_pool_join(pool: *mut GstTaskPool, id: gpointer);
    pub fn gst_task_pool_prepare(pool: *mut GstTaskPool, error: *mut *mut glib::GError);
    pub fn gst_task_pool_push(pool: *mut GstTaskPool, func: GstTaskPoolFunction, user_data: gpointer, error: *mut *mut glib::GError) -> gpointer;

    //=========================================================================
    // GstTracer
    //=========================================================================
    pub fn gst_tracer_get_type() -> GType;

    //=========================================================================
    // GstTracerFactory
    //=========================================================================
    pub fn gst_tracer_factory_get_type() -> GType;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_tracer_factory_get_list() -> *mut glib::GList;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_tracer_factory_get_tracer_type(factory: *mut GstTracerFactory) -> GType;

    //=========================================================================
    // GstTracerRecord
    //=========================================================================
    pub fn gst_tracer_record_get_type() -> GType;

    //=========================================================================
    // GstTypeFindFactory
    //=========================================================================
    pub fn gst_type_find_factory_get_type() -> GType;
    pub fn gst_type_find_factory_get_list() -> *mut glib::GList;
    pub fn gst_type_find_factory_call_function(factory: *mut GstTypeFindFactory, find: *mut GstTypeFind);
    pub fn gst_type_find_factory_get_caps(factory: *mut GstTypeFindFactory) -> *mut GstCaps;
    pub fn gst_type_find_factory_get_extensions(factory: *mut GstTypeFindFactory) -> *mut *mut c_char;
    pub fn gst_type_find_factory_has_function(factory: *mut GstTypeFindFactory) -> gboolean;

    //=========================================================================
    // GstValueArray
    //=========================================================================
    pub fn gst_value_array_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_value_array_append_and_take_value(value: *mut gobject::GValue, append_value: *mut gobject::GValue);
    pub fn gst_value_array_append_value(value: *mut gobject::GValue, append_value: *const gobject::GValue);
    pub fn gst_value_array_get_size(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_array_get_value(value: *const gobject::GValue, index: c_uint) -> *const gobject::GValue;
    pub fn gst_value_array_prepend_value(value: *mut gobject::GValue, prepend_value: *const gobject::GValue);

    //=========================================================================
    // GstValueList
    //=========================================================================
    pub fn gst_value_list_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_value_list_append_and_take_value(value: *mut gobject::GValue, append_value: *mut gobject::GValue);
    pub fn gst_value_list_append_value(value: *mut gobject::GValue, append_value: *const gobject::GValue);
    pub fn gst_value_list_concat(dest: *mut gobject::GValue, value1: *const gobject::GValue, value2: *const gobject::GValue);
    pub fn gst_value_list_get_size(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_list_get_value(value: *const gobject::GValue, index: c_uint) -> *const gobject::GValue;
    pub fn gst_value_list_merge(dest: *mut gobject::GValue, value1: *const gobject::GValue, value2: *const gobject::GValue);
    pub fn gst_value_list_prepend_value(value: *mut gobject::GValue, prepend_value: *const gobject::GValue);

    //=========================================================================
    // GstChildProxy
    //=========================================================================
    pub fn gst_child_proxy_get_type() -> GType;
    pub fn gst_child_proxy_child_added(parent: *mut GstChildProxy, child: *mut gobject::GObject, name: *const c_char);
    pub fn gst_child_proxy_child_removed(parent: *mut GstChildProxy, child: *mut gobject::GObject, name: *const c_char);
    pub fn gst_child_proxy_get(object: *mut GstChildProxy, first_property_name: *const c_char, ...);
    pub fn gst_child_proxy_get_child_by_index(parent: *mut GstChildProxy, index: c_uint) -> *mut gobject::GObject;
    pub fn gst_child_proxy_get_child_by_name(parent: *mut GstChildProxy, name: *const c_char) -> *mut gobject::GObject;
    pub fn gst_child_proxy_get_children_count(parent: *mut GstChildProxy) -> c_uint;
    pub fn gst_child_proxy_get_property(object: *mut GstChildProxy, name: *const c_char, value: *mut gobject::GValue);
    //pub fn gst_child_proxy_get_valist(object: *mut GstChildProxy, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gst_child_proxy_lookup(object: *mut GstChildProxy, name: *const c_char, target: *mut *mut gobject::GObject, pspec: *mut *mut gobject::GParamSpec) -> gboolean;
    pub fn gst_child_proxy_set(object: *mut GstChildProxy, first_property_name: *const c_char, ...);
    pub fn gst_child_proxy_set_property(object: *mut GstChildProxy, name: *const c_char, value: *const gobject::GValue);
    //pub fn gst_child_proxy_set_valist(object: *mut GstChildProxy, first_property_name: *const c_char, var_args: /*Unimplemented*/va_list);

    //=========================================================================
    // GstPreset
    //=========================================================================
    pub fn gst_preset_get_type() -> GType;
    pub fn gst_preset_get_app_dir() -> *const c_char;
    pub fn gst_preset_set_app_dir(app_dir: *const c_char) -> gboolean;
    pub fn gst_preset_delete_preset(preset: *mut GstPreset, name: *const c_char) -> gboolean;
    pub fn gst_preset_get_meta(preset: *mut GstPreset, name: *const c_char, tag: *const c_char, value: *mut *mut c_char) -> gboolean;
    pub fn gst_preset_get_preset_names(preset: *mut GstPreset) -> *mut *mut c_char;
    pub fn gst_preset_get_property_names(preset: *mut GstPreset) -> *mut *mut c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_preset_is_editable(preset: *mut GstPreset) -> gboolean;
    pub fn gst_preset_load_preset(preset: *mut GstPreset, name: *const c_char) -> gboolean;
    pub fn gst_preset_rename_preset(preset: *mut GstPreset, old_name: *const c_char, new_name: *const c_char) -> gboolean;
    pub fn gst_preset_save_preset(preset: *mut GstPreset, name: *const c_char) -> gboolean;
    pub fn gst_preset_set_meta(preset: *mut GstPreset, name: *const c_char, tag: *const c_char, value: *const c_char) -> gboolean;

    //=========================================================================
    // GstTagSetter
    //=========================================================================
    pub fn gst_tag_setter_get_type() -> GType;
    //pub fn gst_tag_setter_add_tag_valist(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    //pub fn gst_tag_setter_add_tag_valist_values(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gst_tag_setter_add_tag_value(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, value: *const gobject::GValue);
    pub fn gst_tag_setter_add_tag_values(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, ...);
    pub fn gst_tag_setter_add_tags(setter: *mut GstTagSetter, mode: GstTagMergeMode, tag: *const c_char, ...);
    pub fn gst_tag_setter_get_tag_list(setter: *mut GstTagSetter) -> *const GstTagList;
    pub fn gst_tag_setter_get_tag_merge_mode(setter: *mut GstTagSetter) -> GstTagMergeMode;
    pub fn gst_tag_setter_merge_tags(setter: *mut GstTagSetter, list: *const GstTagList, mode: GstTagMergeMode);
    pub fn gst_tag_setter_reset_tags(setter: *mut GstTagSetter);
    pub fn gst_tag_setter_set_tag_merge_mode(setter: *mut GstTagSetter, mode: GstTagMergeMode);

    //=========================================================================
    // GstTocSetter
    //=========================================================================
    pub fn gst_toc_setter_get_type() -> GType;
    pub fn gst_toc_setter_get_toc(setter: *mut GstTocSetter) -> *mut GstToc;
    pub fn gst_toc_setter_reset(setter: *mut GstTocSetter);
    pub fn gst_toc_setter_set_toc(setter: *mut GstTocSetter, toc: *mut GstToc);

    //=========================================================================
    // GstURIHandler
    //=========================================================================
    pub fn gst_uri_handler_get_type() -> GType;
    pub fn gst_uri_handler_get_protocols(handler: *mut GstURIHandler) -> *const *const c_char;
    pub fn gst_uri_handler_get_uri(handler: *mut GstURIHandler) -> *mut c_char;
    pub fn gst_uri_handler_get_uri_type(handler: *mut GstURIHandler) -> GstURIType;
    pub fn gst_uri_handler_set_uri(handler: *mut GstURIHandler, uri: *const c_char, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_calculate_linear_regression(xy: *const GstClockTime, temp: *mut GstClockTime, n: c_uint, m_num: *mut GstClockTime, m_denom: *mut GstClockTime, b: *mut GstClockTime, xbase: *mut GstClockTime, r_squared: *mut c_double) -> gboolean;
    pub fn gst_debug_add_log_function(func: GstLogFunction, user_data: gpointer, notify: glib::GDestroyNotify);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_debug_add_ring_buffer_logger(max_size_per_thread: c_uint, thread_timeout: c_uint);
    pub fn gst_debug_bin_to_dot_data(bin: *mut GstBin, details: GstDebugGraphDetails) -> *mut c_char;
    pub fn gst_debug_bin_to_dot_file(bin: *mut GstBin, details: GstDebugGraphDetails, file_name: *const c_char);
    pub fn gst_debug_bin_to_dot_file_with_ts(bin: *mut GstBin, details: GstDebugGraphDetails, file_name: *const c_char);
    pub fn gst_debug_construct_term_color(colorinfo: c_uint) -> *mut c_char;
    pub fn gst_debug_construct_win_color(colorinfo: c_uint) -> c_int;
    pub fn gst_debug_get_all_categories() -> *mut glib::GSList;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_debug_get_color_mode() -> GstDebugColorMode;
    pub fn gst_debug_get_default_threshold() -> GstDebugLevel;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_debug_get_stack_trace(flags: GstStackTraceFlags) -> *mut c_char;
    pub fn gst_debug_is_active() -> gboolean;
    pub fn gst_debug_is_colored() -> gboolean;
    pub fn gst_debug_log(category: *mut GstDebugCategory, level: GstDebugLevel, file: *const c_char, function: *const c_char, line: c_int, object: *mut gobject::GObject, format: *const c_char, ...);
    pub fn gst_debug_log_default(category: *mut GstDebugCategory, level: GstDebugLevel, file: *const c_char, function: *const c_char, line: c_int, object: *mut gobject::GObject, message: *mut GstDebugMessage, user_data: gpointer);
    //pub fn gst_debug_log_valist(category: *mut GstDebugCategory, level: GstDebugLevel, file: *const c_char, function: *const c_char, line: c_int, object: *mut gobject::GObject, format: *const c_char, args: /*Unimplemented*/va_list);
    pub fn gst_debug_print_stack_trace();
    pub fn gst_debug_remove_log_function(func: GstLogFunction) -> c_uint;
    pub fn gst_debug_remove_log_function_by_data(data: gpointer) -> c_uint;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_debug_remove_ring_buffer_logger();
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_debug_ring_buffer_logger_get_logs() -> *mut *mut c_char;
    pub fn gst_debug_set_active(active: gboolean);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_debug_set_color_mode(mode: GstDebugColorMode);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_debug_set_color_mode_from_string(mode: *const c_char);
    pub fn gst_debug_set_colored(colored: gboolean);
    pub fn gst_debug_set_default_threshold(level: GstDebugLevel);
    pub fn gst_debug_set_threshold_for_name(name: *const c_char, level: GstDebugLevel);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn gst_debug_set_threshold_from_string(list: *const c_char, reset: gboolean);
    pub fn gst_debug_unset_threshold_for_name(name: *const c_char);
    pub fn gst_deinit();
    pub fn gst_dynamic_type_register(plugin: *mut GstPlugin, type_: GType) -> gboolean;
    pub fn gst_error_get_message(domain: glib::GQuark, code: c_int) -> *mut c_char;
    pub fn gst_filename_to_uri(filename: *const c_char, error: *mut *mut glib::GError) -> *mut c_char;
    pub fn gst_flow_get_name(ret: GstFlowReturn) -> *const c_char;
    pub fn gst_flow_to_quark(ret: GstFlowReturn) -> glib::GQuark;
    pub fn gst_formats_contains(formats: *mut GstFormat, format: GstFormat) -> gboolean;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_get_main_executable_path() -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn gst_info_strdup_printf(format: *const c_char, ...) -> *mut c_char;
    //#[cfg(any(feature = "v1_8", feature = "dox"))]
    //pub fn gst_info_strdup_vprintf(format: *const c_char, args: /*Unimplemented*/va_list) -> *mut c_char;
    //#[cfg(any(feature = "v1_8", feature = "dox"))]
    //pub fn gst_info_vasprintf(result: *mut *mut c_char, format: *const c_char, args: /*Unimplemented*/va_list) -> c_int;
    pub fn gst_init(argc: *mut c_int, argv: *mut *mut c_char);
    pub fn gst_init_check(argc: *mut c_int, argv: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn gst_init_get_option_group() -> *mut glib::GOptionGroup;
    pub fn gst_is_caps_features(obj: gconstpointer) -> gboolean;
    pub fn gst_is_initialized() -> gboolean;
    pub fn gst_make_element_message_details(name: *const c_char, ...) -> *mut GstStructure;
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_param_spec_array(name: *const c_char, nick: *const c_char, blurb: *const c_char, element_spec: *mut gobject::GParamSpec, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gst_param_spec_fraction(name: *const c_char, nick: *const c_char, blurb: *const c_char, min_num: c_int, min_denom: c_int, max_num: c_int, max_denom: c_int, default_num: c_int, default_denom: c_int, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gst_parent_buffer_meta_api_get_type() -> GType;
    pub fn gst_parse_bin_from_description(bin_description: *const c_char, ghost_unlinked_pads: gboolean, error: *mut *mut glib::GError) -> *mut GstBin;
    pub fn gst_parse_bin_from_description_full(bin_description: *const c_char, ghost_unlinked_pads: gboolean, context: *mut GstParseContext, flags: GstParseFlags, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_parse_launch(pipeline_description: *const c_char, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_parse_launch_full(pipeline_description: *const c_char, context: *mut GstParseContext, flags: GstParseFlags, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_parse_launchv(argv: *mut *mut c_char, error: *mut *mut glib::GError) -> *mut GstElement;
    pub fn gst_parse_launchv_full(argv: *mut *mut c_char, context: *mut GstParseContext, flags: GstParseFlags, error: *mut *mut glib::GError) -> *mut GstElement;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_print(format: *const c_char, ...);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_printerr(format: *const c_char, ...);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_printerrln(format: *const c_char, ...);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_println(format: *const c_char, ...);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_protection_filter_systems_by_available_decryptors(system_identifiers: *mut *mut c_char) -> *mut *mut c_char;
    pub fn gst_protection_meta_api_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_protection_select_system(system_identifiers: *mut *mut c_char) -> *const c_char;
    pub fn gst_reference_timestamp_meta_api_get_type() -> GType;
    pub fn gst_segtrap_is_enabled() -> gboolean;
    pub fn gst_segtrap_set_enabled(enabled: gboolean);
    pub fn gst_static_caps_get_type() -> GType;
    pub fn gst_static_pad_template_get_type() -> GType;
    pub fn gst_tag_exists(tag: *const c_char) -> gboolean;
    pub fn gst_tag_get_description(tag: *const c_char) -> *const c_char;
    pub fn gst_tag_get_flag(tag: *const c_char) -> GstTagFlag;
    pub fn gst_tag_get_nick(tag: *const c_char) -> *const c_char;
    pub fn gst_tag_get_type(tag: *const c_char) -> GType;
    pub fn gst_tag_is_fixed(tag: *const c_char) -> gboolean;
    pub fn gst_tag_merge_strings_with_comma(dest: *mut gobject::GValue, src: *const gobject::GValue);
    pub fn gst_tag_merge_use_first(dest: *mut gobject::GValue, src: *const gobject::GValue);
    pub fn gst_tag_register(name: *const c_char, flag: GstTagFlag, type_: GType, nick: *const c_char, blurb: *const c_char, func: GstTagMergeFunc);
    pub fn gst_tag_register_static(name: *const c_char, flag: GstTagFlag, type_: GType, nick: *const c_char, blurb: *const c_char, func: GstTagMergeFunc);
    pub fn gst_type_find_get_type() -> GType;
    pub fn gst_update_registry() -> gboolean;
    pub fn gst_util_array_binary_search(array: gpointer, num_elements: c_uint, element_size: size_t, search_func: glib::GCompareDataFunc, mode: GstSearchMode, search_data: gconstpointer, user_data: gpointer) -> gpointer;
    pub fn gst_util_double_to_fraction(src: c_double, dest_n: *mut c_int, dest_d: *mut c_int);
    #[cfg(any(feature = "v1_14", feature = "dox"))]
    pub fn gst_util_dump_buffer(buf: *mut GstBuffer);
    pub fn gst_util_dump_mem(mem: *mut u8, size: c_uint);
    pub fn gst_util_fraction_add(a_n: c_int, a_d: c_int, b_n: c_int, b_d: c_int, res_n: *mut c_int, res_d: *mut c_int) -> gboolean;
    pub fn gst_util_fraction_compare(a_n: c_int, a_d: c_int, b_n: c_int, b_d: c_int) -> c_int;
    pub fn gst_util_fraction_multiply(a_n: c_int, a_d: c_int, b_n: c_int, b_d: c_int, res_n: *mut c_int, res_d: *mut c_int) -> gboolean;
    pub fn gst_util_fraction_to_double(src_n: c_int, src_d: c_int, dest: *mut c_double);
    pub fn gst_util_gdouble_to_guint64(value: c_double) -> u64;
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_util_get_object_array(object: *mut gobject::GObject, name: *const c_char, array: *mut *mut gobject::GValueArray) -> gboolean;
    pub fn gst_util_get_timestamp() -> GstClockTime;
    pub fn gst_util_greatest_common_divisor(a: c_int, b: c_int) -> c_int;
    pub fn gst_util_greatest_common_divisor_int64(a: i64, b: i64) -> i64;
    pub fn gst_util_group_id_next() -> c_uint;
    pub fn gst_util_guint64_to_gdouble(value: u64) -> c_double;
    pub fn gst_util_seqnum_compare(s1: u32, s2: u32) -> i32;
    pub fn gst_util_seqnum_next() -> u32;
    pub fn gst_util_set_object_arg(object: *mut gobject::GObject, name: *const c_char, value: *const c_char);
    #[cfg(any(feature = "v1_12", feature = "dox"))]
    pub fn gst_util_set_object_array(object: *mut gobject::GObject, name: *const c_char, array: *const gobject::GValueArray) -> gboolean;
    pub fn gst_util_set_value_from_string(value: *mut gobject::GValue, value_str: *const c_char);
    pub fn gst_util_uint64_scale(val: u64, num: u64, denom: u64) -> u64;
    pub fn gst_util_uint64_scale_ceil(val: u64, num: u64, denom: u64) -> u64;
    pub fn gst_util_uint64_scale_int(val: u64, num: c_int, denom: c_int) -> u64;
    pub fn gst_util_uint64_scale_int_ceil(val: u64, num: c_int, denom: c_int) -> u64;
    pub fn gst_util_uint64_scale_int_round(val: u64, num: c_int, denom: c_int) -> u64;
    pub fn gst_util_uint64_scale_round(val: u64, num: u64, denom: u64) -> u64;
    pub fn gst_value_can_compare(value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_can_intersect(value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_can_subtract(minuend: *const gobject::GValue, subtrahend: *const gobject::GValue) -> gboolean;
    pub fn gst_value_can_union(value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_compare(value1: *const gobject::GValue, value2: *const gobject::GValue) -> c_int;
    pub fn gst_value_deserialize(dest: *mut gobject::GValue, src: *const c_char) -> gboolean;
    pub fn gst_value_fixate(dest: *mut gobject::GValue, src: *const gobject::GValue) -> gboolean;
    pub fn gst_value_fraction_multiply(product: *mut gobject::GValue, factor1: *const gobject::GValue, factor2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_fraction_subtract(dest: *mut gobject::GValue, minuend: *const gobject::GValue, subtrahend: *const gobject::GValue) -> gboolean;
    pub fn gst_value_get_bitmask(value: *const gobject::GValue) -> u64;
    pub fn gst_value_get_caps(value: *const gobject::GValue) -> *const GstCaps;
    pub fn gst_value_get_caps_features(value: *const gobject::GValue) -> *const GstCapsFeatures;
    pub fn gst_value_get_double_range_max(value: *const gobject::GValue) -> c_double;
    pub fn gst_value_get_double_range_min(value: *const gobject::GValue) -> c_double;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_value_get_flagset_flags(value: *const gobject::GValue) -> c_uint;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_value_get_flagset_mask(value: *const gobject::GValue) -> c_uint;
    pub fn gst_value_get_fraction_denominator(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_fraction_numerator(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_fraction_range_max(value: *const gobject::GValue) -> *const gobject::GValue;
    pub fn gst_value_get_fraction_range_min(value: *const gobject::GValue) -> *const gobject::GValue;
    pub fn gst_value_get_int64_range_max(value: *const gobject::GValue) -> i64;
    pub fn gst_value_get_int64_range_min(value: *const gobject::GValue) -> i64;
    pub fn gst_value_get_int64_range_step(value: *const gobject::GValue) -> i64;
    pub fn gst_value_get_int_range_max(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_int_range_min(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_int_range_step(value: *const gobject::GValue) -> c_int;
    pub fn gst_value_get_structure(value: *const gobject::GValue) -> *const GstStructure;
    pub fn gst_value_init_and_copy(dest: *mut gobject::GValue, src: *const gobject::GValue);
    pub fn gst_value_intersect(dest: *mut gobject::GValue, value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_is_fixed(value: *const gobject::GValue) -> gboolean;
    pub fn gst_value_is_subset(value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_value_register(table: *const GstValueTable);
    pub fn gst_value_serialize(value: *const gobject::GValue) -> *mut c_char;
    pub fn gst_value_set_bitmask(value: *mut gobject::GValue, bitmask: u64);
    pub fn gst_value_set_caps(value: *mut gobject::GValue, caps: *const GstCaps);
    pub fn gst_value_set_caps_features(value: *mut gobject::GValue, features: *const GstCapsFeatures);
    pub fn gst_value_set_double_range(value: *mut gobject::GValue, start: c_double, end: c_double);
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn gst_value_set_flagset(value: *mut gobject::GValue, flags: c_uint, mask: c_uint);
    pub fn gst_value_set_fraction(value: *mut gobject::GValue, numerator: c_int, denominator: c_int);
    pub fn gst_value_set_fraction_range(value: *mut gobject::GValue, start: *const gobject::GValue, end: *const gobject::GValue);
    pub fn gst_value_set_fraction_range_full(value: *mut gobject::GValue, numerator_start: c_int, denominator_start: c_int, numerator_end: c_int, denominator_end: c_int);
    pub fn gst_value_set_int64_range(value: *mut gobject::GValue, start: i64, end: i64);
    pub fn gst_value_set_int64_range_step(value: *mut gobject::GValue, start: i64, end: i64, step: i64);
    pub fn gst_value_set_int_range(value: *mut gobject::GValue, start: c_int, end: c_int);
    pub fn gst_value_set_int_range_step(value: *mut gobject::GValue, start: c_int, end: c_int, step: c_int);
    pub fn gst_value_set_structure(value: *mut gobject::GValue, structure: *const GstStructure);
    pub fn gst_value_subtract(dest: *mut gobject::GValue, minuend: *const gobject::GValue, subtrahend: *const gobject::GValue) -> gboolean;
    pub fn gst_value_union(dest: *mut gobject::GValue, value1: *const gobject::GValue, value2: *const gobject::GValue) -> gboolean;
    pub fn gst_version(major: *mut c_uint, minor: *mut c_uint, micro: *mut c_uint, nano: *mut c_uint);
    pub fn gst_version_string() -> *mut c_char;

}
