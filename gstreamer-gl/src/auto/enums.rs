// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use gst_gl_sys;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLContextError {
    Failed,
    WrongConfig,
    WrongApi,
    OldLibs,
    CreateContext,
    ResourceUnavailable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLContextError {
    type GlibType = gst_gl_sys::GstGLContextError;

    fn to_glib(&self) -> gst_gl_sys::GstGLContextError {
        match *self {
            GLContextError::Failed => gst_gl_sys::GST_GL_CONTEXT_ERROR_FAILED,
            GLContextError::WrongConfig => gst_gl_sys::GST_GL_CONTEXT_ERROR_WRONG_CONFIG,
            GLContextError::WrongApi => gst_gl_sys::GST_GL_CONTEXT_ERROR_WRONG_API,
            GLContextError::OldLibs => gst_gl_sys::GST_GL_CONTEXT_ERROR_OLD_LIBS,
            GLContextError::CreateContext => gst_gl_sys::GST_GL_CONTEXT_ERROR_CREATE_CONTEXT,
            GLContextError::ResourceUnavailable => {
                gst_gl_sys::GST_GL_CONTEXT_ERROR_RESOURCE_UNAVAILABLE
            }
            GLContextError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_gl_sys::GstGLContextError> for GLContextError {
    fn from_glib(value: gst_gl_sys::GstGLContextError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLContextError::Failed,
            1 => GLContextError::WrongConfig,
            2 => GLContextError::WrongApi,
            3 => GLContextError::OldLibs,
            4 => GLContextError::CreateContext,
            5 => GLContextError::ResourceUnavailable,
            value => GLContextError::__Unknown(value),
        }
    }
}

impl ErrorDomain for GLContextError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(gst_gl_sys::gst_gl_context_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(GLContextError::Failed),
            1 => Some(GLContextError::WrongConfig),
            2 => Some(GLContextError::WrongApi),
            3 => Some(GLContextError::OldLibs),
            4 => Some(GLContextError::CreateContext),
            5 => Some(GLContextError::ResourceUnavailable),
            _ => Some(GLContextError::Failed),
        }
    }
}

impl StaticType for GLContextError {
    fn static_type() -> Type {
        unsafe { from_glib(gst_gl_sys::gst_gl_context_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLContextError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLContextError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLContextError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLFormat {
    Luminance,
    Alpha,
    LuminanceAlpha,
    Red,
    R8,
    Rg,
    Rg8,
    Rgb,
    Rgb8,
    Rgb565,
    Rgb16,
    Rgba,
    Rgba8,
    Rgba16,
    DepthComponent16,
    Depth24Stencil8,
    Rgb10A2,
    R16,
    Rg16,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLFormat {
    type GlibType = gst_gl_sys::GstGLFormat;

    fn to_glib(&self) -> gst_gl_sys::GstGLFormat {
        match *self {
            GLFormat::Luminance => gst_gl_sys::GST_GL_LUMINANCE,
            GLFormat::Alpha => gst_gl_sys::GST_GL_ALPHA,
            GLFormat::LuminanceAlpha => gst_gl_sys::GST_GL_LUMINANCE_ALPHA,
            GLFormat::Red => gst_gl_sys::GST_GL_RED,
            GLFormat::R8 => gst_gl_sys::GST_GL_R8,
            GLFormat::Rg => gst_gl_sys::GST_GL_RG,
            GLFormat::Rg8 => gst_gl_sys::GST_GL_RG8,
            GLFormat::Rgb => gst_gl_sys::GST_GL_RGB,
            GLFormat::Rgb8 => gst_gl_sys::GST_GL_RGB8,
            GLFormat::Rgb565 => gst_gl_sys::GST_GL_RGB565,
            GLFormat::Rgb16 => gst_gl_sys::GST_GL_RGB16,
            GLFormat::Rgba => gst_gl_sys::GST_GL_RGBA,
            GLFormat::Rgba8 => gst_gl_sys::GST_GL_RGBA8,
            GLFormat::Rgba16 => gst_gl_sys::GST_GL_RGBA16,
            GLFormat::DepthComponent16 => gst_gl_sys::GST_GL_DEPTH_COMPONENT16,
            GLFormat::Depth24Stencil8 => gst_gl_sys::GST_GL_DEPTH24_STENCIL8,
            GLFormat::Rgb10A2 => gst_gl_sys::GST_GL_RGB10_A2,
            GLFormat::R16 => gst_gl_sys::GST_GL_R16,
            GLFormat::Rg16 => gst_gl_sys::GST_GL_RG16,
            GLFormat::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_gl_sys::GstGLFormat> for GLFormat {
    fn from_glib(value: gst_gl_sys::GstGLFormat) -> Self {
        skip_assert_initialized!();
        match value {
            6409 => GLFormat::Luminance,
            6406 => GLFormat::Alpha,
            6410 => GLFormat::LuminanceAlpha,
            6403 => GLFormat::Red,
            33321 => GLFormat::R8,
            33319 => GLFormat::Rg,
            33323 => GLFormat::Rg8,
            6407 => GLFormat::Rgb,
            32849 => GLFormat::Rgb8,
            36194 => GLFormat::Rgb565,
            32852 => GLFormat::Rgb16,
            6408 => GLFormat::Rgba,
            32856 => GLFormat::Rgba8,
            32859 => GLFormat::Rgba16,
            33189 => GLFormat::DepthComponent16,
            35056 => GLFormat::Depth24Stencil8,
            32857 => GLFormat::Rgb10A2,
            33322 => GLFormat::R16,
            33324 => GLFormat::Rg16,
            value => GLFormat::__Unknown(value),
        }
    }
}

impl StaticType for GLFormat {
    fn static_type() -> Type {
        unsafe { from_glib(gst_gl_sys::gst_gl_format_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLFormat {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLFormat {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLFormat {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLQueryType {
    None,
    TimeElapsed,
    Timestamp,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLQueryType {
    type GlibType = gst_gl_sys::GstGLQueryType;

    fn to_glib(&self) -> gst_gl_sys::GstGLQueryType {
        match *self {
            GLQueryType::None => gst_gl_sys::GST_GL_QUERY_NONE,
            GLQueryType::TimeElapsed => gst_gl_sys::GST_GL_QUERY_TIME_ELAPSED,
            GLQueryType::Timestamp => gst_gl_sys::GST_GL_QUERY_TIMESTAMP,
            GLQueryType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_gl_sys::GstGLQueryType> for GLQueryType {
    fn from_glib(value: gst_gl_sys::GstGLQueryType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLQueryType::None,
            1 => GLQueryType::TimeElapsed,
            2 => GLQueryType::Timestamp,
            value => GLQueryType::__Unknown(value),
        }
    }
}

impl StaticType for GLQueryType {
    fn static_type() -> Type {
        unsafe { from_glib(gst_gl_sys::gst_gl_query_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLQueryType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLQueryType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLQueryType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLSLError {
    Compile,
    Link,
    Program,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLSLError {
    type GlibType = gst_gl_sys::GstGLSLError;

    fn to_glib(&self) -> gst_gl_sys::GstGLSLError {
        match *self {
            GLSLError::Compile => gst_gl_sys::GST_GLSL_ERROR_COMPILE,
            GLSLError::Link => gst_gl_sys::GST_GLSL_ERROR_LINK,
            GLSLError::Program => gst_gl_sys::GST_GLSL_ERROR_PROGRAM,
            GLSLError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_gl_sys::GstGLSLError> for GLSLError {
    fn from_glib(value: gst_gl_sys::GstGLSLError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLSLError::Compile,
            1 => GLSLError::Link,
            2 => GLSLError::Program,
            value => GLSLError::__Unknown(value),
        }
    }
}

impl ErrorDomain for GLSLError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(gst_gl_sys::gst_glsl_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(GLSLError::Compile),
            1 => Some(GLSLError::Link),
            2 => Some(GLSLError::Program),
            value => Some(GLSLError::__Unknown(value)),
        }
    }
}

impl StaticType for GLSLError {
    fn static_type() -> Type {
        unsafe { from_glib(gst_gl_sys::gst_glsl_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLSLError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLSLError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLSLError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLSLVersion {
    None,
    _100,
    _110,
    _120,
    _130,
    _140,
    _150,
    _300,
    _310,
    _320,
    _330,
    _400,
    _410,
    _420,
    _430,
    _440,
    _450,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLSLVersion {
    type GlibType = gst_gl_sys::GstGLSLVersion;

    fn to_glib(&self) -> gst_gl_sys::GstGLSLVersion {
        match *self {
            GLSLVersion::None => gst_gl_sys::GST_GLSL_VERSION_NONE,
            GLSLVersion::_100 => gst_gl_sys::GST_GLSL_VERSION_100,
            GLSLVersion::_110 => gst_gl_sys::GST_GLSL_VERSION_110,
            GLSLVersion::_120 => gst_gl_sys::GST_GLSL_VERSION_120,
            GLSLVersion::_130 => gst_gl_sys::GST_GLSL_VERSION_130,
            GLSLVersion::_140 => gst_gl_sys::GST_GLSL_VERSION_140,
            GLSLVersion::_150 => gst_gl_sys::GST_GLSL_VERSION_150,
            GLSLVersion::_300 => gst_gl_sys::GST_GLSL_VERSION_300,
            GLSLVersion::_310 => gst_gl_sys::GST_GLSL_VERSION_310,
            GLSLVersion::_320 => gst_gl_sys::GST_GLSL_VERSION_320,
            GLSLVersion::_330 => gst_gl_sys::GST_GLSL_VERSION_330,
            GLSLVersion::_400 => gst_gl_sys::GST_GLSL_VERSION_400,
            GLSLVersion::_410 => gst_gl_sys::GST_GLSL_VERSION_410,
            GLSLVersion::_420 => gst_gl_sys::GST_GLSL_VERSION_420,
            GLSLVersion::_430 => gst_gl_sys::GST_GLSL_VERSION_430,
            GLSLVersion::_440 => gst_gl_sys::GST_GLSL_VERSION_440,
            GLSLVersion::_450 => gst_gl_sys::GST_GLSL_VERSION_450,
            GLSLVersion::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_gl_sys::GstGLSLVersion> for GLSLVersion {
    fn from_glib(value: gst_gl_sys::GstGLSLVersion) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLSLVersion::None,
            100 => GLSLVersion::_100,
            110 => GLSLVersion::_110,
            120 => GLSLVersion::_120,
            130 => GLSLVersion::_130,
            140 => GLSLVersion::_140,
            150 => GLSLVersion::_150,
            300 => GLSLVersion::_300,
            310 => GLSLVersion::_310,
            320 => GLSLVersion::_320,
            330 => GLSLVersion::_330,
            400 => GLSLVersion::_400,
            410 => GLSLVersion::_410,
            420 => GLSLVersion::_420,
            430 => GLSLVersion::_430,
            440 => GLSLVersion::_440,
            450 => GLSLVersion::_450,
            value => GLSLVersion::__Unknown(value),
        }
    }
}

impl StaticType for GLSLVersion {
    fn static_type() -> Type {
        unsafe { from_glib(gst_gl_sys::gst_glsl_version_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLSLVersion {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLSLVersion {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLSLVersion {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLStereoDownmix {
    GreenMagentaDubois,
    RedCyanDubois,
    AmberBlueDubois,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLStereoDownmix {
    type GlibType = gst_gl_sys::GstGLStereoDownmix;

    fn to_glib(&self) -> gst_gl_sys::GstGLStereoDownmix {
        match *self {
            GLStereoDownmix::GreenMagentaDubois => {
                gst_gl_sys::GST_GL_STEREO_DOWNMIX_ANAGLYPH_GREEN_MAGENTA_DUBOIS
            }
            GLStereoDownmix::RedCyanDubois => {
                gst_gl_sys::GST_GL_STEREO_DOWNMIX_ANAGLYPH_RED_CYAN_DUBOIS
            }
            GLStereoDownmix::AmberBlueDubois => {
                gst_gl_sys::GST_GL_STEREO_DOWNMIX_ANAGLYPH_AMBER_BLUE_DUBOIS
            }
            GLStereoDownmix::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_gl_sys::GstGLStereoDownmix> for GLStereoDownmix {
    fn from_glib(value: gst_gl_sys::GstGLStereoDownmix) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLStereoDownmix::GreenMagentaDubois,
            1 => GLStereoDownmix::RedCyanDubois,
            2 => GLStereoDownmix::AmberBlueDubois,
            value => GLStereoDownmix::__Unknown(value),
        }
    }
}

impl StaticType for GLStereoDownmix {
    fn static_type() -> Type {
        unsafe { from_glib(gst_gl_sys::gst_gl_stereo_downmix_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLStereoDownmix {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLStereoDownmix {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLStereoDownmix {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLTextureTarget {
    None,
    _2d,
    Rectangle,
    ExternalOes,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLTextureTarget {
    type GlibType = gst_gl_sys::GstGLTextureTarget;

    fn to_glib(&self) -> gst_gl_sys::GstGLTextureTarget {
        match *self {
            GLTextureTarget::None => gst_gl_sys::GST_GL_TEXTURE_TARGET_NONE,
            GLTextureTarget::_2d => gst_gl_sys::GST_GL_TEXTURE_TARGET_2D,
            GLTextureTarget::Rectangle => gst_gl_sys::GST_GL_TEXTURE_TARGET_RECTANGLE,
            GLTextureTarget::ExternalOes => gst_gl_sys::GST_GL_TEXTURE_TARGET_EXTERNAL_OES,
            GLTextureTarget::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_gl_sys::GstGLTextureTarget> for GLTextureTarget {
    fn from_glib(value: gst_gl_sys::GstGLTextureTarget) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLTextureTarget::None,
            1 => GLTextureTarget::_2d,
            2 => GLTextureTarget::Rectangle,
            3 => GLTextureTarget::ExternalOes,
            value => GLTextureTarget::__Unknown(value),
        }
    }
}

impl StaticType for GLTextureTarget {
    fn static_type() -> Type {
        unsafe { from_glib(gst_gl_sys::gst_gl_texture_target_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLTextureTarget {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLTextureTarget {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLTextureTarget {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLUploadReturn {
    Done,
    Error,
    Unsupported,
    Reconfigure,
    UnsharedGlContext,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLUploadReturn {
    type GlibType = gst_gl_sys::GstGLUploadReturn;

    fn to_glib(&self) -> gst_gl_sys::GstGLUploadReturn {
        match *self {
            GLUploadReturn::Done => gst_gl_sys::GST_GL_UPLOAD_DONE,
            GLUploadReturn::Error => gst_gl_sys::GST_GL_UPLOAD_ERROR,
            GLUploadReturn::Unsupported => gst_gl_sys::GST_GL_UPLOAD_UNSUPPORTED,
            GLUploadReturn::Reconfigure => gst_gl_sys::GST_GL_UPLOAD_RECONFIGURE,
            GLUploadReturn::UnsharedGlContext => gst_gl_sys::GST_GL_UPLOAD_UNSHARED_GL_CONTEXT,
            GLUploadReturn::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_gl_sys::GstGLUploadReturn> for GLUploadReturn {
    fn from_glib(value: gst_gl_sys::GstGLUploadReturn) -> Self {
        skip_assert_initialized!();
        match value {
            1 => GLUploadReturn::Done,
            -1 => GLUploadReturn::Error,
            -2 => GLUploadReturn::Unsupported,
            -3 => GLUploadReturn::Reconfigure,
            -100 => GLUploadReturn::UnsharedGlContext,
            value => GLUploadReturn::__Unknown(value),
        }
    }
}

impl StaticType for GLUploadReturn {
    fn static_type() -> Type {
        unsafe { from_glib(gst_gl_sys::gst_gl_upload_return_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLUploadReturn {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLUploadReturn {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLUploadReturn {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum GLWindowError {
    Failed,
    OldLibs,
    ResourceUnavailable,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for GLWindowError {
    type GlibType = gst_gl_sys::GstGLWindowError;

    fn to_glib(&self) -> gst_gl_sys::GstGLWindowError {
        match *self {
            GLWindowError::Failed => gst_gl_sys::GST_GL_WINDOW_ERROR_FAILED,
            GLWindowError::OldLibs => gst_gl_sys::GST_GL_WINDOW_ERROR_OLD_LIBS,
            GLWindowError::ResourceUnavailable => {
                gst_gl_sys::GST_GL_WINDOW_ERROR_RESOURCE_UNAVAILABLE
            }
            GLWindowError::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_gl_sys::GstGLWindowError> for GLWindowError {
    fn from_glib(value: gst_gl_sys::GstGLWindowError) -> Self {
        skip_assert_initialized!();
        match value {
            0 => GLWindowError::Failed,
            1 => GLWindowError::OldLibs,
            2 => GLWindowError::ResourceUnavailable,
            value => GLWindowError::__Unknown(value),
        }
    }
}

impl ErrorDomain for GLWindowError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(gst_gl_sys::gst_gl_window_error_quark()) }
    }

    fn code(self) -> i32 {
        self.to_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            0 => Some(GLWindowError::Failed),
            1 => Some(GLWindowError::OldLibs),
            2 => Some(GLWindowError::ResourceUnavailable),
            _ => Some(GLWindowError::Failed),
        }
    }
}

impl StaticType for GLWindowError {
    fn static_type() -> Type {
        unsafe { from_glib(gst_gl_sys::gst_gl_window_error_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for GLWindowError {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for GLWindowError {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for GLWindowError {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
