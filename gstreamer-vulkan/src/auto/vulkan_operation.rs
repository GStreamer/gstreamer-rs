// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// from gst-gir-files (https://gitlab.freedesktop.org/gstreamer/gir-files-rs.git)
// DO NOT EDIT

use crate::VulkanCommandPool;
use glib::{prelude::*, translate::*};

glib::wrapper! {
    #[doc(alias = "GstVulkanOperation")]
    pub struct VulkanOperation(Object<ffi::GstVulkanOperation, ffi::GstVulkanOperationClass>) @extends gst::Object;

    match fn {
        type_ => || ffi::gst_vulkan_operation_get_type(),
    }
}

impl VulkanOperation {
    pub const NONE: Option<&'static VulkanOperation> = None;

    #[doc(alias = "gst_vulkan_operation_new")]
    pub fn new(cmd_pool: &impl IsA<VulkanCommandPool>) -> VulkanOperation {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(ffi::gst_vulkan_operation_new(
                cmd_pool.as_ref().to_glib_none().0,
            ))
        }
    }
}

unsafe impl Send for VulkanOperation {}
unsafe impl Sync for VulkanOperation {}

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::VulkanOperation>> Sealed for T {}
}

pub trait VulkanOperationExt: IsA<VulkanOperation> + sealed::Sealed + 'static {
    #[doc(alias = "gst_vulkan_operation_add_dependency_frame")]
    fn add_dependency_frame(
        &self,
        frame: &gst::Buffer,
        wait_stage: u64,
        signal_stage: u64,
    ) -> bool {
        unsafe {
            from_glib(ffi::gst_vulkan_operation_add_dependency_frame(
                self.as_ref().to_glib_none().0,
                frame.to_glib_none().0,
                wait_stage,
                signal_stage,
            ))
        }
    }

    //#[doc(alias = "gst_vulkan_operation_add_extra_image_barriers")]
    //fn add_extra_image_barriers(&self, extra_barriers: /*Unknown conversion*//*Unimplemented*/Array TypeId { ns_id: 0, id: 25 }) {
    //    unsafe { TODO: call ffi:gst_vulkan_operation_add_extra_image_barriers() }
    //}

    //#[doc(alias = "gst_vulkan_operation_add_frame_barrier")]
    //fn add_frame_barrier(&self, frame: &gst::Buffer, dst_stage: u64, new_access: u64, new_layout: /*Ignored*/&vulkan::ImageLayout, new_queue: Option<&impl IsA<VulkanQueue>>) -> bool {
    //    unsafe { TODO: call ffi:gst_vulkan_operation_add_frame_barrier() }
    //}

    #[doc(alias = "gst_vulkan_operation_begin")]
    fn begin(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gst_vulkan_operation_begin(self.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "gst_vulkan_operation_begin_query")]
    fn begin_query(&self, id: u32) -> bool {
        unsafe {
            from_glib(ffi::gst_vulkan_operation_begin_query(
                self.as_ref().to_glib_none().0,
                id,
            ))
        }
    }

    #[doc(alias = "gst_vulkan_operation_discard_dependencies")]
    fn discard_dependencies(&self) {
        unsafe {
            ffi::gst_vulkan_operation_discard_dependencies(self.as_ref().to_glib_none().0);
        }
    }

    //#[doc(alias = "gst_vulkan_operation_enable_query")]
    //fn enable_query(&self, query_type: u32, n_queries: u32, pnext: /*Unimplemented*/Option<Basic: Pointer>) -> Result<(), glib::Error> {
    //    unsafe { TODO: call ffi:gst_vulkan_operation_enable_query() }
    //}

    #[doc(alias = "gst_vulkan_operation_end")]
    fn end(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::gst_vulkan_operation_end(self.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "gst_vulkan_operation_end_query")]
    fn end_query(&self, id: u32) -> bool {
        unsafe {
            from_glib(ffi::gst_vulkan_operation_end_query(
                self.as_ref().to_glib_none().0,
                id,
            ))
        }
    }

    //#[doc(alias = "gst_vulkan_operation_get_query")]
    //#[doc(alias = "get_query")]
    //fn query(&self, data: /*Unimplemented*/&mut Option<Basic: Pointer>) -> Result<(), glib::Error> {
    //    unsafe { TODO: call ffi:gst_vulkan_operation_get_query() }
    //}

    //#[doc(alias = "gst_vulkan_operation_new_extra_image_barriers")]
    //fn new_extra_image_barriers(&self) -> /*Unknown conversion*//*Unimplemented*/Array TypeId { ns_id: 0, id: 25 } {
    //    unsafe { TODO: call ffi:gst_vulkan_operation_new_extra_image_barriers() }
    //}

    //#[doc(alias = "gst_vulkan_operation_pipeline_barrier2")]
    //fn pipeline_barrier2(&self, dependency_info: /*Unimplemented*/Option<Basic: Pointer>) -> bool {
    //    unsafe { TODO: call ffi:gst_vulkan_operation_pipeline_barrier2() }
    //}

    #[doc(alias = "gst_vulkan_operation_reset")]
    fn reset(&self) {
        unsafe {
            ffi::gst_vulkan_operation_reset(self.as_ref().to_glib_none().0);
        }
    }

    //#[doc(alias = "gst_vulkan_operation_retrieve_image_barriers")]
    //fn retrieve_image_barriers(&self) -> /*Unknown conversion*//*Unimplemented*/Array TypeId { ns_id: 0, id: 25 } {
    //    unsafe { TODO: call ffi:gst_vulkan_operation_retrieve_image_barriers() }
    //}

    //#[doc(alias = "gst_vulkan_operation_update_frame")]
    //fn update_frame(&self, frame: &gst::Buffer, dst_stage: u64, new_access: u64, new_layout: /*Ignored*/&vulkan::ImageLayout, new_queue: Option<&impl IsA<VulkanQueue>>) {
    //    unsafe { TODO: call ffi:gst_vulkan_operation_update_frame() }
    //}

    #[doc(alias = "gst_vulkan_operation_use_sync2")]
    fn use_sync2(&self) -> bool {
        unsafe {
            from_glib(ffi::gst_vulkan_operation_use_sync2(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "gst_vulkan_operation_wait")]
    fn wait(&self) -> bool {
        unsafe {
            from_glib(ffi::gst_vulkan_operation_wait(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "command-pool")]
    fn command_pool(&self) -> Option<VulkanCommandPool> {
        ObjectExt::property(self.as_ref(), "command-pool")
    }
}

impl<O: IsA<VulkanOperation>> VulkanOperationExt for O {}
