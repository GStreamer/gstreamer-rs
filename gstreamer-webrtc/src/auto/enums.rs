// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::translate::*;
use glib::value::FromValue;
use glib::value::FromValueOptional;
use glib::value::SetValue;
use glib::value::Value;
use glib::StaticType;
use glib::Type;
use gobject_sys;
use gst_web_rtc_sys;

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCBundlePolicy {
    None,
    Balanced,
    MaxCompat,
    MaxBundle,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebRTCBundlePolicy {
    type GlibType = gst_web_rtc_sys::GstWebRTCBundlePolicy;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCBundlePolicy {
        match *self {
            WebRTCBundlePolicy::None => gst_web_rtc_sys::GST_WEBRTC_BUNDLE_POLICY_NONE,
            WebRTCBundlePolicy::Balanced => gst_web_rtc_sys::GST_WEBRTC_BUNDLE_POLICY_BALANCED,
            WebRTCBundlePolicy::MaxCompat => gst_web_rtc_sys::GST_WEBRTC_BUNDLE_POLICY_MAX_COMPAT,
            WebRTCBundlePolicy::MaxBundle => gst_web_rtc_sys::GST_WEBRTC_BUNDLE_POLICY_MAX_BUNDLE,
            WebRTCBundlePolicy::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCBundlePolicy> for WebRTCBundlePolicy {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCBundlePolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCBundlePolicy::None,
            1 => WebRTCBundlePolicy::Balanced,
            2 => WebRTCBundlePolicy::MaxCompat,
            3 => WebRTCBundlePolicy::MaxBundle,
            value => WebRTCBundlePolicy::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl StaticType for WebRTCBundlePolicy {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_bundle_policy_get_type()) }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebRTCBundlePolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValue<'a> for WebRTCBundlePolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl SetValue for WebRTCBundlePolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCDTLSSetup {
    None,
    Actpass,
    Active,
    Passive,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCDTLSSetup {
    type GlibType = gst_web_rtc_sys::GstWebRTCDTLSSetup;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCDTLSSetup {
        match *self {
            WebRTCDTLSSetup::None => gst_web_rtc_sys::GST_WEBRTC_DTLS_SETUP_NONE,
            WebRTCDTLSSetup::Actpass => gst_web_rtc_sys::GST_WEBRTC_DTLS_SETUP_ACTPASS,
            WebRTCDTLSSetup::Active => gst_web_rtc_sys::GST_WEBRTC_DTLS_SETUP_ACTIVE,
            WebRTCDTLSSetup::Passive => gst_web_rtc_sys::GST_WEBRTC_DTLS_SETUP_PASSIVE,
            WebRTCDTLSSetup::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCDTLSSetup> for WebRTCDTLSSetup {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCDTLSSetup) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCDTLSSetup::None,
            1 => WebRTCDTLSSetup::Actpass,
            2 => WebRTCDTLSSetup::Active,
            3 => WebRTCDTLSSetup::Passive,
            value => WebRTCDTLSSetup::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCDTLSSetup {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_dtls_setup_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCDTLSSetup {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCDTLSSetup {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCDTLSSetup {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCDTLSTransportState {
    New,
    Closed,
    Failed,
    Connecting,
    Connected,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCDTLSTransportState {
    type GlibType = gst_web_rtc_sys::GstWebRTCDTLSTransportState;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCDTLSTransportState {
        match *self {
            WebRTCDTLSTransportState::New => gst_web_rtc_sys::GST_WEBRTC_DTLS_TRANSPORT_STATE_NEW,
            WebRTCDTLSTransportState::Closed => {
                gst_web_rtc_sys::GST_WEBRTC_DTLS_TRANSPORT_STATE_CLOSED
            }
            WebRTCDTLSTransportState::Failed => {
                gst_web_rtc_sys::GST_WEBRTC_DTLS_TRANSPORT_STATE_FAILED
            }
            WebRTCDTLSTransportState::Connecting => {
                gst_web_rtc_sys::GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTING
            }
            WebRTCDTLSTransportState::Connected => {
                gst_web_rtc_sys::GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTED
            }
            WebRTCDTLSTransportState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCDTLSTransportState> for WebRTCDTLSTransportState {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCDTLSTransportState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCDTLSTransportState::New,
            1 => WebRTCDTLSTransportState::Closed,
            2 => WebRTCDTLSTransportState::Failed,
            3 => WebRTCDTLSTransportState::Connecting,
            4 => WebRTCDTLSTransportState::Connected,
            value => WebRTCDTLSTransportState::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCDTLSTransportState {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_dtls_transport_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCDTLSTransportState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCDTLSTransportState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCDTLSTransportState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCDataChannelState {
    New,
    Connecting,
    Open,
    Closing,
    Closed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebRTCDataChannelState {
    type GlibType = gst_web_rtc_sys::GstWebRTCDataChannelState;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCDataChannelState {
        match *self {
            WebRTCDataChannelState::New => gst_web_rtc_sys::GST_WEBRTC_DATA_CHANNEL_STATE_NEW,
            WebRTCDataChannelState::Connecting => {
                gst_web_rtc_sys::GST_WEBRTC_DATA_CHANNEL_STATE_CONNECTING
            }
            WebRTCDataChannelState::Open => gst_web_rtc_sys::GST_WEBRTC_DATA_CHANNEL_STATE_OPEN,
            WebRTCDataChannelState::Closing => {
                gst_web_rtc_sys::GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING
            }
            WebRTCDataChannelState::Closed => gst_web_rtc_sys::GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED,
            WebRTCDataChannelState::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCDataChannelState> for WebRTCDataChannelState {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCDataChannelState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCDataChannelState::New,
            1 => WebRTCDataChannelState::Connecting,
            2 => WebRTCDataChannelState::Open,
            3 => WebRTCDataChannelState::Closing,
            4 => WebRTCDataChannelState::Closed,
            value => WebRTCDataChannelState::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl StaticType for WebRTCDataChannelState {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_data_channel_state_get_type()) }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebRTCDataChannelState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValue<'a> for WebRTCDataChannelState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl SetValue for WebRTCDataChannelState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_14_1", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCFECType {
    None,
    UlpRed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_14_1", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebRTCFECType {
    type GlibType = gst_web_rtc_sys::GstWebRTCFECType;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCFECType {
        match *self {
            WebRTCFECType::None => gst_web_rtc_sys::GST_WEBRTC_FEC_TYPE_NONE,
            WebRTCFECType::UlpRed => gst_web_rtc_sys::GST_WEBRTC_FEC_TYPE_ULP_RED,
            WebRTCFECType::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_14_1", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCFECType> for WebRTCFECType {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCFECType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCFECType::None,
            1 => WebRTCFECType::UlpRed,
            value => WebRTCFECType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_14_1", feature = "dox"))]
impl StaticType for WebRTCFECType {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_fec_type_get_type()) }
    }
}

#[cfg(any(feature = "v1_14_1", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebRTCFECType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_14_1", feature = "dox"))]
impl<'a> FromValue<'a> for WebRTCFECType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_14_1", feature = "dox"))]
impl SetValue for WebRTCFECType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCICEComponent {
    Rtp,
    Rtcp,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCICEComponent {
    type GlibType = gst_web_rtc_sys::GstWebRTCICEComponent;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCICEComponent {
        match *self {
            WebRTCICEComponent::Rtp => gst_web_rtc_sys::GST_WEBRTC_ICE_COMPONENT_RTP,
            WebRTCICEComponent::Rtcp => gst_web_rtc_sys::GST_WEBRTC_ICE_COMPONENT_RTCP,
            WebRTCICEComponent::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCICEComponent> for WebRTCICEComponent {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCICEComponent) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCICEComponent::Rtp,
            1 => WebRTCICEComponent::Rtcp,
            value => WebRTCICEComponent::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCICEComponent {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_ice_component_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCICEComponent {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCICEComponent {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCICEComponent {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCICEConnectionState {
    New,
    Checking,
    Connected,
    Completed,
    Failed,
    Disconnected,
    Closed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCICEConnectionState {
    type GlibType = gst_web_rtc_sys::GstWebRTCICEConnectionState;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCICEConnectionState {
        match *self {
            WebRTCICEConnectionState::New => gst_web_rtc_sys::GST_WEBRTC_ICE_CONNECTION_STATE_NEW,
            WebRTCICEConnectionState::Checking => {
                gst_web_rtc_sys::GST_WEBRTC_ICE_CONNECTION_STATE_CHECKING
            }
            WebRTCICEConnectionState::Connected => {
                gst_web_rtc_sys::GST_WEBRTC_ICE_CONNECTION_STATE_CONNECTED
            }
            WebRTCICEConnectionState::Completed => {
                gst_web_rtc_sys::GST_WEBRTC_ICE_CONNECTION_STATE_COMPLETED
            }
            WebRTCICEConnectionState::Failed => {
                gst_web_rtc_sys::GST_WEBRTC_ICE_CONNECTION_STATE_FAILED
            }
            WebRTCICEConnectionState::Disconnected => {
                gst_web_rtc_sys::GST_WEBRTC_ICE_CONNECTION_STATE_DISCONNECTED
            }
            WebRTCICEConnectionState::Closed => {
                gst_web_rtc_sys::GST_WEBRTC_ICE_CONNECTION_STATE_CLOSED
            }
            WebRTCICEConnectionState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCICEConnectionState> for WebRTCICEConnectionState {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCICEConnectionState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCICEConnectionState::New,
            1 => WebRTCICEConnectionState::Checking,
            2 => WebRTCICEConnectionState::Connected,
            3 => WebRTCICEConnectionState::Completed,
            4 => WebRTCICEConnectionState::Failed,
            5 => WebRTCICEConnectionState::Disconnected,
            6 => WebRTCICEConnectionState::Closed,
            value => WebRTCICEConnectionState::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCICEConnectionState {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_ice_connection_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCICEConnectionState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCICEConnectionState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCICEConnectionState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCICEGatheringState {
    New,
    Gathering,
    Complete,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCICEGatheringState {
    type GlibType = gst_web_rtc_sys::GstWebRTCICEGatheringState;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCICEGatheringState {
        match *self {
            WebRTCICEGatheringState::New => gst_web_rtc_sys::GST_WEBRTC_ICE_GATHERING_STATE_NEW,
            WebRTCICEGatheringState::Gathering => {
                gst_web_rtc_sys::GST_WEBRTC_ICE_GATHERING_STATE_GATHERING
            }
            WebRTCICEGatheringState::Complete => {
                gst_web_rtc_sys::GST_WEBRTC_ICE_GATHERING_STATE_COMPLETE
            }
            WebRTCICEGatheringState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCICEGatheringState> for WebRTCICEGatheringState {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCICEGatheringState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCICEGatheringState::New,
            1 => WebRTCICEGatheringState::Gathering,
            2 => WebRTCICEGatheringState::Complete,
            value => WebRTCICEGatheringState::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCICEGatheringState {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_ice_gathering_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCICEGatheringState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCICEGatheringState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCICEGatheringState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCICERole {
    Controlled,
    Controlling,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCICERole {
    type GlibType = gst_web_rtc_sys::GstWebRTCICERole;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCICERole {
        match *self {
            WebRTCICERole::Controlled => gst_web_rtc_sys::GST_WEBRTC_ICE_ROLE_CONTROLLED,
            WebRTCICERole::Controlling => gst_web_rtc_sys::GST_WEBRTC_ICE_ROLE_CONTROLLING,
            WebRTCICERole::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCICERole> for WebRTCICERole {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCICERole) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCICERole::Controlled,
            1 => WebRTCICERole::Controlling,
            value => WebRTCICERole::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCICERole {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_ice_role_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCICERole {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCICERole {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCICERole {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCICETransportPolicy {
    All,
    Relay,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebRTCICETransportPolicy {
    type GlibType = gst_web_rtc_sys::GstWebRTCICETransportPolicy;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCICETransportPolicy {
        match *self {
            WebRTCICETransportPolicy::All => gst_web_rtc_sys::GST_WEBRTC_ICE_TRANSPORT_POLICY_ALL,
            WebRTCICETransportPolicy::Relay => {
                gst_web_rtc_sys::GST_WEBRTC_ICE_TRANSPORT_POLICY_RELAY
            }
            WebRTCICETransportPolicy::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCICETransportPolicy> for WebRTCICETransportPolicy {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCICETransportPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCICETransportPolicy::All,
            1 => WebRTCICETransportPolicy::Relay,
            value => WebRTCICETransportPolicy::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl StaticType for WebRTCICETransportPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_ice_transport_policy_get_type()) }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebRTCICETransportPolicy {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValue<'a> for WebRTCICETransportPolicy {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl SetValue for WebRTCICETransportPolicy {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCPeerConnectionState {
    New,
    Connecting,
    Connected,
    Disconnected,
    Failed,
    Closed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCPeerConnectionState {
    type GlibType = gst_web_rtc_sys::GstWebRTCPeerConnectionState;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCPeerConnectionState {
        match *self {
            WebRTCPeerConnectionState::New => gst_web_rtc_sys::GST_WEBRTC_PEER_CONNECTION_STATE_NEW,
            WebRTCPeerConnectionState::Connecting => {
                gst_web_rtc_sys::GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTING
            }
            WebRTCPeerConnectionState::Connected => {
                gst_web_rtc_sys::GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTED
            }
            WebRTCPeerConnectionState::Disconnected => {
                gst_web_rtc_sys::GST_WEBRTC_PEER_CONNECTION_STATE_DISCONNECTED
            }
            WebRTCPeerConnectionState::Failed => {
                gst_web_rtc_sys::GST_WEBRTC_PEER_CONNECTION_STATE_FAILED
            }
            WebRTCPeerConnectionState::Closed => {
                gst_web_rtc_sys::GST_WEBRTC_PEER_CONNECTION_STATE_CLOSED
            }
            WebRTCPeerConnectionState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCPeerConnectionState> for WebRTCPeerConnectionState {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCPeerConnectionState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCPeerConnectionState::New,
            1 => WebRTCPeerConnectionState::Connecting,
            2 => WebRTCPeerConnectionState::Connected,
            3 => WebRTCPeerConnectionState::Disconnected,
            4 => WebRTCPeerConnectionState::Failed,
            5 => WebRTCPeerConnectionState::Closed,
            value => WebRTCPeerConnectionState::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCPeerConnectionState {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_peer_connection_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCPeerConnectionState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCPeerConnectionState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCPeerConnectionState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCPriorityType {
    VeryLow,
    Low,
    Medium,
    High,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebRTCPriorityType {
    type GlibType = gst_web_rtc_sys::GstWebRTCPriorityType;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCPriorityType {
        match *self {
            WebRTCPriorityType::VeryLow => gst_web_rtc_sys::GST_WEBRTC_PRIORITY_TYPE_VERY_LOW,
            WebRTCPriorityType::Low => gst_web_rtc_sys::GST_WEBRTC_PRIORITY_TYPE_LOW,
            WebRTCPriorityType::Medium => gst_web_rtc_sys::GST_WEBRTC_PRIORITY_TYPE_MEDIUM,
            WebRTCPriorityType::High => gst_web_rtc_sys::GST_WEBRTC_PRIORITY_TYPE_HIGH,
            WebRTCPriorityType::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCPriorityType> for WebRTCPriorityType {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCPriorityType) -> Self {
        skip_assert_initialized!();
        match value {
            1 => WebRTCPriorityType::VeryLow,
            2 => WebRTCPriorityType::Low,
            3 => WebRTCPriorityType::Medium,
            4 => WebRTCPriorityType::High,
            value => WebRTCPriorityType::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl StaticType for WebRTCPriorityType {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_priority_type_get_type()) }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebRTCPriorityType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValue<'a> for WebRTCPriorityType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl SetValue for WebRTCPriorityType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCRTPTransceiverDirection {
    None,
    Inactive,
    Sendonly,
    Recvonly,
    Sendrecv,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCRTPTransceiverDirection {
    type GlibType = gst_web_rtc_sys::GstWebRTCRTPTransceiverDirection;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCRTPTransceiverDirection {
        match *self {
            WebRTCRTPTransceiverDirection::None => {
                gst_web_rtc_sys::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE
            }
            WebRTCRTPTransceiverDirection::Inactive => {
                gst_web_rtc_sys::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_INACTIVE
            }
            WebRTCRTPTransceiverDirection::Sendonly => {
                gst_web_rtc_sys::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY
            }
            WebRTCRTPTransceiverDirection::Recvonly => {
                gst_web_rtc_sys::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY
            }
            WebRTCRTPTransceiverDirection::Sendrecv => {
                gst_web_rtc_sys::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV
            }
            WebRTCRTPTransceiverDirection::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCRTPTransceiverDirection> for WebRTCRTPTransceiverDirection {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCRTPTransceiverDirection) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCRTPTransceiverDirection::None,
            1 => WebRTCRTPTransceiverDirection::Inactive,
            2 => WebRTCRTPTransceiverDirection::Sendonly,
            3 => WebRTCRTPTransceiverDirection::Recvonly,
            4 => WebRTCRTPTransceiverDirection::Sendrecv,
            value => WebRTCRTPTransceiverDirection::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCRTPTransceiverDirection {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_rtp_transceiver_direction_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCRTPTransceiverDirection {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCRTPTransceiverDirection {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCRTPTransceiverDirection {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCSCTPTransportState {
    New,
    Connecting,
    Connected,
    Closed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for WebRTCSCTPTransportState {
    type GlibType = gst_web_rtc_sys::GstWebRTCSCTPTransportState;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCSCTPTransportState {
        match *self {
            WebRTCSCTPTransportState::New => gst_web_rtc_sys::GST_WEBRTC_SCTP_TRANSPORT_STATE_NEW,
            WebRTCSCTPTransportState::Connecting => {
                gst_web_rtc_sys::GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTING
            }
            WebRTCSCTPTransportState::Connected => {
                gst_web_rtc_sys::GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTED
            }
            WebRTCSCTPTransportState::Closed => {
                gst_web_rtc_sys::GST_WEBRTC_SCTP_TRANSPORT_STATE_CLOSED
            }
            WebRTCSCTPTransportState::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCSCTPTransportState> for WebRTCSCTPTransportState {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCSCTPTransportState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCSCTPTransportState::New,
            1 => WebRTCSCTPTransportState::Connecting,
            2 => WebRTCSCTPTransportState::Connected,
            3 => WebRTCSCTPTransportState::Closed,
            value => WebRTCSCTPTransportState::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl StaticType for WebRTCSCTPTransportState {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_sctp_transport_state_get_type()) }
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValueOptional<'a> for WebRTCSCTPTransportState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl<'a> FromValue<'a> for WebRTCSCTPTransportState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_16", feature = "dox"))]
impl SetValue for WebRTCSCTPTransportState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCSDPType {
    Offer,
    Pranswer,
    Answer,
    Rollback,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCSDPType {
    type GlibType = gst_web_rtc_sys::GstWebRTCSDPType;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCSDPType {
        match *self {
            WebRTCSDPType::Offer => gst_web_rtc_sys::GST_WEBRTC_SDP_TYPE_OFFER,
            WebRTCSDPType::Pranswer => gst_web_rtc_sys::GST_WEBRTC_SDP_TYPE_PRANSWER,
            WebRTCSDPType::Answer => gst_web_rtc_sys::GST_WEBRTC_SDP_TYPE_ANSWER,
            WebRTCSDPType::Rollback => gst_web_rtc_sys::GST_WEBRTC_SDP_TYPE_ROLLBACK,
            WebRTCSDPType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCSDPType> for WebRTCSDPType {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCSDPType) -> Self {
        skip_assert_initialized!();
        match value {
            1 => WebRTCSDPType::Offer,
            2 => WebRTCSDPType::Pranswer,
            3 => WebRTCSDPType::Answer,
            4 => WebRTCSDPType::Rollback,
            value => WebRTCSDPType::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCSDPType {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_sdp_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCSDPType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCSDPType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCSDPType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCSignalingState {
    Stable,
    Closed,
    HaveLocalOffer,
    HaveRemoteOffer,
    HaveLocalPranswer,
    HaveRemotePranswer,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCSignalingState {
    type GlibType = gst_web_rtc_sys::GstWebRTCSignalingState;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCSignalingState {
        match *self {
            WebRTCSignalingState::Stable => gst_web_rtc_sys::GST_WEBRTC_SIGNALING_STATE_STABLE,
            WebRTCSignalingState::Closed => gst_web_rtc_sys::GST_WEBRTC_SIGNALING_STATE_CLOSED,
            WebRTCSignalingState::HaveLocalOffer => {
                gst_web_rtc_sys::GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_OFFER
            }
            WebRTCSignalingState::HaveRemoteOffer => {
                gst_web_rtc_sys::GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_OFFER
            }
            WebRTCSignalingState::HaveLocalPranswer => {
                gst_web_rtc_sys::GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_PRANSWER
            }
            WebRTCSignalingState::HaveRemotePranswer => {
                gst_web_rtc_sys::GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_PRANSWER
            }
            WebRTCSignalingState::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCSignalingState> for WebRTCSignalingState {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCSignalingState) -> Self {
        skip_assert_initialized!();
        match value {
            0 => WebRTCSignalingState::Stable,
            1 => WebRTCSignalingState::Closed,
            2 => WebRTCSignalingState::HaveLocalOffer,
            3 => WebRTCSignalingState::HaveRemoteOffer,
            4 => WebRTCSignalingState::HaveLocalPranswer,
            5 => WebRTCSignalingState::HaveRemotePranswer,
            value => WebRTCSignalingState::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCSignalingState {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_signaling_state_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCSignalingState {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCSignalingState {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCSignalingState {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
pub enum WebRTCStatsType {
    Codec,
    InboundRtp,
    OutboundRtp,
    RemoteInboundRtp,
    RemoteOutboundRtp,
    Csrc,
    PeerConnection,
    DataChannel,
    Stream,
    Transport,
    CandidatePair,
    LocalCandidate,
    RemoteCandidate,
    Certificate,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl ToGlib for WebRTCStatsType {
    type GlibType = gst_web_rtc_sys::GstWebRTCStatsType;

    fn to_glib(&self) -> gst_web_rtc_sys::GstWebRTCStatsType {
        match *self {
            WebRTCStatsType::Codec => gst_web_rtc_sys::GST_WEBRTC_STATS_CODEC,
            WebRTCStatsType::InboundRtp => gst_web_rtc_sys::GST_WEBRTC_STATS_INBOUND_RTP,
            WebRTCStatsType::OutboundRtp => gst_web_rtc_sys::GST_WEBRTC_STATS_OUTBOUND_RTP,
            WebRTCStatsType::RemoteInboundRtp => {
                gst_web_rtc_sys::GST_WEBRTC_STATS_REMOTE_INBOUND_RTP
            }
            WebRTCStatsType::RemoteOutboundRtp => {
                gst_web_rtc_sys::GST_WEBRTC_STATS_REMOTE_OUTBOUND_RTP
            }
            WebRTCStatsType::Csrc => gst_web_rtc_sys::GST_WEBRTC_STATS_CSRC,
            WebRTCStatsType::PeerConnection => gst_web_rtc_sys::GST_WEBRTC_STATS_PEER_CONNECTION,
            WebRTCStatsType::DataChannel => gst_web_rtc_sys::GST_WEBRTC_STATS_DATA_CHANNEL,
            WebRTCStatsType::Stream => gst_web_rtc_sys::GST_WEBRTC_STATS_STREAM,
            WebRTCStatsType::Transport => gst_web_rtc_sys::GST_WEBRTC_STATS_TRANSPORT,
            WebRTCStatsType::CandidatePair => gst_web_rtc_sys::GST_WEBRTC_STATS_CANDIDATE_PAIR,
            WebRTCStatsType::LocalCandidate => gst_web_rtc_sys::GST_WEBRTC_STATS_LOCAL_CANDIDATE,
            WebRTCStatsType::RemoteCandidate => gst_web_rtc_sys::GST_WEBRTC_STATS_REMOTE_CANDIDATE,
            WebRTCStatsType::Certificate => gst_web_rtc_sys::GST_WEBRTC_STATS_CERTIFICATE,
            WebRTCStatsType::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<gst_web_rtc_sys::GstWebRTCStatsType> for WebRTCStatsType {
    fn from_glib(value: gst_web_rtc_sys::GstWebRTCStatsType) -> Self {
        skip_assert_initialized!();
        match value {
            1 => WebRTCStatsType::Codec,
            2 => WebRTCStatsType::InboundRtp,
            3 => WebRTCStatsType::OutboundRtp,
            4 => WebRTCStatsType::RemoteInboundRtp,
            5 => WebRTCStatsType::RemoteOutboundRtp,
            6 => WebRTCStatsType::Csrc,
            7 => WebRTCStatsType::PeerConnection,
            8 => WebRTCStatsType::DataChannel,
            9 => WebRTCStatsType::Stream,
            10 => WebRTCStatsType::Transport,
            11 => WebRTCStatsType::CandidatePair,
            12 => WebRTCStatsType::LocalCandidate,
            13 => WebRTCStatsType::RemoteCandidate,
            14 => WebRTCStatsType::Certificate,
            value => WebRTCStatsType::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCStatsType {
    fn static_type() -> Type {
        unsafe { from_glib(gst_web_rtc_sys::gst_webrtc_stats_type_get_type()) }
    }
}

impl<'a> FromValueOptional<'a> for WebRTCStatsType {
    unsafe fn from_value_optional(value: &Value) -> Option<Self> {
        Some(FromValue::from_value(value))
    }
}

impl<'a> FromValue<'a> for WebRTCStatsType {
    unsafe fn from_value(value: &Value) -> Self {
        from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
    }
}

impl SetValue for WebRTCStatsType {
    unsafe fn set_value(value: &mut Value, this: &Self) {
        gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
    }
}
