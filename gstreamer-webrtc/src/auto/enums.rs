// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// from gst-gir-files (https://gitlab.freedesktop.org/gstreamer/gir-files-rs.git)
// DO NOT EDIT

use glib::{prelude::*, translate::*, GStr};
use std::fmt;

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCBundlePolicy")]
pub enum WebRTCBundlePolicy {
    #[doc(alias = "GST_WEBRTC_BUNDLE_POLICY_NONE")]
    None,
    #[doc(alias = "GST_WEBRTC_BUNDLE_POLICY_BALANCED")]
    Balanced,
    #[doc(alias = "GST_WEBRTC_BUNDLE_POLICY_MAX_COMPAT")]
    MaxCompat,
    #[doc(alias = "GST_WEBRTC_BUNDLE_POLICY_MAX_BUNDLE")]
    MaxBundle,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl IntoGlib for WebRTCBundlePolicy {
    type GlibType = ffi::GstWebRTCBundlePolicy;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCBundlePolicy {
        match self {
            Self::None => ffi::GST_WEBRTC_BUNDLE_POLICY_NONE,
            Self::Balanced => ffi::GST_WEBRTC_BUNDLE_POLICY_BALANCED,
            Self::MaxCompat => ffi::GST_WEBRTC_BUNDLE_POLICY_MAX_COMPAT,
            Self::MaxBundle => ffi::GST_WEBRTC_BUNDLE_POLICY_MAX_BUNDLE,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCBundlePolicy> for WebRTCBundlePolicy {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCBundlePolicy) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_BUNDLE_POLICY_NONE => Self::None,
            ffi::GST_WEBRTC_BUNDLE_POLICY_BALANCED => Self::Balanced,
            ffi::GST_WEBRTC_BUNDLE_POLICY_MAX_COMPAT => Self::MaxCompat,
            ffi::GST_WEBRTC_BUNDLE_POLICY_MAX_BUNDLE => Self::MaxBundle,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl StaticType for WebRTCBundlePolicy {
    #[inline]
    #[doc(alias = "gst_webrtc_bundle_policy_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_bundle_policy_get_type()) }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::HasParamSpec for WebRTCBundlePolicy {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::value::ValueType for WebRTCBundlePolicy {
    type Type = Self;
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
unsafe impl<'a> glib::value::FromValue<'a> for WebRTCBundlePolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl ToValue for WebRTCBundlePolicy {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl From<WebRTCBundlePolicy> for glib::Value {
    #[inline]
    fn from(v: WebRTCBundlePolicy) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCDTLSSetup")]
pub enum WebRTCDTLSSetup {
    #[doc(alias = "GST_WEBRTC_DTLS_SETUP_NONE")]
    None,
    #[doc(alias = "GST_WEBRTC_DTLS_SETUP_ACTPASS")]
    Actpass,
    #[doc(alias = "GST_WEBRTC_DTLS_SETUP_ACTIVE")]
    Active,
    #[doc(alias = "GST_WEBRTC_DTLS_SETUP_PASSIVE")]
    Passive,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCDTLSSetup {
    type GlibType = ffi::GstWebRTCDTLSSetup;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCDTLSSetup {
        match self {
            Self::None => ffi::GST_WEBRTC_DTLS_SETUP_NONE,
            Self::Actpass => ffi::GST_WEBRTC_DTLS_SETUP_ACTPASS,
            Self::Active => ffi::GST_WEBRTC_DTLS_SETUP_ACTIVE,
            Self::Passive => ffi::GST_WEBRTC_DTLS_SETUP_PASSIVE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCDTLSSetup> for WebRTCDTLSSetup {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCDTLSSetup) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_DTLS_SETUP_NONE => Self::None,
            ffi::GST_WEBRTC_DTLS_SETUP_ACTPASS => Self::Actpass,
            ffi::GST_WEBRTC_DTLS_SETUP_ACTIVE => Self::Active,
            ffi::GST_WEBRTC_DTLS_SETUP_PASSIVE => Self::Passive,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCDTLSSetup {
    #[inline]
    #[doc(alias = "gst_webrtc_dtls_setup_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_dtls_setup_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCDTLSSetup {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCDTLSSetup {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCDTLSSetup {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCDTLSSetup {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCDTLSSetup> for glib::Value {
    #[inline]
    fn from(v: WebRTCDTLSSetup) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCDTLSTransportState")]
pub enum WebRTCDTLSTransportState {
    #[doc(alias = "GST_WEBRTC_DTLS_TRANSPORT_STATE_NEW")]
    New,
    #[doc(alias = "GST_WEBRTC_DTLS_TRANSPORT_STATE_CLOSED")]
    Closed,
    #[doc(alias = "GST_WEBRTC_DTLS_TRANSPORT_STATE_FAILED")]
    Failed,
    #[doc(alias = "GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTING")]
    Connecting,
    #[doc(alias = "GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTED")]
    Connected,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCDTLSTransportState {
    type GlibType = ffi::GstWebRTCDTLSTransportState;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCDTLSTransportState {
        match self {
            Self::New => ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_NEW,
            Self::Closed => ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_CLOSED,
            Self::Failed => ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_FAILED,
            Self::Connecting => ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTING,
            Self::Connected => ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCDTLSTransportState> for WebRTCDTLSTransportState {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCDTLSTransportState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_NEW => Self::New,
            ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_CLOSED => Self::Closed,
            ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_FAILED => Self::Failed,
            ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTING => Self::Connecting,
            ffi::GST_WEBRTC_DTLS_TRANSPORT_STATE_CONNECTED => Self::Connected,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCDTLSTransportState {
    #[inline]
    #[doc(alias = "gst_webrtc_dtls_transport_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_dtls_transport_state_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCDTLSTransportState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCDTLSTransportState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCDTLSTransportState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCDTLSTransportState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCDTLSTransportState> for glib::Value {
    #[inline]
    fn from(v: WebRTCDTLSTransportState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCDataChannelState")]
pub enum WebRTCDataChannelState {
    #[doc(alias = "GST_WEBRTC_DATA_CHANNEL_STATE_CONNECTING")]
    Connecting,
    #[doc(alias = "GST_WEBRTC_DATA_CHANNEL_STATE_OPEN")]
    Open,
    #[doc(alias = "GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING")]
    Closing,
    #[doc(alias = "GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED")]
    Closed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl IntoGlib for WebRTCDataChannelState {
    type GlibType = ffi::GstWebRTCDataChannelState;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCDataChannelState {
        match self {
            Self::Connecting => ffi::GST_WEBRTC_DATA_CHANNEL_STATE_CONNECTING,
            Self::Open => ffi::GST_WEBRTC_DATA_CHANNEL_STATE_OPEN,
            Self::Closing => ffi::GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING,
            Self::Closed => ffi::GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCDataChannelState> for WebRTCDataChannelState {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCDataChannelState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_DATA_CHANNEL_STATE_CONNECTING => Self::Connecting,
            ffi::GST_WEBRTC_DATA_CHANNEL_STATE_OPEN => Self::Open,
            ffi::GST_WEBRTC_DATA_CHANNEL_STATE_CLOSING => Self::Closing,
            ffi::GST_WEBRTC_DATA_CHANNEL_STATE_CLOSED => Self::Closed,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl StaticType for WebRTCDataChannelState {
    #[inline]
    #[doc(alias = "gst_webrtc_data_channel_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_data_channel_state_get_type()) }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::HasParamSpec for WebRTCDataChannelState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::value::ValueType for WebRTCDataChannelState {
    type Type = Self;
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
unsafe impl<'a> glib::value::FromValue<'a> for WebRTCDataChannelState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl ToValue for WebRTCDataChannelState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl From<WebRTCDataChannelState> for glib::Value {
    #[inline]
    fn from(v: WebRTCDataChannelState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCError")]
pub enum WebRTCError {
    #[doc(alias = "GST_WEBRTC_ERROR_DATA_CHANNEL_FAILURE")]
    DataChannelFailure,
    #[doc(alias = "GST_WEBRTC_ERROR_DTLS_FAILURE")]
    DtlsFailure,
    #[doc(alias = "GST_WEBRTC_ERROR_FINGERPRINT_FAILURE")]
    FingerprintFailure,
    #[doc(alias = "GST_WEBRTC_ERROR_SCTP_FAILURE")]
    SctpFailure,
    #[doc(alias = "GST_WEBRTC_ERROR_SDP_SYNTAX_ERROR")]
    SdpSyntaxError,
    #[doc(alias = "GST_WEBRTC_ERROR_HARDWARE_ENCODER_NOT_AVAILABLE")]
    HardwareEncoderNotAvailable,
    #[doc(alias = "GST_WEBRTC_ERROR_ENCODER_ERROR")]
    EncoderError,
    #[doc(alias = "GST_WEBRTC_ERROR_INVALID_STATE")]
    InvalidState,
    #[doc(alias = "GST_WEBRTC_ERROR_INTERNAL_FAILURE")]
    InternalFailure,
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[doc(alias = "GST_WEBRTC_ERROR_INVALID_MODIFICATION")]
    InvalidModification,
    #[cfg(feature = "v1_22")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_22")))]
    #[doc(alias = "GST_WEBRTC_ERROR_TYPE_ERROR")]
    TypeError,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl IntoGlib for WebRTCError {
    type GlibType = ffi::GstWebRTCError;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCError {
        match self {
            Self::DataChannelFailure => ffi::GST_WEBRTC_ERROR_DATA_CHANNEL_FAILURE,
            Self::DtlsFailure => ffi::GST_WEBRTC_ERROR_DTLS_FAILURE,
            Self::FingerprintFailure => ffi::GST_WEBRTC_ERROR_FINGERPRINT_FAILURE,
            Self::SctpFailure => ffi::GST_WEBRTC_ERROR_SCTP_FAILURE,
            Self::SdpSyntaxError => ffi::GST_WEBRTC_ERROR_SDP_SYNTAX_ERROR,
            Self::HardwareEncoderNotAvailable => {
                ffi::GST_WEBRTC_ERROR_HARDWARE_ENCODER_NOT_AVAILABLE
            }
            Self::EncoderError => ffi::GST_WEBRTC_ERROR_ENCODER_ERROR,
            Self::InvalidState => ffi::GST_WEBRTC_ERROR_INVALID_STATE,
            Self::InternalFailure => ffi::GST_WEBRTC_ERROR_INTERNAL_FAILURE,
            #[cfg(feature = "v1_22")]
            Self::InvalidModification => ffi::GST_WEBRTC_ERROR_INVALID_MODIFICATION,
            #[cfg(feature = "v1_22")]
            Self::TypeError => ffi::GST_WEBRTC_ERROR_TYPE_ERROR,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCError> for WebRTCError {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_ERROR_DATA_CHANNEL_FAILURE => Self::DataChannelFailure,
            ffi::GST_WEBRTC_ERROR_DTLS_FAILURE => Self::DtlsFailure,
            ffi::GST_WEBRTC_ERROR_FINGERPRINT_FAILURE => Self::FingerprintFailure,
            ffi::GST_WEBRTC_ERROR_SCTP_FAILURE => Self::SctpFailure,
            ffi::GST_WEBRTC_ERROR_SDP_SYNTAX_ERROR => Self::SdpSyntaxError,
            ffi::GST_WEBRTC_ERROR_HARDWARE_ENCODER_NOT_AVAILABLE => {
                Self::HardwareEncoderNotAvailable
            }
            ffi::GST_WEBRTC_ERROR_ENCODER_ERROR => Self::EncoderError,
            ffi::GST_WEBRTC_ERROR_INVALID_STATE => Self::InvalidState,
            ffi::GST_WEBRTC_ERROR_INTERNAL_FAILURE => Self::InternalFailure,
            #[cfg(feature = "v1_22")]
            ffi::GST_WEBRTC_ERROR_INVALID_MODIFICATION => Self::InvalidModification,
            #[cfg(feature = "v1_22")]
            ffi::GST_WEBRTC_ERROR_TYPE_ERROR => Self::TypeError,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::error::ErrorDomain for WebRTCError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::gst_webrtc_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            value => Some(value),
        }
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl StaticType for WebRTCError {
    #[inline]
    #[doc(alias = "gst_webrtc_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_error_get_type()) }
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::HasParamSpec for WebRTCError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::value::ValueType for WebRTCError {
    type Type = Self;
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
unsafe impl<'a> glib::value::FromValue<'a> for WebRTCError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl ToValue for WebRTCError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl From<WebRTCError> for glib::Value {
    #[inline]
    fn from(v: WebRTCError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_14_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14_1")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCFECType")]
pub enum WebRTCFECType {
    #[doc(alias = "GST_WEBRTC_FEC_TYPE_NONE")]
    None,
    #[doc(alias = "GST_WEBRTC_FEC_TYPE_ULP_RED")]
    UlpRed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_14_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14_1")))]
#[doc(hidden)]
impl IntoGlib for WebRTCFECType {
    type GlibType = ffi::GstWebRTCFECType;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCFECType {
        match self {
            Self::None => ffi::GST_WEBRTC_FEC_TYPE_NONE,
            Self::UlpRed => ffi::GST_WEBRTC_FEC_TYPE_ULP_RED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_14_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14_1")))]
#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCFECType> for WebRTCFECType {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCFECType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_FEC_TYPE_NONE => Self::None,
            ffi::GST_WEBRTC_FEC_TYPE_ULP_RED => Self::UlpRed,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_14_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14_1")))]
impl StaticType for WebRTCFECType {
    #[inline]
    #[doc(alias = "gst_webrtc_fec_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_fec_type_get_type()) }
    }
}

#[cfg(feature = "v1_14_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14_1")))]
impl glib::HasParamSpec for WebRTCFECType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_14_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14_1")))]
impl glib::value::ValueType for WebRTCFECType {
    type Type = Self;
}

#[cfg(feature = "v1_14_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14_1")))]
unsafe impl<'a> glib::value::FromValue<'a> for WebRTCFECType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_14_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14_1")))]
impl ToValue for WebRTCFECType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_14_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_14_1")))]
impl From<WebRTCFECType> for glib::Value {
    #[inline]
    fn from(v: WebRTCFECType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCICEComponent")]
pub enum WebRTCICEComponent {
    #[doc(alias = "GST_WEBRTC_ICE_COMPONENT_RTP")]
    Rtp,
    #[doc(alias = "GST_WEBRTC_ICE_COMPONENT_RTCP")]
    Rtcp,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCICEComponent {
    type GlibType = ffi::GstWebRTCICEComponent;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCICEComponent {
        match self {
            Self::Rtp => ffi::GST_WEBRTC_ICE_COMPONENT_RTP,
            Self::Rtcp => ffi::GST_WEBRTC_ICE_COMPONENT_RTCP,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCICEComponent> for WebRTCICEComponent {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCICEComponent) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_ICE_COMPONENT_RTP => Self::Rtp,
            ffi::GST_WEBRTC_ICE_COMPONENT_RTCP => Self::Rtcp,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCICEComponent {
    #[inline]
    #[doc(alias = "gst_webrtc_ice_component_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_ice_component_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCICEComponent {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCICEComponent {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCICEComponent {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCICEComponent {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCICEComponent> for glib::Value {
    #[inline]
    fn from(v: WebRTCICEComponent) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCICEConnectionState")]
pub enum WebRTCICEConnectionState {
    #[doc(alias = "GST_WEBRTC_ICE_CONNECTION_STATE_NEW")]
    New,
    #[doc(alias = "GST_WEBRTC_ICE_CONNECTION_STATE_CHECKING")]
    Checking,
    #[doc(alias = "GST_WEBRTC_ICE_CONNECTION_STATE_CONNECTED")]
    Connected,
    #[doc(alias = "GST_WEBRTC_ICE_CONNECTION_STATE_COMPLETED")]
    Completed,
    #[doc(alias = "GST_WEBRTC_ICE_CONNECTION_STATE_FAILED")]
    Failed,
    #[doc(alias = "GST_WEBRTC_ICE_CONNECTION_STATE_DISCONNECTED")]
    Disconnected,
    #[doc(alias = "GST_WEBRTC_ICE_CONNECTION_STATE_CLOSED")]
    Closed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCICEConnectionState {
    type GlibType = ffi::GstWebRTCICEConnectionState;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCICEConnectionState {
        match self {
            Self::New => ffi::GST_WEBRTC_ICE_CONNECTION_STATE_NEW,
            Self::Checking => ffi::GST_WEBRTC_ICE_CONNECTION_STATE_CHECKING,
            Self::Connected => ffi::GST_WEBRTC_ICE_CONNECTION_STATE_CONNECTED,
            Self::Completed => ffi::GST_WEBRTC_ICE_CONNECTION_STATE_COMPLETED,
            Self::Failed => ffi::GST_WEBRTC_ICE_CONNECTION_STATE_FAILED,
            Self::Disconnected => ffi::GST_WEBRTC_ICE_CONNECTION_STATE_DISCONNECTED,
            Self::Closed => ffi::GST_WEBRTC_ICE_CONNECTION_STATE_CLOSED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCICEConnectionState> for WebRTCICEConnectionState {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCICEConnectionState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_ICE_CONNECTION_STATE_NEW => Self::New,
            ffi::GST_WEBRTC_ICE_CONNECTION_STATE_CHECKING => Self::Checking,
            ffi::GST_WEBRTC_ICE_CONNECTION_STATE_CONNECTED => Self::Connected,
            ffi::GST_WEBRTC_ICE_CONNECTION_STATE_COMPLETED => Self::Completed,
            ffi::GST_WEBRTC_ICE_CONNECTION_STATE_FAILED => Self::Failed,
            ffi::GST_WEBRTC_ICE_CONNECTION_STATE_DISCONNECTED => Self::Disconnected,
            ffi::GST_WEBRTC_ICE_CONNECTION_STATE_CLOSED => Self::Closed,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCICEConnectionState {
    #[inline]
    #[doc(alias = "gst_webrtc_ice_connection_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_ice_connection_state_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCICEConnectionState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCICEConnectionState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCICEConnectionState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCICEConnectionState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCICEConnectionState> for glib::Value {
    #[inline]
    fn from(v: WebRTCICEConnectionState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCICEGatheringState")]
pub enum WebRTCICEGatheringState {
    #[doc(alias = "GST_WEBRTC_ICE_GATHERING_STATE_NEW")]
    New,
    #[doc(alias = "GST_WEBRTC_ICE_GATHERING_STATE_GATHERING")]
    Gathering,
    #[doc(alias = "GST_WEBRTC_ICE_GATHERING_STATE_COMPLETE")]
    Complete,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCICEGatheringState {
    type GlibType = ffi::GstWebRTCICEGatheringState;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCICEGatheringState {
        match self {
            Self::New => ffi::GST_WEBRTC_ICE_GATHERING_STATE_NEW,
            Self::Gathering => ffi::GST_WEBRTC_ICE_GATHERING_STATE_GATHERING,
            Self::Complete => ffi::GST_WEBRTC_ICE_GATHERING_STATE_COMPLETE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCICEGatheringState> for WebRTCICEGatheringState {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCICEGatheringState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_ICE_GATHERING_STATE_NEW => Self::New,
            ffi::GST_WEBRTC_ICE_GATHERING_STATE_GATHERING => Self::Gathering,
            ffi::GST_WEBRTC_ICE_GATHERING_STATE_COMPLETE => Self::Complete,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCICEGatheringState {
    #[inline]
    #[doc(alias = "gst_webrtc_ice_gathering_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_ice_gathering_state_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCICEGatheringState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCICEGatheringState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCICEGatheringState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCICEGatheringState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCICEGatheringState> for glib::Value {
    #[inline]
    fn from(v: WebRTCICEGatheringState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCICERole")]
pub enum WebRTCICERole {
    #[doc(alias = "GST_WEBRTC_ICE_ROLE_CONTROLLED")]
    Controlled,
    #[doc(alias = "GST_WEBRTC_ICE_ROLE_CONTROLLING")]
    Controlling,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCICERole {
    type GlibType = ffi::GstWebRTCICERole;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCICERole {
        match self {
            Self::Controlled => ffi::GST_WEBRTC_ICE_ROLE_CONTROLLED,
            Self::Controlling => ffi::GST_WEBRTC_ICE_ROLE_CONTROLLING,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCICERole> for WebRTCICERole {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCICERole) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_ICE_ROLE_CONTROLLED => Self::Controlled,
            ffi::GST_WEBRTC_ICE_ROLE_CONTROLLING => Self::Controlling,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCICERole {
    #[inline]
    #[doc(alias = "gst_webrtc_ice_role_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_ice_role_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCICERole {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCICERole {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCICERole {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCICERole {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCICERole> for glib::Value {
    #[inline]
    fn from(v: WebRTCICERole) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCICETransportPolicy")]
pub enum WebRTCICETransportPolicy {
    #[doc(alias = "GST_WEBRTC_ICE_TRANSPORT_POLICY_ALL")]
    All,
    #[doc(alias = "GST_WEBRTC_ICE_TRANSPORT_POLICY_RELAY")]
    Relay,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl IntoGlib for WebRTCICETransportPolicy {
    type GlibType = ffi::GstWebRTCICETransportPolicy;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCICETransportPolicy {
        match self {
            Self::All => ffi::GST_WEBRTC_ICE_TRANSPORT_POLICY_ALL,
            Self::Relay => ffi::GST_WEBRTC_ICE_TRANSPORT_POLICY_RELAY,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCICETransportPolicy> for WebRTCICETransportPolicy {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCICETransportPolicy) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_ICE_TRANSPORT_POLICY_ALL => Self::All,
            ffi::GST_WEBRTC_ICE_TRANSPORT_POLICY_RELAY => Self::Relay,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl StaticType for WebRTCICETransportPolicy {
    #[inline]
    #[doc(alias = "gst_webrtc_ice_transport_policy_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_ice_transport_policy_get_type()) }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::HasParamSpec for WebRTCICETransportPolicy {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::value::ValueType for WebRTCICETransportPolicy {
    type Type = Self;
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
unsafe impl<'a> glib::value::FromValue<'a> for WebRTCICETransportPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl ToValue for WebRTCICETransportPolicy {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl From<WebRTCICETransportPolicy> for glib::Value {
    #[inline]
    fn from(v: WebRTCICETransportPolicy) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCKind")]
pub enum WebRTCKind {
    #[doc(alias = "GST_WEBRTC_KIND_UNKNOWN")]
    Unknown,
    #[doc(alias = "GST_WEBRTC_KIND_AUDIO")]
    Audio,
    #[doc(alias = "GST_WEBRTC_KIND_VIDEO")]
    Video,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl IntoGlib for WebRTCKind {
    type GlibType = ffi::GstWebRTCKind;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCKind {
        match self {
            Self::Unknown => ffi::GST_WEBRTC_KIND_UNKNOWN,
            Self::Audio => ffi::GST_WEBRTC_KIND_AUDIO,
            Self::Video => ffi::GST_WEBRTC_KIND_VIDEO,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCKind> for WebRTCKind {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCKind) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_KIND_UNKNOWN => Self::Unknown,
            ffi::GST_WEBRTC_KIND_AUDIO => Self::Audio,
            ffi::GST_WEBRTC_KIND_VIDEO => Self::Video,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl StaticType for WebRTCKind {
    #[inline]
    #[doc(alias = "gst_webrtc_kind_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_kind_get_type()) }
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::HasParamSpec for WebRTCKind {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::value::ValueType for WebRTCKind {
    type Type = Self;
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
unsafe impl<'a> glib::value::FromValue<'a> for WebRTCKind {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl ToValue for WebRTCKind {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl From<WebRTCKind> for glib::Value {
    #[inline]
    fn from(v: WebRTCKind) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCPeerConnectionState")]
pub enum WebRTCPeerConnectionState {
    #[doc(alias = "GST_WEBRTC_PEER_CONNECTION_STATE_NEW")]
    New,
    #[doc(alias = "GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTING")]
    Connecting,
    #[doc(alias = "GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTED")]
    Connected,
    #[doc(alias = "GST_WEBRTC_PEER_CONNECTION_STATE_DISCONNECTED")]
    Disconnected,
    #[doc(alias = "GST_WEBRTC_PEER_CONNECTION_STATE_FAILED")]
    Failed,
    #[doc(alias = "GST_WEBRTC_PEER_CONNECTION_STATE_CLOSED")]
    Closed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCPeerConnectionState {
    type GlibType = ffi::GstWebRTCPeerConnectionState;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCPeerConnectionState {
        match self {
            Self::New => ffi::GST_WEBRTC_PEER_CONNECTION_STATE_NEW,
            Self::Connecting => ffi::GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTING,
            Self::Connected => ffi::GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTED,
            Self::Disconnected => ffi::GST_WEBRTC_PEER_CONNECTION_STATE_DISCONNECTED,
            Self::Failed => ffi::GST_WEBRTC_PEER_CONNECTION_STATE_FAILED,
            Self::Closed => ffi::GST_WEBRTC_PEER_CONNECTION_STATE_CLOSED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCPeerConnectionState> for WebRTCPeerConnectionState {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCPeerConnectionState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_PEER_CONNECTION_STATE_NEW => Self::New,
            ffi::GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTING => Self::Connecting,
            ffi::GST_WEBRTC_PEER_CONNECTION_STATE_CONNECTED => Self::Connected,
            ffi::GST_WEBRTC_PEER_CONNECTION_STATE_DISCONNECTED => Self::Disconnected,
            ffi::GST_WEBRTC_PEER_CONNECTION_STATE_FAILED => Self::Failed,
            ffi::GST_WEBRTC_PEER_CONNECTION_STATE_CLOSED => Self::Closed,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCPeerConnectionState {
    #[inline]
    #[doc(alias = "gst_webrtc_peer_connection_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_peer_connection_state_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCPeerConnectionState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCPeerConnectionState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCPeerConnectionState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCPeerConnectionState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCPeerConnectionState> for glib::Value {
    #[inline]
    fn from(v: WebRTCPeerConnectionState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCPriorityType")]
pub enum WebRTCPriorityType {
    #[doc(alias = "GST_WEBRTC_PRIORITY_TYPE_VERY_LOW")]
    VeryLow,
    #[doc(alias = "GST_WEBRTC_PRIORITY_TYPE_LOW")]
    Low,
    #[doc(alias = "GST_WEBRTC_PRIORITY_TYPE_MEDIUM")]
    Medium,
    #[doc(alias = "GST_WEBRTC_PRIORITY_TYPE_HIGH")]
    High,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl IntoGlib for WebRTCPriorityType {
    type GlibType = ffi::GstWebRTCPriorityType;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCPriorityType {
        match self {
            Self::VeryLow => ffi::GST_WEBRTC_PRIORITY_TYPE_VERY_LOW,
            Self::Low => ffi::GST_WEBRTC_PRIORITY_TYPE_LOW,
            Self::Medium => ffi::GST_WEBRTC_PRIORITY_TYPE_MEDIUM,
            Self::High => ffi::GST_WEBRTC_PRIORITY_TYPE_HIGH,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCPriorityType> for WebRTCPriorityType {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCPriorityType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_PRIORITY_TYPE_VERY_LOW => Self::VeryLow,
            ffi::GST_WEBRTC_PRIORITY_TYPE_LOW => Self::Low,
            ffi::GST_WEBRTC_PRIORITY_TYPE_MEDIUM => Self::Medium,
            ffi::GST_WEBRTC_PRIORITY_TYPE_HIGH => Self::High,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl StaticType for WebRTCPriorityType {
    #[inline]
    #[doc(alias = "gst_webrtc_priority_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_priority_type_get_type()) }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::HasParamSpec for WebRTCPriorityType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::value::ValueType for WebRTCPriorityType {
    type Type = Self;
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
unsafe impl<'a> glib::value::FromValue<'a> for WebRTCPriorityType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl ToValue for WebRTCPriorityType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl From<WebRTCPriorityType> for glib::Value {
    #[inline]
    fn from(v: WebRTCPriorityType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCRTPTransceiverDirection")]
pub enum WebRTCRTPTransceiverDirection {
    #[doc(alias = "GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE")]
    None,
    #[doc(alias = "GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_INACTIVE")]
    Inactive,
    #[doc(alias = "GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY")]
    Sendonly,
    #[doc(alias = "GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY")]
    Recvonly,
    #[doc(alias = "GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV")]
    Sendrecv,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCRTPTransceiverDirection {
    type GlibType = ffi::GstWebRTCRTPTransceiverDirection;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCRTPTransceiverDirection {
        match self {
            Self::None => ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE,
            Self::Inactive => ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_INACTIVE,
            Self::Sendonly => ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY,
            Self::Recvonly => ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY,
            Self::Sendrecv => ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCRTPTransceiverDirection> for WebRTCRTPTransceiverDirection {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCRTPTransceiverDirection) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_NONE => Self::None,
            ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_INACTIVE => Self::Inactive,
            ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDONLY => Self::Sendonly,
            ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_RECVONLY => Self::Recvonly,
            ffi::GST_WEBRTC_RTP_TRANSCEIVER_DIRECTION_SENDRECV => Self::Sendrecv,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCRTPTransceiverDirection {
    #[inline]
    #[doc(alias = "gst_webrtc_rtp_transceiver_direction_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_rtp_transceiver_direction_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCRTPTransceiverDirection {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCRTPTransceiverDirection {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCRTPTransceiverDirection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCRTPTransceiverDirection {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCRTPTransceiverDirection> for glib::Value {
    #[inline]
    fn from(v: WebRTCRTPTransceiverDirection) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCSCTPTransportState")]
pub enum WebRTCSCTPTransportState {
    #[doc(alias = "GST_WEBRTC_SCTP_TRANSPORT_STATE_NEW")]
    New,
    #[doc(alias = "GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTING")]
    Connecting,
    #[doc(alias = "GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTED")]
    Connected,
    #[doc(alias = "GST_WEBRTC_SCTP_TRANSPORT_STATE_CLOSED")]
    Closed,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl IntoGlib for WebRTCSCTPTransportState {
    type GlibType = ffi::GstWebRTCSCTPTransportState;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCSCTPTransportState {
        match self {
            Self::New => ffi::GST_WEBRTC_SCTP_TRANSPORT_STATE_NEW,
            Self::Connecting => ffi::GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTING,
            Self::Connected => ffi::GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTED,
            Self::Closed => ffi::GST_WEBRTC_SCTP_TRANSPORT_STATE_CLOSED,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCSCTPTransportState> for WebRTCSCTPTransportState {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCSCTPTransportState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_SCTP_TRANSPORT_STATE_NEW => Self::New,
            ffi::GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTING => Self::Connecting,
            ffi::GST_WEBRTC_SCTP_TRANSPORT_STATE_CONNECTED => Self::Connected,
            ffi::GST_WEBRTC_SCTP_TRANSPORT_STATE_CLOSED => Self::Closed,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl StaticType for WebRTCSCTPTransportState {
    #[inline]
    #[doc(alias = "gst_webrtc_sctp_transport_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_sctp_transport_state_get_type()) }
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::HasParamSpec for WebRTCSCTPTransportState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl glib::value::ValueType for WebRTCSCTPTransportState {
    type Type = Self;
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
unsafe impl<'a> glib::value::FromValue<'a> for WebRTCSCTPTransportState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl ToValue for WebRTCSCTPTransportState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_16")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
impl From<WebRTCSCTPTransportState> for glib::Value {
    #[inline]
    fn from(v: WebRTCSCTPTransportState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCSDPType")]
pub enum WebRTCSDPType {
    #[doc(alias = "GST_WEBRTC_SDP_TYPE_OFFER")]
    Offer,
    #[doc(alias = "GST_WEBRTC_SDP_TYPE_PRANSWER")]
    Pranswer,
    #[doc(alias = "GST_WEBRTC_SDP_TYPE_ANSWER")]
    Answer,
    #[doc(alias = "GST_WEBRTC_SDP_TYPE_ROLLBACK")]
    Rollback,
    #[doc(hidden)]
    __Unknown(i32),
}

impl WebRTCSDPType {
    pub fn to_str<'a>(self) -> &'a GStr {
        unsafe {
            GStr::from_ptr(
                ffi::gst_webrtc_sdp_type_to_string(self.into_glib())
                    .as_ref()
                    .expect("gst_webrtc_sdp_type_to_string returned NULL"),
            )
        }
    }
}

impl fmt::Display for WebRTCSDPType {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str(&self.to_str())
    }
}

#[doc(hidden)]
impl IntoGlib for WebRTCSDPType {
    type GlibType = ffi::GstWebRTCSDPType;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCSDPType {
        match self {
            Self::Offer => ffi::GST_WEBRTC_SDP_TYPE_OFFER,
            Self::Pranswer => ffi::GST_WEBRTC_SDP_TYPE_PRANSWER,
            Self::Answer => ffi::GST_WEBRTC_SDP_TYPE_ANSWER,
            Self::Rollback => ffi::GST_WEBRTC_SDP_TYPE_ROLLBACK,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCSDPType> for WebRTCSDPType {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCSDPType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_SDP_TYPE_OFFER => Self::Offer,
            ffi::GST_WEBRTC_SDP_TYPE_PRANSWER => Self::Pranswer,
            ffi::GST_WEBRTC_SDP_TYPE_ANSWER => Self::Answer,
            ffi::GST_WEBRTC_SDP_TYPE_ROLLBACK => Self::Rollback,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCSDPType {
    #[inline]
    #[doc(alias = "gst_webrtc_sdp_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_sdp_type_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCSDPType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCSDPType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCSDPType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCSDPType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCSDPType> for glib::Value {
    #[inline]
    fn from(v: WebRTCSDPType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCSignalingState")]
pub enum WebRTCSignalingState {
    #[doc(alias = "GST_WEBRTC_SIGNALING_STATE_STABLE")]
    Stable,
    #[doc(alias = "GST_WEBRTC_SIGNALING_STATE_CLOSED")]
    Closed,
    #[doc(alias = "GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_OFFER")]
    HaveLocalOffer,
    #[doc(alias = "GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_OFFER")]
    HaveRemoteOffer,
    #[doc(alias = "GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_PRANSWER")]
    HaveLocalPranswer,
    #[doc(alias = "GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_PRANSWER")]
    HaveRemotePranswer,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCSignalingState {
    type GlibType = ffi::GstWebRTCSignalingState;

    #[inline]
    fn into_glib(self) -> ffi::GstWebRTCSignalingState {
        match self {
            Self::Stable => ffi::GST_WEBRTC_SIGNALING_STATE_STABLE,
            Self::Closed => ffi::GST_WEBRTC_SIGNALING_STATE_CLOSED,
            Self::HaveLocalOffer => ffi::GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_OFFER,
            Self::HaveRemoteOffer => ffi::GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_OFFER,
            Self::HaveLocalPranswer => ffi::GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_PRANSWER,
            Self::HaveRemotePranswer => ffi::GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_PRANSWER,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCSignalingState> for WebRTCSignalingState {
    #[inline]
    unsafe fn from_glib(value: ffi::GstWebRTCSignalingState) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_SIGNALING_STATE_STABLE => Self::Stable,
            ffi::GST_WEBRTC_SIGNALING_STATE_CLOSED => Self::Closed,
            ffi::GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_OFFER => Self::HaveLocalOffer,
            ffi::GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_OFFER => Self::HaveRemoteOffer,
            ffi::GST_WEBRTC_SIGNALING_STATE_HAVE_LOCAL_PRANSWER => Self::HaveLocalPranswer,
            ffi::GST_WEBRTC_SIGNALING_STATE_HAVE_REMOTE_PRANSWER => Self::HaveRemotePranswer,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCSignalingState {
    #[inline]
    #[doc(alias = "gst_webrtc_signaling_state_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_signaling_state_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCSignalingState {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCSignalingState {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCSignalingState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCSignalingState {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCSignalingState> for glib::Value {
    #[inline]
    fn from(v: WebRTCSignalingState) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GstWebRTCStatsType")]
pub enum WebRTCStatsType {
    #[doc(alias = "GST_WEBRTC_STATS_CODEC")]
    Codec,
    #[doc(alias = "GST_WEBRTC_STATS_INBOUND_RTP")]
    InboundRtp,
    #[doc(alias = "GST_WEBRTC_STATS_OUTBOUND_RTP")]
    OutboundRtp,
    #[doc(alias = "GST_WEBRTC_STATS_REMOTE_INBOUND_RTP")]
    RemoteInboundRtp,
    #[doc(alias = "GST_WEBRTC_STATS_REMOTE_OUTBOUND_RTP")]
    RemoteOutboundRtp,
    #[doc(alias = "GST_WEBRTC_STATS_CSRC")]
    Csrc,
    #[doc(alias = "GST_WEBRTC_STATS_PEER_CONNECTION")]
    PeerConnection,
    #[doc(alias = "GST_WEBRTC_STATS_DATA_CHANNEL")]
    DataChannel,
    #[doc(alias = "GST_WEBRTC_STATS_STREAM")]
    Stream,
    #[doc(alias = "GST_WEBRTC_STATS_TRANSPORT")]
    Transport,
    #[doc(alias = "GST_WEBRTC_STATS_CANDIDATE_PAIR")]
    CandidatePair,
    #[doc(alias = "GST_WEBRTC_STATS_LOCAL_CANDIDATE")]
    LocalCandidate,
    #[doc(alias = "GST_WEBRTC_STATS_REMOTE_CANDIDATE")]
    RemoteCandidate,
    #[doc(alias = "GST_WEBRTC_STATS_CERTIFICATE")]
    Certificate,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for WebRTCStatsType {
    type GlibType = ffi::GstWebRTCStatsType;

    fn into_glib(self) -> ffi::GstWebRTCStatsType {
        match self {
            Self::Codec => ffi::GST_WEBRTC_STATS_CODEC,
            Self::InboundRtp => ffi::GST_WEBRTC_STATS_INBOUND_RTP,
            Self::OutboundRtp => ffi::GST_WEBRTC_STATS_OUTBOUND_RTP,
            Self::RemoteInboundRtp => ffi::GST_WEBRTC_STATS_REMOTE_INBOUND_RTP,
            Self::RemoteOutboundRtp => ffi::GST_WEBRTC_STATS_REMOTE_OUTBOUND_RTP,
            Self::Csrc => ffi::GST_WEBRTC_STATS_CSRC,
            Self::PeerConnection => ffi::GST_WEBRTC_STATS_PEER_CONNECTION,
            Self::DataChannel => ffi::GST_WEBRTC_STATS_DATA_CHANNEL,
            Self::Stream => ffi::GST_WEBRTC_STATS_STREAM,
            Self::Transport => ffi::GST_WEBRTC_STATS_TRANSPORT,
            Self::CandidatePair => ffi::GST_WEBRTC_STATS_CANDIDATE_PAIR,
            Self::LocalCandidate => ffi::GST_WEBRTC_STATS_LOCAL_CANDIDATE,
            Self::RemoteCandidate => ffi::GST_WEBRTC_STATS_REMOTE_CANDIDATE,
            Self::Certificate => ffi::GST_WEBRTC_STATS_CERTIFICATE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstWebRTCStatsType> for WebRTCStatsType {
    unsafe fn from_glib(value: ffi::GstWebRTCStatsType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::GST_WEBRTC_STATS_CODEC => Self::Codec,
            ffi::GST_WEBRTC_STATS_INBOUND_RTP => Self::InboundRtp,
            ffi::GST_WEBRTC_STATS_OUTBOUND_RTP => Self::OutboundRtp,
            ffi::GST_WEBRTC_STATS_REMOTE_INBOUND_RTP => Self::RemoteInboundRtp,
            ffi::GST_WEBRTC_STATS_REMOTE_OUTBOUND_RTP => Self::RemoteOutboundRtp,
            ffi::GST_WEBRTC_STATS_CSRC => Self::Csrc,
            ffi::GST_WEBRTC_STATS_PEER_CONNECTION => Self::PeerConnection,
            ffi::GST_WEBRTC_STATS_DATA_CHANNEL => Self::DataChannel,
            ffi::GST_WEBRTC_STATS_STREAM => Self::Stream,
            ffi::GST_WEBRTC_STATS_TRANSPORT => Self::Transport,
            ffi::GST_WEBRTC_STATS_CANDIDATE_PAIR => Self::CandidatePair,
            ffi::GST_WEBRTC_STATS_LOCAL_CANDIDATE => Self::LocalCandidate,
            ffi::GST_WEBRTC_STATS_REMOTE_CANDIDATE => Self::RemoteCandidate,
            ffi::GST_WEBRTC_STATS_CERTIFICATE => Self::Certificate,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WebRTCStatsType {
    #[inline]
    #[doc(alias = "gst_webrtc_stats_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_webrtc_stats_type_get_type()) }
    }
}

impl glib::HasParamSpec for WebRTCStatsType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for WebRTCStatsType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for WebRTCStatsType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WebRTCStatsType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<WebRTCStatsType> for glib::Value {
    #[inline]
    fn from(v: WebRTCStatsType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
