// This file was generated by gir (651da6e) from gir-files (???)
// DO NOT EDIT

use Clock;
use ClockType;
use Object;
use ffi;
use glib;
use glib::Value;
use glib::object::IsA;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use std::mem;
use std::mem::transmute;
use std::ptr;

glib_wrapper! {
    pub struct SystemClock(Object<ffi::GstSystemClock>): Clock, Object;

    match fn {
        get_type => || ffi::gst_system_clock_get_type(),
    }
}

impl SystemClock {
    pub fn obtain() -> Clock {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gst_system_clock_obtain())
        }
    }

    pub fn set_default<P: IsA<Clock>>(new_clock: &P) {
        skip_assert_initialized!();
        unsafe {
            ffi::gst_system_clock_set_default(new_clock.to_glib_none().0);
        }
    }
}

unsafe impl Send for SystemClock {}
unsafe impl Sync for SystemClock {}

pub trait SystemClockExt {
    fn get_property_clock_type(&self) -> ClockType;

    fn set_property_clock_type(&self, clock_type: ClockType);
}

impl<O: IsA<SystemClock> + IsA<glib::object::Object>> SystemClockExt for O {
    fn get_property_clock_type(&self) -> ClockType {
        let mut value = Value::from(&0);
        unsafe {
            gobject_ffi::g_object_get_property(self.to_glib_none().0, "clock-type".to_glib_none().0, value.to_glib_none_mut().0);
            from_glib(transmute(value.get::<i32>().unwrap()))
        }
    }

    fn set_property_clock_type(&self, clock_type: ClockType) {
        let clock_type = clock_type.to_glib() as i32;
        unsafe {
            gobject_ffi::g_object_set_property(self.to_glib_none().0, "clock-type".to_glib_none().0, Value::from(&clock_type).to_glib_none().0);
        }
    }
}
