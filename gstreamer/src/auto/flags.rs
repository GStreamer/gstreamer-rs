// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// from gst-gir-files (https://gitlab.freedesktop.org/gstreamer/gir-files-rs.git)
// DO NOT EDIT

use crate::ffi;
use glib::{bitflags::bitflags, prelude::*, translate::*, GStr};

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstBinFlags")]
    pub struct BinFlags: u32 {
        #[doc(alias = "GST_BIN_FLAG_NO_RESYNC")]
        const NO_RESYNC = ffi::GST_BIN_FLAG_NO_RESYNC as _;
        #[doc(alias = "GST_BIN_FLAG_STREAMS_AWARE")]
        const STREAMS_AWARE = ffi::GST_BIN_FLAG_STREAMS_AWARE as _;
    }
}

#[doc(hidden)]
impl IntoGlib for BinFlags {
    type GlibType = ffi::GstBinFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstBinFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstBinFlags> for BinFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstBinFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BinFlags {
    #[inline]
    #[doc(alias = "gst_bin_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_bin_flags_get_type()) }
    }
}

impl glib::HasParamSpec for BinFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for BinFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BinFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BinFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BinFlags> for glib::Value {
    #[inline]
    fn from(v: BinFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstBufferCopyFlags")]
    pub struct BufferCopyFlags: u32 {
        #[doc(alias = "GST_BUFFER_COPY_FLAGS")]
        const FLAGS = ffi::GST_BUFFER_COPY_FLAGS as _;
        #[doc(alias = "GST_BUFFER_COPY_TIMESTAMPS")]
        const TIMESTAMPS = ffi::GST_BUFFER_COPY_TIMESTAMPS as _;
        #[doc(alias = "GST_BUFFER_COPY_META")]
        const META = ffi::GST_BUFFER_COPY_META as _;
        #[doc(alias = "GST_BUFFER_COPY_MEMORY")]
        const MEMORY = ffi::GST_BUFFER_COPY_MEMORY as _;
        #[doc(alias = "GST_BUFFER_COPY_MERGE")]
        const MERGE = ffi::GST_BUFFER_COPY_MERGE as _;
        #[doc(alias = "GST_BUFFER_COPY_DEEP")]
        const DEEP = ffi::GST_BUFFER_COPY_DEEP as _;
    }
}

#[doc(hidden)]
impl IntoGlib for BufferCopyFlags {
    type GlibType = ffi::GstBufferCopyFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstBufferCopyFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstBufferCopyFlags> for BufferCopyFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstBufferCopyFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BufferCopyFlags {
    #[inline]
    #[doc(alias = "gst_buffer_copy_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_buffer_copy_flags_get_type()) }
    }
}

impl glib::HasParamSpec for BufferCopyFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for BufferCopyFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BufferCopyFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BufferCopyFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BufferCopyFlags> for glib::Value {
    #[inline]
    fn from(v: BufferCopyFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstBufferFlags")]
    pub struct BufferFlags: u32 {
        #[doc(alias = "GST_BUFFER_FLAG_LIVE")]
        const LIVE = ffi::GST_BUFFER_FLAG_LIVE as _;
        #[doc(alias = "GST_BUFFER_FLAG_DECODE_ONLY")]
        const DECODE_ONLY = ffi::GST_BUFFER_FLAG_DECODE_ONLY as _;
        #[doc(alias = "GST_BUFFER_FLAG_DISCONT")]
        const DISCONT = ffi::GST_BUFFER_FLAG_DISCONT as _;
        #[doc(alias = "GST_BUFFER_FLAG_RESYNC")]
        const RESYNC = ffi::GST_BUFFER_FLAG_RESYNC as _;
        #[doc(alias = "GST_BUFFER_FLAG_CORRUPTED")]
        const CORRUPTED = ffi::GST_BUFFER_FLAG_CORRUPTED as _;
        #[doc(alias = "GST_BUFFER_FLAG_MARKER")]
        const MARKER = ffi::GST_BUFFER_FLAG_MARKER as _;
        #[doc(alias = "GST_BUFFER_FLAG_HEADER")]
        const HEADER = ffi::GST_BUFFER_FLAG_HEADER as _;
        #[doc(alias = "GST_BUFFER_FLAG_GAP")]
        const GAP = ffi::GST_BUFFER_FLAG_GAP as _;
        #[doc(alias = "GST_BUFFER_FLAG_DROPPABLE")]
        const DROPPABLE = ffi::GST_BUFFER_FLAG_DROPPABLE as _;
        #[doc(alias = "GST_BUFFER_FLAG_DELTA_UNIT")]
        const DELTA_UNIT = ffi::GST_BUFFER_FLAG_DELTA_UNIT as _;
        #[doc(alias = "GST_BUFFER_FLAG_TAG_MEMORY")]
        const TAG_MEMORY = ffi::GST_BUFFER_FLAG_TAG_MEMORY as _;
        #[doc(alias = "GST_BUFFER_FLAG_SYNC_AFTER")]
        const SYNC_AFTER = ffi::GST_BUFFER_FLAG_SYNC_AFTER as _;
        #[doc(alias = "GST_BUFFER_FLAG_NON_DROPPABLE")]
        const NON_DROPPABLE = ffi::GST_BUFFER_FLAG_NON_DROPPABLE as _;
    }
}

#[doc(hidden)]
impl IntoGlib for BufferFlags {
    type GlibType = ffi::GstBufferFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstBufferFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstBufferFlags> for BufferFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstBufferFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BufferFlags {
    #[inline]
    #[doc(alias = "gst_buffer_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_buffer_flags_get_type()) }
    }
}

impl glib::HasParamSpec for BufferFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for BufferFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BufferFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BufferFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BufferFlags> for glib::Value {
    #[inline]
    fn from(v: BufferFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstBufferPoolAcquireFlags")]
    pub struct BufferPoolAcquireFlags: u32 {
        #[doc(alias = "GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT")]
        const KEY_UNIT = ffi::GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT as _;
        #[doc(alias = "GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT")]
        const DONTWAIT = ffi::GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT as _;
        #[doc(alias = "GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT")]
        const DISCONT = ffi::GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT as _;
    }
}

#[doc(hidden)]
impl IntoGlib for BufferPoolAcquireFlags {
    type GlibType = ffi::GstBufferPoolAcquireFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstBufferPoolAcquireFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstBufferPoolAcquireFlags> for BufferPoolAcquireFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstBufferPoolAcquireFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BufferPoolAcquireFlags {
    #[inline]
    #[doc(alias = "gst_buffer_pool_acquire_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_buffer_pool_acquire_flags_get_type()) }
    }
}

impl glib::HasParamSpec for BufferPoolAcquireFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for BufferPoolAcquireFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BufferPoolAcquireFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BufferPoolAcquireFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BufferPoolAcquireFlags> for glib::Value {
    #[inline]
    fn from(v: BufferPoolAcquireFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstClockFlags")]
    pub struct ClockFlags: u32 {
        #[doc(alias = "GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC")]
        const CAN_DO_SINGLE_SYNC = ffi::GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC as _;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC")]
        const CAN_DO_SINGLE_ASYNC = ffi::GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC as _;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC")]
        const CAN_DO_PERIODIC_SYNC = ffi::GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC as _;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC")]
        const CAN_DO_PERIODIC_ASYNC = ffi::GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC as _;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_SET_RESOLUTION")]
        const CAN_SET_RESOLUTION = ffi::GST_CLOCK_FLAG_CAN_SET_RESOLUTION as _;
        #[doc(alias = "GST_CLOCK_FLAG_CAN_SET_MASTER")]
        const CAN_SET_MASTER = ffi::GST_CLOCK_FLAG_CAN_SET_MASTER as _;
        #[doc(alias = "GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC")]
        const NEEDS_STARTUP_SYNC = ffi::GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC as _;
    }
}

#[doc(hidden)]
impl IntoGlib for ClockFlags {
    type GlibType = ffi::GstClockFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstClockFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstClockFlags> for ClockFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstClockFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ClockFlags {
    #[inline]
    #[doc(alias = "gst_clock_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_clock_flags_get_type()) }
    }
}

impl glib::HasParamSpec for ClockFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for ClockFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ClockFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ClockFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ClockFlags> for glib::Value {
    #[inline]
    fn from(v: ClockFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstDebugColorFlags")]
    pub struct DebugColorFlags: u32 {
        #[doc(alias = "GST_DEBUG_FG_BLACK")]
        const FG_BLACK = ffi::GST_DEBUG_FG_BLACK as _;
        #[doc(alias = "GST_DEBUG_FG_RED")]
        const FG_RED = ffi::GST_DEBUG_FG_RED as _;
        #[doc(alias = "GST_DEBUG_FG_GREEN")]
        const FG_GREEN = ffi::GST_DEBUG_FG_GREEN as _;
        #[doc(alias = "GST_DEBUG_FG_YELLOW")]
        const FG_YELLOW = ffi::GST_DEBUG_FG_YELLOW as _;
        #[doc(alias = "GST_DEBUG_FG_BLUE")]
        const FG_BLUE = ffi::GST_DEBUG_FG_BLUE as _;
        #[doc(alias = "GST_DEBUG_FG_MAGENTA")]
        const FG_MAGENTA = ffi::GST_DEBUG_FG_MAGENTA as _;
        #[doc(alias = "GST_DEBUG_FG_CYAN")]
        const FG_CYAN = ffi::GST_DEBUG_FG_CYAN as _;
        #[doc(alias = "GST_DEBUG_FG_WHITE")]
        const FG_WHITE = ffi::GST_DEBUG_FG_WHITE as _;
        #[doc(alias = "GST_DEBUG_BG_BLACK")]
        const BG_BLACK = ffi::GST_DEBUG_BG_BLACK as _;
        #[doc(alias = "GST_DEBUG_BG_RED")]
        const BG_RED = ffi::GST_DEBUG_BG_RED as _;
        #[doc(alias = "GST_DEBUG_BG_GREEN")]
        const BG_GREEN = ffi::GST_DEBUG_BG_GREEN as _;
        #[doc(alias = "GST_DEBUG_BG_YELLOW")]
        const BG_YELLOW = ffi::GST_DEBUG_BG_YELLOW as _;
        #[doc(alias = "GST_DEBUG_BG_BLUE")]
        const BG_BLUE = ffi::GST_DEBUG_BG_BLUE as _;
        #[doc(alias = "GST_DEBUG_BG_MAGENTA")]
        const BG_MAGENTA = ffi::GST_DEBUG_BG_MAGENTA as _;
        #[doc(alias = "GST_DEBUG_BG_CYAN")]
        const BG_CYAN = ffi::GST_DEBUG_BG_CYAN as _;
        #[doc(alias = "GST_DEBUG_BG_WHITE")]
        const BG_WHITE = ffi::GST_DEBUG_BG_WHITE as _;
        #[doc(alias = "GST_DEBUG_BOLD")]
        const BOLD = ffi::GST_DEBUG_BOLD as _;
        #[doc(alias = "GST_DEBUG_UNDERLINE")]
        const UNDERLINE = ffi::GST_DEBUG_UNDERLINE as _;
    }
}

#[doc(hidden)]
impl IntoGlib for DebugColorFlags {
    type GlibType = ffi::GstDebugColorFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstDebugColorFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstDebugColorFlags> for DebugColorFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstDebugColorFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DebugColorFlags {
    #[inline]
    #[doc(alias = "gst_debug_color_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_debug_color_flags_get_type()) }
    }
}

impl glib::HasParamSpec for DebugColorFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for DebugColorFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DebugColorFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DebugColorFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DebugColorFlags> for glib::Value {
    #[inline]
    fn from(v: DebugColorFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstDebugGraphDetails")]
    pub struct DebugGraphDetails: u32 {
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE")]
        const MEDIA_TYPE = ffi::GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE as _;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS")]
        const CAPS_DETAILS = ffi::GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS as _;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS")]
        const NON_DEFAULT_PARAMS = ffi::GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS as _;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_STATES")]
        const STATES = ffi::GST_DEBUG_GRAPH_SHOW_STATES as _;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_FULL_PARAMS")]
        const FULL_PARAMS = ffi::GST_DEBUG_GRAPH_SHOW_FULL_PARAMS as _;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_ALL")]
        const ALL = ffi::GST_DEBUG_GRAPH_SHOW_ALL as _;
        #[doc(alias = "GST_DEBUG_GRAPH_SHOW_VERBOSE")]
        const VERBOSE = ffi::GST_DEBUG_GRAPH_SHOW_VERBOSE as _;
    }
}

#[doc(hidden)]
impl IntoGlib for DebugGraphDetails {
    type GlibType = ffi::GstDebugGraphDetails;

    #[inline]
    fn into_glib(self) -> ffi::GstDebugGraphDetails {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstDebugGraphDetails> for DebugGraphDetails {
    #[inline]
    unsafe fn from_glib(value: ffi::GstDebugGraphDetails) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DebugGraphDetails {
    #[inline]
    #[doc(alias = "gst_debug_graph_details_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_debug_graph_details_get_type()) }
    }
}

impl glib::HasParamSpec for DebugGraphDetails {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for DebugGraphDetails {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DebugGraphDetails {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DebugGraphDetails {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DebugGraphDetails> for glib::Value {
    #[inline]
    fn from(v: DebugGraphDetails) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstElementFlags")]
    pub struct ElementFlags: u32 {
        #[doc(alias = "GST_ELEMENT_FLAG_LOCKED_STATE")]
        const LOCKED_STATE = ffi::GST_ELEMENT_FLAG_LOCKED_STATE as _;
        #[doc(alias = "GST_ELEMENT_FLAG_SINK")]
        const SINK = ffi::GST_ELEMENT_FLAG_SINK as _;
        #[doc(alias = "GST_ELEMENT_FLAG_SOURCE")]
        const SOURCE = ffi::GST_ELEMENT_FLAG_SOURCE as _;
        #[doc(alias = "GST_ELEMENT_FLAG_PROVIDE_CLOCK")]
        const PROVIDE_CLOCK = ffi::GST_ELEMENT_FLAG_PROVIDE_CLOCK as _;
        #[doc(alias = "GST_ELEMENT_FLAG_REQUIRE_CLOCK")]
        const REQUIRE_CLOCK = ffi::GST_ELEMENT_FLAG_REQUIRE_CLOCK as _;
        #[doc(alias = "GST_ELEMENT_FLAG_INDEXABLE")]
        const INDEXABLE = ffi::GST_ELEMENT_FLAG_INDEXABLE as _;
    }
}

#[doc(hidden)]
impl IntoGlib for ElementFlags {
    type GlibType = ffi::GstElementFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstElementFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstElementFlags> for ElementFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstElementFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ElementFlags {
    #[inline]
    #[doc(alias = "gst_element_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_element_flags_get_type()) }
    }
}

impl glib::HasParamSpec for ElementFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for ElementFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ElementFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ElementFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ElementFlags> for glib::Value {
    #[inline]
    fn from(v: ElementFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstEventTypeFlags")]
    pub struct EventTypeFlags: u32 {
        #[doc(alias = "GST_EVENT_TYPE_UPSTREAM")]
        const UPSTREAM = ffi::GST_EVENT_TYPE_UPSTREAM as _;
        #[doc(alias = "GST_EVENT_TYPE_DOWNSTREAM")]
        const DOWNSTREAM = ffi::GST_EVENT_TYPE_DOWNSTREAM as _;
        #[doc(alias = "GST_EVENT_TYPE_SERIALIZED")]
        const SERIALIZED = ffi::GST_EVENT_TYPE_SERIALIZED as _;
        #[doc(alias = "GST_EVENT_TYPE_STICKY")]
        const STICKY = ffi::GST_EVENT_TYPE_STICKY as _;
        #[doc(alias = "GST_EVENT_TYPE_STICKY_MULTI")]
        const STICKY_MULTI = ffi::GST_EVENT_TYPE_STICKY_MULTI as _;
    }
}

#[doc(hidden)]
impl IntoGlib for EventTypeFlags {
    type GlibType = ffi::GstEventTypeFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstEventTypeFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstEventTypeFlags> for EventTypeFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstEventTypeFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for EventTypeFlags {
    #[inline]
    #[doc(alias = "gst_event_type_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_event_type_flags_get_type()) }
    }
}

impl glib::HasParamSpec for EventTypeFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for EventTypeFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for EventTypeFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for EventTypeFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<EventTypeFlags> for glib::Value {
    #[inline]
    fn from(v: EventTypeFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_20")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstGapFlags")]
    pub struct GapFlags: u32 {
        #[doc(alias = "GST_GAP_FLAG_MISSING_DATA")]
        const DATA = ffi::GST_GAP_FLAG_MISSING_DATA as _;
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl IntoGlib for GapFlags {
    type GlibType = ffi::GstGapFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstGapFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl FromGlib<ffi::GstGapFlags> for GapFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstGapFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl StaticType for GapFlags {
    #[inline]
    #[doc(alias = "gst_gap_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_gap_flags_get_type()) }
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::HasParamSpec for GapFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::value::ValueType for GapFlags {
    type Type = Self;
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
unsafe impl<'a> glib::value::FromValue<'a> for GapFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl ToValue for GapFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl From<GapFlags> for glib::Value {
    #[inline]
    fn from(v: GapFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstMemoryFlags")]
    pub struct MemoryFlags: u32 {
        #[doc(alias = "GST_MEMORY_FLAG_READONLY")]
        const READONLY = ffi::GST_MEMORY_FLAG_READONLY as _;
        #[doc(alias = "GST_MEMORY_FLAG_NO_SHARE")]
        const NO_SHARE = ffi::GST_MEMORY_FLAG_NO_SHARE as _;
        #[doc(alias = "GST_MEMORY_FLAG_ZERO_PREFIXED")]
        const ZERO_PREFIXED = ffi::GST_MEMORY_FLAG_ZERO_PREFIXED as _;
        #[doc(alias = "GST_MEMORY_FLAG_ZERO_PADDED")]
        const ZERO_PADDED = ffi::GST_MEMORY_FLAG_ZERO_PADDED as _;
        #[doc(alias = "GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS")]
        const PHYSICALLY_CONTIGUOUS = ffi::GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS as _;
        #[doc(alias = "GST_MEMORY_FLAG_NOT_MAPPABLE")]
        const NOT_MAPPABLE = ffi::GST_MEMORY_FLAG_NOT_MAPPABLE as _;
    }
}

#[doc(hidden)]
impl IntoGlib for MemoryFlags {
    type GlibType = ffi::GstMemoryFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstMemoryFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstMemoryFlags> for MemoryFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstMemoryFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for MemoryFlags {
    #[inline]
    #[doc(alias = "gst_memory_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_memory_flags_get_type()) }
    }
}

impl glib::HasParamSpec for MemoryFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for MemoryFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MemoryFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for MemoryFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MemoryFlags> for glib::Value {
    #[inline]
    fn from(v: MemoryFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstMetaFlags")]
    pub struct MetaFlags: u32 {
        #[doc(alias = "GST_META_FLAG_READONLY")]
        const READONLY = ffi::GST_META_FLAG_READONLY as _;
        #[doc(alias = "GST_META_FLAG_POOLED")]
        const POOLED = ffi::GST_META_FLAG_POOLED as _;
        #[doc(alias = "GST_META_FLAG_LOCKED")]
        const LOCKED = ffi::GST_META_FLAG_LOCKED as _;
    }
}

#[doc(hidden)]
impl IntoGlib for MetaFlags {
    type GlibType = ffi::GstMetaFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstMetaFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstMetaFlags> for MetaFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstMetaFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for MetaFlags {
    #[inline]
    #[doc(alias = "gst_meta_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_meta_flags_get_type()) }
    }
}

impl glib::HasParamSpec for MetaFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for MetaFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MetaFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for MetaFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MetaFlags> for glib::Value {
    #[inline]
    fn from(v: MetaFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstObjectFlags")]
    pub struct ObjectFlags: u32 {
        #[doc(alias = "GST_OBJECT_FLAG_MAY_BE_LEAKED")]
        const MAY_BE_LEAKED = ffi::GST_OBJECT_FLAG_MAY_BE_LEAKED as _;
        #[cfg(feature = "v1_24")]
        #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
        #[doc(alias = "GST_OBJECT_FLAG_CONSTRUCTED")]
        const CONSTRUCTED = ffi::GST_OBJECT_FLAG_CONSTRUCTED as _;
    }
}

#[doc(hidden)]
impl IntoGlib for ObjectFlags {
    type GlibType = ffi::GstObjectFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstObjectFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstObjectFlags> for ObjectFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstObjectFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ObjectFlags {
    #[inline]
    #[doc(alias = "gst_object_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_object_flags_get_type()) }
    }
}

impl glib::HasParamSpec for ObjectFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for ObjectFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ObjectFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ObjectFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ObjectFlags> for glib::Value {
    #[inline]
    fn from(v: ObjectFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstPadFlags")]
    pub struct PadFlags: u32 {
        #[doc(alias = "GST_PAD_FLAG_BLOCKED")]
        const BLOCKED = ffi::GST_PAD_FLAG_BLOCKED as _;
        #[doc(alias = "GST_PAD_FLAG_FLUSHING")]
        const FLUSHING = ffi::GST_PAD_FLAG_FLUSHING as _;
        #[doc(alias = "GST_PAD_FLAG_EOS")]
        const EOS = ffi::GST_PAD_FLAG_EOS as _;
        #[doc(alias = "GST_PAD_FLAG_BLOCKING")]
        const BLOCKING = ffi::GST_PAD_FLAG_BLOCKING as _;
        #[doc(alias = "GST_PAD_FLAG_NEED_PARENT")]
        const NEED_PARENT = ffi::GST_PAD_FLAG_NEED_PARENT as _;
        #[doc(alias = "GST_PAD_FLAG_NEED_RECONFIGURE")]
        const NEED_RECONFIGURE = ffi::GST_PAD_FLAG_NEED_RECONFIGURE as _;
        #[doc(alias = "GST_PAD_FLAG_PENDING_EVENTS")]
        const PENDING_EVENTS = ffi::GST_PAD_FLAG_PENDING_EVENTS as _;
        #[doc(alias = "GST_PAD_FLAG_FIXED_CAPS")]
        const FIXED_CAPS = ffi::GST_PAD_FLAG_FIXED_CAPS as _;
        #[doc(alias = "GST_PAD_FLAG_PROXY_CAPS")]
        const PROXY_CAPS = ffi::GST_PAD_FLAG_PROXY_CAPS as _;
        #[doc(alias = "GST_PAD_FLAG_PROXY_ALLOCATION")]
        const PROXY_ALLOCATION = ffi::GST_PAD_FLAG_PROXY_ALLOCATION as _;
        #[doc(alias = "GST_PAD_FLAG_PROXY_SCHEDULING")]
        const PROXY_SCHEDULING = ffi::GST_PAD_FLAG_PROXY_SCHEDULING as _;
        #[doc(alias = "GST_PAD_FLAG_ACCEPT_INTERSECT")]
        const ACCEPT_INTERSECT = ffi::GST_PAD_FLAG_ACCEPT_INTERSECT as _;
        #[doc(alias = "GST_PAD_FLAG_ACCEPT_TEMPLATE")]
        const ACCEPT_TEMPLATE = ffi::GST_PAD_FLAG_ACCEPT_TEMPLATE as _;
    }
}

#[doc(hidden)]
impl IntoGlib for PadFlags {
    type GlibType = ffi::GstPadFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstPadFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPadFlags> for PadFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstPadFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PadFlags {
    #[inline]
    #[doc(alias = "gst_pad_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_pad_flags_get_type()) }
    }
}

impl glib::HasParamSpec for PadFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for PadFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PadFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PadFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PadFlags> for glib::Value {
    #[inline]
    fn from(v: PadFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstPadLinkCheck")]
    pub struct PadLinkCheck: u32 {
        #[doc(alias = "GST_PAD_LINK_CHECK_HIERARCHY")]
        const HIERARCHY = ffi::GST_PAD_LINK_CHECK_HIERARCHY as _;
        #[doc(alias = "GST_PAD_LINK_CHECK_TEMPLATE_CAPS")]
        const TEMPLATE_CAPS = ffi::GST_PAD_LINK_CHECK_TEMPLATE_CAPS as _;
        #[doc(alias = "GST_PAD_LINK_CHECK_CAPS")]
        const CAPS = ffi::GST_PAD_LINK_CHECK_CAPS as _;
        #[doc(alias = "GST_PAD_LINK_CHECK_NO_RECONFIGURE")]
        const NO_RECONFIGURE = ffi::GST_PAD_LINK_CHECK_NO_RECONFIGURE as _;
        #[doc(alias = "GST_PAD_LINK_CHECK_DEFAULT")]
        const DEFAULT = ffi::GST_PAD_LINK_CHECK_DEFAULT as _;
    }
}

#[doc(hidden)]
impl IntoGlib for PadLinkCheck {
    type GlibType = ffi::GstPadLinkCheck;

    #[inline]
    fn into_glib(self) -> ffi::GstPadLinkCheck {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPadLinkCheck> for PadLinkCheck {
    #[inline]
    unsafe fn from_glib(value: ffi::GstPadLinkCheck) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PadLinkCheck {
    #[inline]
    #[doc(alias = "gst_pad_link_check_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_pad_link_check_get_type()) }
    }
}

impl glib::HasParamSpec for PadLinkCheck {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for PadLinkCheck {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PadLinkCheck {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PadLinkCheck {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PadLinkCheck> for glib::Value {
    #[inline]
    fn from(v: PadLinkCheck) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstPadProbeType")]
    pub struct PadProbeType: u32 {
        #[doc(alias = "GST_PAD_PROBE_TYPE_IDLE")]
        const IDLE = ffi::GST_PAD_PROBE_TYPE_IDLE as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BLOCK")]
        const BLOCK = ffi::GST_PAD_PROBE_TYPE_BLOCK as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BUFFER")]
        const BUFFER = ffi::GST_PAD_PROBE_TYPE_BUFFER as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BUFFER_LIST")]
        const BUFFER_LIST = ffi::GST_PAD_PROBE_TYPE_BUFFER_LIST as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM")]
        const EVENT_DOWNSTREAM = ffi::GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_EVENT_UPSTREAM")]
        const EVENT_UPSTREAM = ffi::GST_PAD_PROBE_TYPE_EVENT_UPSTREAM as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_EVENT_FLUSH")]
        const EVENT_FLUSH = ffi::GST_PAD_PROBE_TYPE_EVENT_FLUSH as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM")]
        const QUERY_DOWNSTREAM = ffi::GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_QUERY_UPSTREAM")]
        const QUERY_UPSTREAM = ffi::GST_PAD_PROBE_TYPE_QUERY_UPSTREAM as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_PUSH")]
        const PUSH = ffi::GST_PAD_PROBE_TYPE_PUSH as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_PULL")]
        const PULL = ffi::GST_PAD_PROBE_TYPE_PULL as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BLOCKING")]
        const BLOCKING = ffi::GST_PAD_PROBE_TYPE_BLOCKING as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM")]
        const DATA_DOWNSTREAM = ffi::GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_DATA_UPSTREAM")]
        const DATA_UPSTREAM = ffi::GST_PAD_PROBE_TYPE_DATA_UPSTREAM as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_DATA_BOTH")]
        const DATA_BOTH = ffi::GST_PAD_PROBE_TYPE_DATA_BOTH as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM")]
        const BLOCK_DOWNSTREAM = ffi::GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM")]
        const BLOCK_UPSTREAM = ffi::GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_EVENT_BOTH")]
        const EVENT_BOTH = ffi::GST_PAD_PROBE_TYPE_EVENT_BOTH as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_QUERY_BOTH")]
        const QUERY_BOTH = ffi::GST_PAD_PROBE_TYPE_QUERY_BOTH as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_ALL_BOTH")]
        const ALL_BOTH = ffi::GST_PAD_PROBE_TYPE_ALL_BOTH as _;
        #[doc(alias = "GST_PAD_PROBE_TYPE_SCHEDULING")]
        const SCHEDULING = ffi::GST_PAD_PROBE_TYPE_SCHEDULING as _;
    }
}

#[doc(hidden)]
impl IntoGlib for PadProbeType {
    type GlibType = ffi::GstPadProbeType;

    #[inline]
    fn into_glib(self) -> ffi::GstPadProbeType {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPadProbeType> for PadProbeType {
    #[inline]
    unsafe fn from_glib(value: ffi::GstPadProbeType) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PadProbeType {
    #[inline]
    #[doc(alias = "gst_pad_probe_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_pad_probe_type_get_type()) }
    }
}

impl glib::HasParamSpec for PadProbeType {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for PadProbeType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PadProbeType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PadProbeType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PadProbeType> for glib::Value {
    #[inline]
    fn from(v: PadProbeType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstParseFlags")]
    pub struct ParseFlags: u32 {
        #[doc(alias = "GST_PARSE_FLAG_FATAL_ERRORS")]
        const FATAL_ERRORS = ffi::GST_PARSE_FLAG_FATAL_ERRORS as _;
        #[doc(alias = "GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS")]
        const NO_SINGLE_ELEMENT_BINS = ffi::GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS as _;
        #[doc(alias = "GST_PARSE_FLAG_PLACE_IN_BIN")]
        const PLACE_IN_BIN = ffi::GST_PARSE_FLAG_PLACE_IN_BIN as _;
    }
}

#[doc(hidden)]
impl IntoGlib for ParseFlags {
    type GlibType = ffi::GstParseFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstParseFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstParseFlags> for ParseFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstParseFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ParseFlags {
    #[inline]
    #[doc(alias = "gst_parse_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_parse_flags_get_type()) }
    }
}

impl glib::HasParamSpec for ParseFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for ParseFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ParseFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ParseFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ParseFlags> for glib::Value {
    #[inline]
    fn from(v: ParseFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstPipelineFlags")]
    pub struct PipelineFlags: u32 {
        #[doc(alias = "GST_PIPELINE_FLAG_FIXED_CLOCK")]
        const FIXED_CLOCK = ffi::GST_PIPELINE_FLAG_FIXED_CLOCK as _;
    }
}

#[doc(hidden)]
impl IntoGlib for PipelineFlags {
    type GlibType = ffi::GstPipelineFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstPipelineFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPipelineFlags> for PipelineFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstPipelineFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PipelineFlags {
    #[inline]
    #[doc(alias = "gst_pipeline_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_pipeline_flags_get_type()) }
    }
}

impl glib::HasParamSpec for PipelineFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for PipelineFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PipelineFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PipelineFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PipelineFlags> for glib::Value {
    #[inline]
    fn from(v: PipelineFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_18")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstPluginAPIFlags")]
    pub struct PluginAPIFlags: u32 {
        #[doc(alias = "GST_PLUGIN_API_FLAG_IGNORE_ENUM_MEMBERS")]
        const MEMBERS = ffi::GST_PLUGIN_API_FLAG_IGNORE_ENUM_MEMBERS as _;
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
#[doc(hidden)]
impl IntoGlib for PluginAPIFlags {
    type GlibType = ffi::GstPluginAPIFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstPluginAPIFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
#[doc(hidden)]
impl FromGlib<ffi::GstPluginAPIFlags> for PluginAPIFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstPluginAPIFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl StaticType for PluginAPIFlags {
    #[inline]
    #[doc(alias = "gst_plugin_api_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_plugin_api_flags_get_type()) }
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl glib::HasParamSpec for PluginAPIFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl glib::value::ValueType for PluginAPIFlags {
    type Type = Self;
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
unsafe impl<'a> glib::value::FromValue<'a> for PluginAPIFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl ToValue for PluginAPIFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_18")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
impl From<PluginAPIFlags> for glib::Value {
    #[inline]
    fn from(v: PluginAPIFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstPluginDependencyFlags")]
    pub struct PluginDependencyFlags: u32 {
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_RECURSE")]
        const RECURSE = ffi::GST_PLUGIN_DEPENDENCY_FLAG_RECURSE as _;
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY")]
        const PATHS_ARE_DEFAULT_ONLY = ffi::GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY as _;
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX")]
        const FILE_NAME_IS_SUFFIX = ffi::GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX as _;
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX")]
        const FILE_NAME_IS_PREFIX = ffi::GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX as _;
        #[doc(alias = "GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE")]
        const PATHS_ARE_RELATIVE_TO_EXE = ffi::GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE as _;
    }
}

#[doc(hidden)]
impl IntoGlib for PluginDependencyFlags {
    type GlibType = ffi::GstPluginDependencyFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstPluginDependencyFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPluginDependencyFlags> for PluginDependencyFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstPluginDependencyFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PluginDependencyFlags {
    #[inline]
    #[doc(alias = "gst_plugin_dependency_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_plugin_dependency_flags_get_type()) }
    }
}

impl glib::HasParamSpec for PluginDependencyFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for PluginDependencyFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PluginDependencyFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PluginDependencyFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PluginDependencyFlags> for glib::Value {
    #[inline]
    fn from(v: PluginDependencyFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstPluginFlags")]
    pub struct PluginFlags: u32 {
        #[doc(alias = "GST_PLUGIN_FLAG_CACHED")]
        const CACHED = ffi::GST_PLUGIN_FLAG_CACHED as _;
        #[doc(alias = "GST_PLUGIN_FLAG_BLACKLISTED")]
        const BLACKLISTED = ffi::GST_PLUGIN_FLAG_BLACKLISTED as _;
    }
}

#[doc(hidden)]
impl IntoGlib for PluginFlags {
    type GlibType = ffi::GstPluginFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstPluginFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstPluginFlags> for PluginFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstPluginFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PluginFlags {
    #[inline]
    #[doc(alias = "gst_plugin_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_plugin_flags_get_type()) }
    }
}

impl glib::HasParamSpec for PluginFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for PluginFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PluginFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PluginFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PluginFlags> for glib::Value {
    #[inline]
    fn from(v: PluginFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstSchedulingFlags")]
    pub struct SchedulingFlags: u32 {
        #[doc(alias = "GST_SCHEDULING_FLAG_SEEKABLE")]
        const SEEKABLE = ffi::GST_SCHEDULING_FLAG_SEEKABLE as _;
        #[doc(alias = "GST_SCHEDULING_FLAG_SEQUENTIAL")]
        const SEQUENTIAL = ffi::GST_SCHEDULING_FLAG_SEQUENTIAL as _;
        #[doc(alias = "GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED")]
        const BANDWIDTH_LIMITED = ffi::GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED as _;
    }
}

#[doc(hidden)]
impl IntoGlib for SchedulingFlags {
    type GlibType = ffi::GstSchedulingFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstSchedulingFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstSchedulingFlags> for SchedulingFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstSchedulingFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SchedulingFlags {
    #[inline]
    #[doc(alias = "gst_scheduling_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_scheduling_flags_get_type()) }
    }
}

impl glib::HasParamSpec for SchedulingFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for SchedulingFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SchedulingFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SchedulingFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SchedulingFlags> for glib::Value {
    #[inline]
    fn from(v: SchedulingFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstSeekFlags")]
    pub struct SeekFlags: u32 {
        #[doc(alias = "GST_SEEK_FLAG_FLUSH")]
        const FLUSH = ffi::GST_SEEK_FLAG_FLUSH as _;
        #[doc(alias = "GST_SEEK_FLAG_ACCURATE")]
        const ACCURATE = ffi::GST_SEEK_FLAG_ACCURATE as _;
        #[doc(alias = "GST_SEEK_FLAG_KEY_UNIT")]
        const KEY_UNIT = ffi::GST_SEEK_FLAG_KEY_UNIT as _;
        #[doc(alias = "GST_SEEK_FLAG_SEGMENT")]
        const SEGMENT = ffi::GST_SEEK_FLAG_SEGMENT as _;
        #[doc(alias = "GST_SEEK_FLAG_TRICKMODE")]
        const TRICKMODE = ffi::GST_SEEK_FLAG_TRICKMODE as _;
        #[doc(alias = "GST_SEEK_FLAG_SKIP")]
        const SKIP = ffi::GST_SEEK_FLAG_SKIP as _;
        #[doc(alias = "GST_SEEK_FLAG_SNAP_BEFORE")]
        const SNAP_BEFORE = ffi::GST_SEEK_FLAG_SNAP_BEFORE as _;
        #[doc(alias = "GST_SEEK_FLAG_SNAP_AFTER")]
        const SNAP_AFTER = ffi::GST_SEEK_FLAG_SNAP_AFTER as _;
        #[doc(alias = "GST_SEEK_FLAG_SNAP_NEAREST")]
        const SNAP_NEAREST = ffi::GST_SEEK_FLAG_SNAP_NEAREST as _;
        #[doc(alias = "GST_SEEK_FLAG_TRICKMODE_KEY_UNITS")]
        const TRICKMODE_KEY_UNITS = ffi::GST_SEEK_FLAG_TRICKMODE_KEY_UNITS as _;
        #[doc(alias = "GST_SEEK_FLAG_TRICKMODE_NO_AUDIO")]
        const TRICKMODE_NO_AUDIO = ffi::GST_SEEK_FLAG_TRICKMODE_NO_AUDIO as _;
        #[cfg(feature = "v1_18")]
        #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
        #[doc(alias = "GST_SEEK_FLAG_TRICKMODE_FORWARD_PREDICTED")]
        const TRICKMODE_FORWARD_PREDICTED = ffi::GST_SEEK_FLAG_TRICKMODE_FORWARD_PREDICTED as _;
        #[cfg(feature = "v1_18")]
        #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
        #[doc(alias = "GST_SEEK_FLAG_INSTANT_RATE_CHANGE")]
        const INSTANT_RATE_CHANGE = ffi::GST_SEEK_FLAG_INSTANT_RATE_CHANGE as _;
    }
}

#[doc(hidden)]
impl IntoGlib for SeekFlags {
    type GlibType = ffi::GstSeekFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstSeekFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstSeekFlags> for SeekFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstSeekFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SeekFlags {
    #[inline]
    #[doc(alias = "gst_seek_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_seek_flags_get_type()) }
    }
}

impl glib::HasParamSpec for SeekFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for SeekFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SeekFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SeekFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SeekFlags> for glib::Value {
    #[inline]
    fn from(v: SeekFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstSegmentFlags")]
    pub struct SegmentFlags: u32 {
        #[doc(alias = "GST_SEGMENT_FLAG_RESET")]
        const RESET = ffi::GST_SEGMENT_FLAG_RESET as _;
        #[doc(alias = "GST_SEGMENT_FLAG_TRICKMODE")]
        const TRICKMODE = ffi::GST_SEGMENT_FLAG_TRICKMODE as _;
        #[doc(alias = "GST_SEGMENT_FLAG_SKIP")]
        const SKIP = ffi::GST_SEGMENT_FLAG_SKIP as _;
        #[doc(alias = "GST_SEGMENT_FLAG_SEGMENT")]
        const SEGMENT = ffi::GST_SEGMENT_FLAG_SEGMENT as _;
        #[doc(alias = "GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS")]
        const TRICKMODE_KEY_UNITS = ffi::GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS as _;
        #[cfg(feature = "v1_18")]
        #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
        #[doc(alias = "GST_SEGMENT_FLAG_TRICKMODE_FORWARD_PREDICTED")]
        const TRICKMODE_FORWARD_PREDICTED = ffi::GST_SEGMENT_FLAG_TRICKMODE_FORWARD_PREDICTED as _;
        #[doc(alias = "GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO")]
        const TRICKMODE_NO_AUDIO = ffi::GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO as _;
    }
}

#[doc(hidden)]
impl IntoGlib for SegmentFlags {
    type GlibType = ffi::GstSegmentFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstSegmentFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstSegmentFlags> for SegmentFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstSegmentFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SegmentFlags {
    #[inline]
    #[doc(alias = "gst_segment_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_segment_flags_get_type()) }
    }
}

impl glib::HasParamSpec for SegmentFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for SegmentFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SegmentFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SegmentFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SegmentFlags> for glib::Value {
    #[inline]
    fn from(v: SegmentFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(feature = "v1_20")]
bitflags! {
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstSerializeFlags")]
    pub struct SerializeFlags: u32 {
        #[doc(alias = "GST_SERIALIZE_FLAG_NONE")]
        const NONE = ffi::GST_SERIALIZE_FLAG_NONE as _;
        #[doc(alias = "GST_SERIALIZE_FLAG_BACKWARD_COMPAT")]
        const BACKWARD_COMPAT = ffi::GST_SERIALIZE_FLAG_BACKWARD_COMPAT as _;
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl IntoGlib for SerializeFlags {
    type GlibType = ffi::GstSerializeFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstSerializeFlags {
        self.bits()
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
#[doc(hidden)]
impl FromGlib<ffi::GstSerializeFlags> for SerializeFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstSerializeFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl StaticType for SerializeFlags {
    #[inline]
    #[doc(alias = "gst_serialize_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_serialize_flags_get_type()) }
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::HasParamSpec for SerializeFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl glib::value::ValueType for SerializeFlags {
    type Type = Self;
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
unsafe impl<'a> glib::value::FromValue<'a> for SerializeFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl ToValue for SerializeFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(feature = "v1_20")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
impl From<SerializeFlags> for glib::Value {
    #[inline]
    fn from(v: SerializeFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstStackTraceFlags")]
    pub struct StackTraceFlags: u32 {
        #[doc(alias = "GST_STACK_TRACE_SHOW_FULL")]
        const FULL = ffi::GST_STACK_TRACE_SHOW_FULL as _;
    }
}

#[doc(hidden)]
impl IntoGlib for StackTraceFlags {
    type GlibType = ffi::GstStackTraceFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstStackTraceFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstStackTraceFlags> for StackTraceFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstStackTraceFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for StackTraceFlags {
    #[inline]
    #[doc(alias = "gst_stack_trace_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_stack_trace_flags_get_type()) }
    }
}

impl glib::HasParamSpec for StackTraceFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for StackTraceFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for StackTraceFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for StackTraceFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<StackTraceFlags> for glib::Value {
    #[inline]
    fn from(v: StackTraceFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstStreamFlags")]
    pub struct StreamFlags: u32 {
        #[doc(alias = "GST_STREAM_FLAG_SPARSE")]
        const SPARSE = ffi::GST_STREAM_FLAG_SPARSE as _;
        #[doc(alias = "GST_STREAM_FLAG_SELECT")]
        const SELECT = ffi::GST_STREAM_FLAG_SELECT as _;
        #[doc(alias = "GST_STREAM_FLAG_UNSELECT")]
        const UNSELECT = ffi::GST_STREAM_FLAG_UNSELECT as _;
    }
}

#[doc(hidden)]
impl IntoGlib for StreamFlags {
    type GlibType = ffi::GstStreamFlags;

    #[inline]
    fn into_glib(self) -> ffi::GstStreamFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstStreamFlags> for StreamFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GstStreamFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for StreamFlags {
    #[inline]
    #[doc(alias = "gst_stream_flags_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_stream_flags_get_type()) }
    }
}

impl glib::HasParamSpec for StreamFlags {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for StreamFlags {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for StreamFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for StreamFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<StreamFlags> for glib::Value {
    #[inline]
    fn from(v: StreamFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[doc(alias = "GstStreamType")]
    pub struct StreamType: u32 {
        #[doc(alias = "GST_STREAM_TYPE_UNKNOWN")]
        const UNKNOWN = ffi::GST_STREAM_TYPE_UNKNOWN as _;
        #[doc(alias = "GST_STREAM_TYPE_AUDIO")]
        const AUDIO = ffi::GST_STREAM_TYPE_AUDIO as _;
        #[doc(alias = "GST_STREAM_TYPE_VIDEO")]
        const VIDEO = ffi::GST_STREAM_TYPE_VIDEO as _;
        #[doc(alias = "GST_STREAM_TYPE_CONTAINER")]
        const CONTAINER = ffi::GST_STREAM_TYPE_CONTAINER as _;
        #[doc(alias = "GST_STREAM_TYPE_TEXT")]
        const TEXT = ffi::GST_STREAM_TYPE_TEXT as _;
    }
}

impl StreamType {
    pub fn name<'a>(self) -> &'a GStr {
        unsafe {
            GStr::from_ptr(
                ffi::gst_stream_type_get_name(self.into_glib())
                    .as_ref()
                    .expect("gst_stream_type_get_name returned NULL"),
            )
        }
    }
}

impl std::fmt::Display for StreamType {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.write_str(&self.name())
    }
}

#[doc(hidden)]
impl IntoGlib for StreamType {
    type GlibType = ffi::GstStreamType;

    #[inline]
    fn into_glib(self) -> ffi::GstStreamType {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GstStreamType> for StreamType {
    #[inline]
    unsafe fn from_glib(value: ffi::GstStreamType) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for StreamType {
    #[inline]
    #[doc(alias = "gst_stream_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::gst_stream_type_get_type()) }
    }
}

impl glib::HasParamSpec for StreamType {
    type ParamSpec = glib::ParamSpecFlags;
    type SetValue = Self;
    type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder
    }
}

impl glib::value::ValueType for StreamType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for StreamType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for StreamType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<StreamType> for glib::Value {
    #[inline]
    fn from(v: StreamType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
