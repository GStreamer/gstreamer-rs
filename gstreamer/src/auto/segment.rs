// This file was generated by gir (a01311c+) from gir-files (???)
// DO NOT EDIT

use Format;
use SeekFlags;
use SeekType;
use ffi;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use std::mem;
use std::ptr;

glib_wrapper! {
    pub struct Segment(Boxed<ffi::GstSegment>);

    match fn {
        copy => |ptr| ffi::gst_segment_copy(mut_override(ptr)),
        free => |ptr| ffi::gst_segment_free(ptr),
        get_type => || ffi::gst_segment_get_type(),
    }
}

impl Segment {
    pub fn new() -> Segment {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gst_segment_new())
        }
    }

    pub fn clip(&self, format: Format, start: u64, stop: u64) -> Option<(u64, u64)> {
        unsafe {
            let mut clip_start = mem::uninitialized();
            let mut clip_stop = mem::uninitialized();
            let ret = from_glib(ffi::gst_segment_clip(self.to_glib_none().0, format.to_glib(), start, stop, &mut clip_start, &mut clip_stop));
            if ret { Some((clip_start, clip_stop)) } else { None }
        }
    }

    pub fn copy_into(&self, dest: &mut Segment) {
        unsafe {
            ffi::gst_segment_copy_into(self.to_glib_none().0, dest.to_glib_none_mut().0);
        }
    }

    pub fn do_seek(&mut self, rate: f64, format: Format, flags: SeekFlags, start_type: SeekType, start: u64, stop_type: SeekType, stop: u64) -> Option<bool> {
        unsafe {
            let mut update = mem::uninitialized();
            let ret = from_glib(ffi::gst_segment_do_seek(self.to_glib_none_mut().0, rate, format.to_glib(), flags.to_glib(), start_type.to_glib(), start, stop_type.to_glib(), stop, &mut update));
            if ret { Some(from_glib(update)) } else { None }
        }
    }

    pub fn init(&mut self, format: Format) {
        unsafe {
            ffi::gst_segment_init(self.to_glib_none_mut().0, format.to_glib());
        }
    }

    fn is_equal(&self, s1: &Segment) -> bool {
        unsafe {
            from_glib(ffi::gst_segment_is_equal(self.to_glib_none().0, s1.to_glib_none().0))
        }
    }

    pub fn offset_running_time(&mut self, format: Format, offset: i64) -> bool {
        unsafe {
            from_glib(ffi::gst_segment_offset_running_time(self.to_glib_none_mut().0, format.to_glib(), offset))
        }
    }

    pub fn position_from_running_time(&self, format: Format, running_time: u64) -> u64 {
        unsafe {
            ffi::gst_segment_position_from_running_time(self.to_glib_none().0, format.to_glib(), running_time)
        }
    }

    pub fn position_from_running_time_full(&self, format: Format, running_time: u64) -> (i32, u64) {
        unsafe {
            let mut position = mem::uninitialized();
            let ret = ffi::gst_segment_position_from_running_time_full(self.to_glib_none().0, format.to_glib(), running_time, &mut position);
            (ret, position)
        }
    }

    pub fn position_from_stream_time(&self, format: Format, stream_time: u64) -> u64 {
        unsafe {
            ffi::gst_segment_position_from_stream_time(self.to_glib_none().0, format.to_glib(), stream_time)
        }
    }

    pub fn position_from_stream_time_full(&self, format: Format, stream_time: u64) -> (i32, u64) {
        unsafe {
            let mut position = mem::uninitialized();
            let ret = ffi::gst_segment_position_from_stream_time_full(self.to_glib_none().0, format.to_glib(), stream_time, &mut position);
            (ret, position)
        }
    }

    pub fn set_running_time(&mut self, format: Format, running_time: u64) -> bool {
        unsafe {
            from_glib(ffi::gst_segment_set_running_time(self.to_glib_none_mut().0, format.to_glib(), running_time))
        }
    }

    pub fn to_position(&self, format: Format, running_time: u64) -> u64 {
        unsafe {
            ffi::gst_segment_to_position(self.to_glib_none().0, format.to_glib(), running_time)
        }
    }

    pub fn to_running_time(&self, format: Format, position: u64) -> u64 {
        unsafe {
            ffi::gst_segment_to_running_time(self.to_glib_none().0, format.to_glib(), position)
        }
    }

    pub fn to_running_time_full(&self, format: Format, position: u64) -> (i32, u64) {
        unsafe {
            let mut running_time = mem::uninitialized();
            let ret = ffi::gst_segment_to_running_time_full(self.to_glib_none().0, format.to_glib(), position, &mut running_time);
            (ret, running_time)
        }
    }

    pub fn to_stream_time(&self, format: Format, position: u64) -> u64 {
        unsafe {
            ffi::gst_segment_to_stream_time(self.to_glib_none().0, format.to_glib(), position)
        }
    }

    pub fn to_stream_time_full(&self, format: Format, position: u64) -> (i32, u64) {
        unsafe {
            let mut stream_time = mem::uninitialized();
            let ret = ffi::gst_segment_to_stream_time_full(self.to_glib_none().0, format.to_glib(), position, &mut stream_time);
            (ret, stream_time)
        }
    }
}

impl PartialEq for Segment {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.is_equal(other)
    }
}

impl Eq for Segment {}

unsafe impl Send for Segment {}
