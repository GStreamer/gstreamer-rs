// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use MIKEYCacheType;
use MIKEYMapType;
use MIKEYPRFFunc;
use MIKEYPayload;
use MIKEYPayloadType;
use MIKEYType;
use ffi;
use glib;
use glib::translate::*;
use gobject_ffi;
use gst;

glib_wrapper! {
    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct MIKEYMessage(Boxed<ffi::GstMIKEYMessage>);

    match fn {
        copy => |ptr| gobject_ffi::g_boxed_copy(ffi::gst_mikey_message_get_type(), ptr as *mut _) as *mut ffi::GstMIKEYMessage,
        free => |ptr| gobject_ffi::g_boxed_free(ffi::gst_mikey_message_get_type(), ptr as *mut _),
        get_type => || ffi::gst_mikey_message_get_type(),
    }
}

impl MIKEYMessage {
    pub fn new() -> MIKEYMessage {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gst_mikey_message_new())
        }
    }

    //pub fn new_from_bytes(bytes: &glib::Bytes, info: /*Ignored*/&mut MIKEYDecryptInfo, error: /*Ignored*/Option<Error>) -> MIKEYMessage {
    //    unsafe { TODO: call ffi::gst_mikey_message_new_from_bytes() }
    //}

    pub fn new_from_caps(caps: &gst::Caps) -> MIKEYMessage {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gst_mikey_message_new_from_caps(caps.to_glib_none().0))
        }
    }

    //pub fn new_from_data(data: &[u8], info: /*Ignored*/&mut MIKEYDecryptInfo, error: /*Ignored*/Option<Error>) -> MIKEYMessage {
    //    unsafe { TODO: call ffi::gst_mikey_message_new_from_data() }
    //}

    pub fn add_cs_srtp(&mut self, policy: u8, ssrc: u32, roc: u32) -> Result<(), glib::error::BoolError> {
        unsafe {
            glib_result_from_gboolean!(ffi::gst_mikey_message_add_cs_srtp(self.to_glib_none_mut().0, policy, ssrc, roc), "Failed to add the Crypto policy for SRTP")
        }
    }

    pub fn add_pke(&mut self, C: MIKEYCacheType, data: &[u8]) -> Result<(), glib::error::BoolError> {
        let data_len = data.len() as u16;
        unsafe {
            glib_result_from_gboolean!(ffi::gst_mikey_message_add_pke(self.to_glib_none_mut().0, C.to_glib(), data_len, data.to_glib_none().0), "Failed to add the PKE payload")
        }
    }

    pub fn add_rand(&mut self, rand: &[u8]) -> Result<(), glib::error::BoolError> {
        let len = rand.len() as u8;
        unsafe {
            glib_result_from_gboolean!(ffi::gst_mikey_message_add_rand(self.to_glib_none_mut().0, len, rand.to_glib_none().0), "Failed to add the RAND payload")
        }
    }

    pub fn add_rand_len(&mut self, len: u8) -> Result<(), glib::error::BoolError> {
        unsafe {
            glib_result_from_gboolean!(ffi::gst_mikey_message_add_rand_len(self.to_glib_none_mut().0, len), "Failed to add the RAND payload with random bytes")
        }
    }

    //pub fn add_t(&mut self, type_: MIKEYTSType, ts_value: &[u8]) -> Result<(), glib::error::BoolError> {
    //    unsafe { TODO: call ffi::gst_mikey_message_add_t() }
    //}

    pub fn add_t_now_ntp_utc(&mut self) -> Result<(), glib::error::BoolError> {
        unsafe {
            glib_result_from_gboolean!(ffi::gst_mikey_message_add_t_now_ntp_utc(self.to_glib_none_mut().0), "Failed to add the T payload with current time")
        }
    }

    pub fn find_payload(&self, type_: MIKEYPayloadType, nth: u32) -> Option<MIKEYPayload> {
        unsafe {
            from_glib_none(ffi::gst_mikey_message_find_payload(self.to_glib_none().0, type_.to_glib(), nth))
        }
    }

    //pub fn get_cs_srtp(&self, idx: u32) -> /*Ignored*/Option<MIKEYMapSRTP> {
    //    unsafe { TODO: call ffi::gst_mikey_message_get_cs_srtp() }
    //}

    pub fn get_n_cs(&self) -> u32 {
        unsafe {
            ffi::gst_mikey_message_get_n_cs(self.to_glib_none().0)
        }
    }

    pub fn get_n_payloads(&self) -> u32 {
        unsafe {
            ffi::gst_mikey_message_get_n_payloads(self.to_glib_none().0)
        }
    }

    //pub fn insert_cs_srtp(&mut self, idx: i32, map: /*Ignored*/&MIKEYMapSRTP) -> bool {
    //    unsafe { TODO: call ffi::gst_mikey_message_insert_cs_srtp() }
    //}

    pub fn remove_cs_srtp(&mut self, idx: i32) -> Result<(), glib::error::BoolError> {
        unsafe {
            glib_result_from_gboolean!(ffi::gst_mikey_message_remove_cs_srtp(self.to_glib_none_mut().0, idx), "Failed to remove the SRTP policy")
        }
    }

    pub fn remove_payload(&mut self, idx: u32) -> Result<(), glib::error::BoolError> {
        unsafe {
            glib_result_from_gboolean!(ffi::gst_mikey_message_remove_payload(self.to_glib_none_mut().0, idx), "Failed to remove the payload")
        }
    }

    //pub fn replace_cs_srtp(&mut self, idx: i32, map: /*Ignored*/&MIKEYMapSRTP) -> bool {
    //    unsafe { TODO: call ffi::gst_mikey_message_replace_cs_srtp() }
    //}

    pub fn set_info(&mut self, version: u8, type_: MIKEYType, V: bool, prf_func: MIKEYPRFFunc, CSB_id: u32, map_type: MIKEYMapType) -> Result<(), glib::error::BoolError> {
        unsafe {
            glib_result_from_gboolean!(ffi::gst_mikey_message_set_info(self.to_glib_none_mut().0, version, type_.to_glib(), V.to_glib(), prf_func.to_glib(), CSB_id, map_type.to_glib()), "Failed to set the information")
        }
    }

    //pub fn to_bytes(&mut self, info: /*Ignored*/&mut MIKEYEncryptInfo, error: /*Ignored*/Option<Error>) -> Option<glib::Bytes> {
    //    unsafe { TODO: call ffi::gst_mikey_message_to_bytes() }
    //}

    #[cfg(any(feature = "v1_8_1", feature = "dox"))]
    pub fn to_caps(&self, caps: &gst::Caps) -> Result<(), glib::error::BoolError> {
        unsafe {
            glib_result_from_gboolean!(ffi::gst_mikey_message_to_caps(self.to_glib_none().0, caps.to_glib_none().0), "Failed to fill caps with SRTP parameters")
        }
    }
}

impl Default for MIKEYMessage {
    fn default() -> Self {
        Self::new()
    }
}

unsafe impl Send for MIKEYMessage {}
