// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// from gst-gir-files (https://gitlab.freedesktop.org/gstreamer/gir-files-rs.git)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use glib_sys as glib;
use gobject_sys as gobject;
use gstreamer_base_sys as gst_base;
use gstreamer_sys as gst;

#[cfg(unix)]
#[allow(unused_imports)]
use libc::{dev_t, gid_t, pid_t, socklen_t, uid_t};
#[allow(unused_imports)]
use libc::{intptr_t, off_t, size_t, ssize_t, time_t, uintptr_t, FILE};
#[allow(unused_imports)]
use std::ffi::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type GstAudioBaseSinkDiscontReason = c_int;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_NO_DISCONT: GstAudioBaseSinkDiscontReason = 0;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_NEW_CAPS: GstAudioBaseSinkDiscontReason = 1;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_FLUSH: GstAudioBaseSinkDiscontReason = 2;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_SYNC_LATENCY: GstAudioBaseSinkDiscontReason = 3;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_ALIGNMENT: GstAudioBaseSinkDiscontReason = 4;
pub const GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE: GstAudioBaseSinkDiscontReason = 5;

pub type GstAudioBaseSinkSlaveMethod = c_int;
pub const GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE: GstAudioBaseSinkSlaveMethod = 0;
pub const GST_AUDIO_BASE_SINK_SLAVE_SKEW: GstAudioBaseSinkSlaveMethod = 1;
pub const GST_AUDIO_BASE_SINK_SLAVE_NONE: GstAudioBaseSinkSlaveMethod = 2;
pub const GST_AUDIO_BASE_SINK_SLAVE_CUSTOM: GstAudioBaseSinkSlaveMethod = 3;

pub type GstAudioBaseSrcSlaveMethod = c_int;
pub const GST_AUDIO_BASE_SRC_SLAVE_RESAMPLE: GstAudioBaseSrcSlaveMethod = 0;
pub const GST_AUDIO_BASE_SRC_SLAVE_RE_TIMESTAMP: GstAudioBaseSrcSlaveMethod = 1;
pub const GST_AUDIO_BASE_SRC_SLAVE_SKEW: GstAudioBaseSrcSlaveMethod = 2;
pub const GST_AUDIO_BASE_SRC_SLAVE_NONE: GstAudioBaseSrcSlaveMethod = 3;

pub type GstAudioCdSrcMode = c_int;
pub const GST_AUDIO_CD_SRC_MODE_NORMAL: GstAudioCdSrcMode = 0;
pub const GST_AUDIO_CD_SRC_MODE_CONTINUOUS: GstAudioCdSrcMode = 1;

pub type GstAudioChannelPosition = c_int;
pub const GST_AUDIO_CHANNEL_POSITION_NONE: GstAudioChannelPosition = -3;
pub const GST_AUDIO_CHANNEL_POSITION_MONO: GstAudioChannelPosition = -2;
pub const GST_AUDIO_CHANNEL_POSITION_INVALID: GstAudioChannelPosition = -1;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT: GstAudioChannelPosition = 0;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT: GstAudioChannelPosition = 1;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER: GstAudioChannelPosition = 2;
pub const GST_AUDIO_CHANNEL_POSITION_LFE1: GstAudioChannelPosition = 3;
pub const GST_AUDIO_CHANNEL_POSITION_REAR_LEFT: GstAudioChannelPosition = 4;
pub const GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT: GstAudioChannelPosition = 5;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER: GstAudioChannelPosition = 6;
pub const GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER: GstAudioChannelPosition = 7;
pub const GST_AUDIO_CHANNEL_POSITION_REAR_CENTER: GstAudioChannelPosition = 8;
pub const GST_AUDIO_CHANNEL_POSITION_LFE2: GstAudioChannelPosition = 9;
pub const GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT: GstAudioChannelPosition = 10;
pub const GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT: GstAudioChannelPosition = 11;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT: GstAudioChannelPosition = 12;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT: GstAudioChannelPosition = 13;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER: GstAudioChannelPosition = 14;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_CENTER: GstAudioChannelPosition = 15;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT: GstAudioChannelPosition = 16;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT: GstAudioChannelPosition = 17;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT: GstAudioChannelPosition = 18;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT: GstAudioChannelPosition = 19;
pub const GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER: GstAudioChannelPosition = 20;
pub const GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER: GstAudioChannelPosition = 21;
pub const GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT: GstAudioChannelPosition = 22;
pub const GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT: GstAudioChannelPosition = 23;
pub const GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT: GstAudioChannelPosition = 24;
pub const GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT: GstAudioChannelPosition = 25;
pub const GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT: GstAudioChannelPosition = 26;
pub const GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT: GstAudioChannelPosition = 27;
#[cfg(feature = "v1_26")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
pub const GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_LEFT: GstAudioChannelPosition = 28;
#[cfg(feature = "v1_26")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
pub const GST_AUDIO_CHANNEL_POSITION_TOP_SURROUND_RIGHT: GstAudioChannelPosition = 29;

pub type GstAudioDitherMethod = c_int;
pub const GST_AUDIO_DITHER_NONE: GstAudioDitherMethod = 0;
pub const GST_AUDIO_DITHER_RPDF: GstAudioDitherMethod = 1;
pub const GST_AUDIO_DITHER_TPDF: GstAudioDitherMethod = 2;
pub const GST_AUDIO_DITHER_TPDF_HF: GstAudioDitherMethod = 3;

pub type GstAudioFormat = c_int;
pub const GST_AUDIO_FORMAT_UNKNOWN: GstAudioFormat = 0;
pub const GST_AUDIO_FORMAT_ENCODED: GstAudioFormat = 1;
pub const GST_AUDIO_FORMAT_S8: GstAudioFormat = 2;
pub const GST_AUDIO_FORMAT_U8: GstAudioFormat = 3;
pub const GST_AUDIO_FORMAT_S16LE: GstAudioFormat = 4;
pub const GST_AUDIO_FORMAT_S16BE: GstAudioFormat = 5;
pub const GST_AUDIO_FORMAT_U16LE: GstAudioFormat = 6;
pub const GST_AUDIO_FORMAT_U16BE: GstAudioFormat = 7;
pub const GST_AUDIO_FORMAT_S24_32LE: GstAudioFormat = 8;
pub const GST_AUDIO_FORMAT_S24_32BE: GstAudioFormat = 9;
pub const GST_AUDIO_FORMAT_U24_32LE: GstAudioFormat = 10;
pub const GST_AUDIO_FORMAT_U24_32BE: GstAudioFormat = 11;
pub const GST_AUDIO_FORMAT_S32LE: GstAudioFormat = 12;
pub const GST_AUDIO_FORMAT_S32BE: GstAudioFormat = 13;
pub const GST_AUDIO_FORMAT_U32LE: GstAudioFormat = 14;
pub const GST_AUDIO_FORMAT_U32BE: GstAudioFormat = 15;
pub const GST_AUDIO_FORMAT_S24LE: GstAudioFormat = 16;
pub const GST_AUDIO_FORMAT_S24BE: GstAudioFormat = 17;
pub const GST_AUDIO_FORMAT_U24LE: GstAudioFormat = 18;
pub const GST_AUDIO_FORMAT_U24BE: GstAudioFormat = 19;
pub const GST_AUDIO_FORMAT_S20LE: GstAudioFormat = 20;
pub const GST_AUDIO_FORMAT_S20BE: GstAudioFormat = 21;
pub const GST_AUDIO_FORMAT_U20LE: GstAudioFormat = 22;
pub const GST_AUDIO_FORMAT_U20BE: GstAudioFormat = 23;
pub const GST_AUDIO_FORMAT_S18LE: GstAudioFormat = 24;
pub const GST_AUDIO_FORMAT_S18BE: GstAudioFormat = 25;
pub const GST_AUDIO_FORMAT_U18LE: GstAudioFormat = 26;
pub const GST_AUDIO_FORMAT_U18BE: GstAudioFormat = 27;
pub const GST_AUDIO_FORMAT_F32LE: GstAudioFormat = 28;
pub const GST_AUDIO_FORMAT_F32BE: GstAudioFormat = 29;
pub const GST_AUDIO_FORMAT_F64LE: GstAudioFormat = 30;
pub const GST_AUDIO_FORMAT_F64BE: GstAudioFormat = 31;

pub type GstAudioLayout = c_int;
pub const GST_AUDIO_LAYOUT_INTERLEAVED: GstAudioLayout = 0;
pub const GST_AUDIO_LAYOUT_NON_INTERLEAVED: GstAudioLayout = 1;

pub type GstAudioNoiseShapingMethod = c_int;
pub const GST_AUDIO_NOISE_SHAPING_NONE: GstAudioNoiseShapingMethod = 0;
pub const GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK: GstAudioNoiseShapingMethod = 1;
pub const GST_AUDIO_NOISE_SHAPING_SIMPLE: GstAudioNoiseShapingMethod = 2;
pub const GST_AUDIO_NOISE_SHAPING_MEDIUM: GstAudioNoiseShapingMethod = 3;
pub const GST_AUDIO_NOISE_SHAPING_HIGH: GstAudioNoiseShapingMethod = 4;

pub type GstAudioResamplerFilterInterpolation = c_int;
pub const GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE: GstAudioResamplerFilterInterpolation = 0;
pub const GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_LINEAR: GstAudioResamplerFilterInterpolation = 1;
pub const GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_CUBIC: GstAudioResamplerFilterInterpolation = 2;

pub type GstAudioResamplerFilterMode = c_int;
pub const GST_AUDIO_RESAMPLER_FILTER_MODE_INTERPOLATED: GstAudioResamplerFilterMode = 0;
pub const GST_AUDIO_RESAMPLER_FILTER_MODE_FULL: GstAudioResamplerFilterMode = 1;
pub const GST_AUDIO_RESAMPLER_FILTER_MODE_AUTO: GstAudioResamplerFilterMode = 2;

pub type GstAudioResamplerMethod = c_int;
pub const GST_AUDIO_RESAMPLER_METHOD_NEAREST: GstAudioResamplerMethod = 0;
pub const GST_AUDIO_RESAMPLER_METHOD_LINEAR: GstAudioResamplerMethod = 1;
pub const GST_AUDIO_RESAMPLER_METHOD_CUBIC: GstAudioResamplerMethod = 2;
pub const GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL: GstAudioResamplerMethod = 3;
pub const GST_AUDIO_RESAMPLER_METHOD_KAISER: GstAudioResamplerMethod = 4;

pub type GstAudioRingBufferFormatType = c_int;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW: GstAudioRingBufferFormatType = 0;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW: GstAudioRingBufferFormatType = 1;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW: GstAudioRingBufferFormatType = 2;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IMA_ADPCM: GstAudioRingBufferFormatType = 3;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG: GstAudioRingBufferFormatType = 4;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_GSM: GstAudioRingBufferFormatType = 5;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958: GstAudioRingBufferFormatType = 6;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3: GstAudioRingBufferFormatType = 7;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3: GstAudioRingBufferFormatType = 8;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS: GstAudioRingBufferFormatType = 9;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC: GstAudioRingBufferFormatType = 10;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC: GstAudioRingBufferFormatType = 11;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW: GstAudioRingBufferFormatType = 12;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW: GstAudioRingBufferFormatType = 13;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC: GstAudioRingBufferFormatType = 14;
pub const GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DSD: GstAudioRingBufferFormatType = 15;

pub type GstAudioRingBufferState = c_int;
pub const GST_AUDIO_RING_BUFFER_STATE_STOPPED: GstAudioRingBufferState = 0;
pub const GST_AUDIO_RING_BUFFER_STATE_PAUSED: GstAudioRingBufferState = 1;
pub const GST_AUDIO_RING_BUFFER_STATE_STARTED: GstAudioRingBufferState = 2;
pub const GST_AUDIO_RING_BUFFER_STATE_ERROR: GstAudioRingBufferState = 3;

pub type GstDsdFormat = c_int;
pub const GST_DSD_FORMAT_UNKNOWN: GstDsdFormat = 0;
pub const GST_DSD_FORMAT_U8: GstDsdFormat = 1;
pub const GST_DSD_FORMAT_U16LE: GstDsdFormat = 2;
pub const GST_DSD_FORMAT_U16BE: GstDsdFormat = 3;
pub const GST_DSD_FORMAT_U32LE: GstDsdFormat = 4;
pub const GST_DSD_FORMAT_U32BE: GstDsdFormat = 5;
pub const GST_NUM_DSD_FORMATS: GstDsdFormat = 6;
pub const GST_DSD_FORMAT_U16: GstDsdFormat = 2;
pub const GST_DSD_FORMAT_U32: GstDsdFormat = 4;

pub type GstStreamVolumeFormat = c_int;
pub const GST_STREAM_VOLUME_FORMAT_LINEAR: GstStreamVolumeFormat = 0;
pub const GST_STREAM_VOLUME_FORMAT_CUBIC: GstStreamVolumeFormat = 1;
pub const GST_STREAM_VOLUME_FORMAT_DB: GstStreamVolumeFormat = 2;

// Constants
pub const GST_AUDIO_CHANNELS_RANGE: &[u8] = b"(int) [ 1, max ]\0";
pub const GST_AUDIO_CONVERTER_OPT_DITHER_METHOD: &[u8] = b"GstAudioConverter.dither-method\0";
pub const GST_AUDIO_CONVERTER_OPT_DITHER_THRESHOLD: &[u8] = b"GstAudioConverter.dither-threshold\0";
pub const GST_AUDIO_CONVERTER_OPT_MIX_MATRIX: &[u8] = b"GstAudioConverter.mix-matrix\0";
pub const GST_AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD: &[u8] =
    b"GstAudioConverter.noise-shaping-method\0";
pub const GST_AUDIO_CONVERTER_OPT_QUANTIZATION: &[u8] = b"GstAudioConverter.quantization\0";
pub const GST_AUDIO_CONVERTER_OPT_RESAMPLER_METHOD: &[u8] = b"GstAudioConverter.resampler-method\0";
pub const GST_AUDIO_DECODER_MAX_ERRORS: c_int = -1;
pub const GST_AUDIO_DECODER_SINK_NAME: &[u8] = b"sink\0";
pub const GST_AUDIO_DECODER_SRC_NAME: &[u8] = b"src\0";
pub const GST_AUDIO_DEF_CHANNELS: c_int = 2;
pub const GST_AUDIO_DEF_FORMAT: &[u8] = b"S16LE\0";
pub const GST_AUDIO_DEF_RATE: c_int = 44100;
pub const GST_AUDIO_ENCODER_SINK_NAME: &[u8] = b"sink\0";
pub const GST_AUDIO_ENCODER_SRC_NAME: &[u8] = b"src\0";
pub const GST_AUDIO_FORMAT_LAST: c_int = 32;
pub const GST_AUDIO_RATE_RANGE: &[u8] = b"(int) [ 1, max ]\0";
pub const GST_AUDIO_RESAMPLER_OPT_CUBIC_B: &[u8] = b"GstAudioResampler.cubic-b\0";
pub const GST_AUDIO_RESAMPLER_OPT_CUBIC_C: &[u8] = b"GstAudioResampler.cubic-c\0";
pub const GST_AUDIO_RESAMPLER_OPT_CUTOFF: &[u8] = b"GstAudioResampler.cutoff\0";
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_INTERPOLATION: &[u8] =
    b"GstAudioResampler.filter-interpolation\0";
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_MODE: &[u8] = b"GstAudioResampler.filter-mode\0";
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_MODE_THRESHOLD: &[u8] =
    b"GstAudioResampler.filter-mode-threshold\0";
pub const GST_AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE: &[u8] =
    b"GstAudioResampler.filter-oversample\0";
pub const GST_AUDIO_RESAMPLER_OPT_MAX_PHASE_ERROR: &[u8] = b"GstAudioResampler.max-phase-error\0";
pub const GST_AUDIO_RESAMPLER_OPT_N_TAPS: &[u8] = b"GstAudioResampler.n-taps\0";
pub const GST_AUDIO_RESAMPLER_OPT_STOP_ATTENUATION: &[u8] =
    b"GstAudioResampler.stop-attenutation\0";
pub const GST_AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH: &[u8] =
    b"GstAudioResampler.transition-bandwidth\0";
pub const GST_AUDIO_RESAMPLER_QUALITY_DEFAULT: c_int = 4;
pub const GST_AUDIO_RESAMPLER_QUALITY_MAX: c_int = 10;
pub const GST_AUDIO_RESAMPLER_QUALITY_MIN: c_int = 0;
pub const GST_DSD_FORMATS_ALL: &[u8] = b"{ DSDU32BE, DSDU16BE, DSDU8, DSDU32LE, DSDU16LE }\0";
pub const GST_DSD_MEDIA_TYPE: &[u8] = b"audio/x-dsd\0";
pub const GST_DSD_SILENCE_PATTERN_BYTE: c_int = 105;
pub const GST_META_TAG_AUDIO_CHANNELS_STR: &[u8] = b"channels\0";
pub const GST_META_TAG_AUDIO_RATE_STR: &[u8] = b"rate\0";
pub const GST_META_TAG_AUDIO_STR: &[u8] = b"audio\0";
pub const GST_META_TAG_DSD_PLANE_OFFSETS_STR: &[u8] = b"dsdplaneoffsets\0";

// Flags
pub type GstAudioChannelMixerFlags = c_uint;
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_NONE: GstAudioChannelMixerFlags = 0;
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_IN: GstAudioChannelMixerFlags = 1;
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_OUT: GstAudioChannelMixerFlags = 2;
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_IN: GstAudioChannelMixerFlags = 4;
pub const GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_OUT: GstAudioChannelMixerFlags = 8;

pub type GstAudioConverterFlags = c_uint;
pub const GST_AUDIO_CONVERTER_FLAG_NONE: GstAudioConverterFlags = 0;
pub const GST_AUDIO_CONVERTER_FLAG_IN_WRITABLE: GstAudioConverterFlags = 1;
pub const GST_AUDIO_CONVERTER_FLAG_VARIABLE_RATE: GstAudioConverterFlags = 2;

pub type GstAudioFlags = c_uint;
pub const GST_AUDIO_FLAG_NONE: GstAudioFlags = 0;
pub const GST_AUDIO_FLAG_UNPOSITIONED: GstAudioFlags = 1;

pub type GstAudioFormatFlags = c_uint;
pub const GST_AUDIO_FORMAT_FLAG_INTEGER: GstAudioFormatFlags = 1;
pub const GST_AUDIO_FORMAT_FLAG_FLOAT: GstAudioFormatFlags = 2;
pub const GST_AUDIO_FORMAT_FLAG_SIGNED: GstAudioFormatFlags = 4;
pub const GST_AUDIO_FORMAT_FLAG_COMPLEX: GstAudioFormatFlags = 16;
pub const GST_AUDIO_FORMAT_FLAG_UNPACK: GstAudioFormatFlags = 32;

pub type GstAudioPackFlags = c_uint;
pub const GST_AUDIO_PACK_FLAG_NONE: GstAudioPackFlags = 0;
pub const GST_AUDIO_PACK_FLAG_TRUNCATE_RANGE: GstAudioPackFlags = 1;

pub type GstAudioQuantizeFlags = c_uint;
pub const GST_AUDIO_QUANTIZE_FLAG_NONE: GstAudioQuantizeFlags = 0;
pub const GST_AUDIO_QUANTIZE_FLAG_NON_INTERLEAVED: GstAudioQuantizeFlags = 1;

pub type GstAudioResamplerFlags = c_uint;
pub const GST_AUDIO_RESAMPLER_FLAG_NONE: GstAudioResamplerFlags = 0;
pub const GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_IN: GstAudioResamplerFlags = 1;
pub const GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT: GstAudioResamplerFlags = 2;
pub const GST_AUDIO_RESAMPLER_FLAG_VARIABLE_RATE: GstAudioResamplerFlags = 4;

// Unions
#[derive(Copy, Clone)]
#[repr(C)]
pub union GstAudioRingBufferSpec_ABI {
    pub abi: GstAudioRingBufferSpec_ABI_abi,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioRingBufferSpec_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioRingBufferSpec_ABI @ {self:p}"))
            .field("abi", unsafe { &self.abi })
            .finish()
    }
}

// Callbacks
pub type GstAudioBaseSinkCustomSlavingCallback = Option<
    unsafe extern "C" fn(
        *mut GstAudioBaseSink,
        gst::GstClockTime,
        gst::GstClockTime,
        *mut gst::GstClockTimeDiff,
        GstAudioBaseSinkDiscontReason,
        gpointer,
    ),
>;
pub type GstAudioClockGetTimeFunc =
    Option<unsafe extern "C" fn(*mut gst::GstClock, gpointer) -> gst::GstClockTime>;
pub type GstAudioFormatPack = Option<
    unsafe extern "C" fn(
        *const GstAudioFormatInfo,
        GstAudioPackFlags,
        gconstpointer,
        gpointer,
        c_int,
    ),
>;
pub type GstAudioFormatUnpack = Option<
    unsafe extern "C" fn(
        *const GstAudioFormatInfo,
        GstAudioPackFlags,
        gpointer,
        gconstpointer,
        c_int,
    ),
>;
pub type GstAudioRingBufferCallback =
    Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, *mut u8, c_uint, gpointer)>;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioAggregatorClass {
    pub parent_class: gst_base::GstAggregatorClass,
    pub create_output_buffer:
        Option<unsafe extern "C" fn(*mut GstAudioAggregator, c_uint) -> *mut gst::GstBuffer>,
    pub aggregate_one_buffer: Option<
        unsafe extern "C" fn(
            *mut GstAudioAggregator,
            *mut GstAudioAggregatorPad,
            *mut gst::GstBuffer,
            c_uint,
            *mut gst::GstBuffer,
            c_uint,
            c_uint,
        ) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GstAudioAggregatorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioAggregatorClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("create_output_buffer", &self.create_output_buffer)
            .field("aggregate_one_buffer", &self.aggregate_one_buffer)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioAggregatorConvertPadClass {
    pub parent_class: GstAudioAggregatorPadClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioAggregatorConvertPadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioAggregatorConvertPadClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioAggregatorConvertPadPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioAggregatorConvertPadPrivate = _GstAudioAggregatorConvertPadPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioAggregatorPadClass {
    pub parent_class: gst_base::GstAggregatorPadClass,
    pub convert_buffer: Option<
        unsafe extern "C" fn(
            *mut GstAudioAggregatorPad,
            *mut GstAudioInfo,
            *mut GstAudioInfo,
            *mut gst::GstBuffer,
        ) -> *mut gst::GstBuffer,
    >,
    pub update_conversion_info: Option<unsafe extern "C" fn(*mut GstAudioAggregatorPad)>,
    pub _gst_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GstAudioAggregatorPadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioAggregatorPadClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("convert_buffer", &self.convert_buffer)
            .field("update_conversion_info", &self.update_conversion_info)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioAggregatorPadPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioAggregatorPadPrivate = _GstAudioAggregatorPadPrivate;

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioAggregatorPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioAggregatorPrivate = _GstAudioAggregatorPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioBaseSinkClass {
    pub parent_class: gst_base::GstBaseSinkClass,
    pub create_ringbuffer:
        Option<unsafe extern "C" fn(*mut GstAudioBaseSink) -> *mut GstAudioRingBuffer>,
    pub payload: Option<
        unsafe extern "C" fn(*mut GstAudioBaseSink, *mut gst::GstBuffer) -> *mut gst::GstBuffer,
    >,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioBaseSinkClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioBaseSinkClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("create_ringbuffer", &self.create_ringbuffer)
            .field("payload", &self.payload)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioBaseSinkPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioBaseSinkPrivate = _GstAudioBaseSinkPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioBaseSrcClass {
    pub parent_class: gst_base::GstPushSrcClass,
    pub create_ringbuffer:
        Option<unsafe extern "C" fn(*mut GstAudioBaseSrc) -> *mut GstAudioRingBuffer>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioBaseSrcClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioBaseSrcClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("create_ringbuffer", &self.create_ringbuffer)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioBaseSrcPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioBaseSrcPrivate = _GstAudioBaseSrcPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioBuffer {
    pub info: GstAudioInfo,
    pub n_samples: size_t,
    pub n_planes: c_int,
    pub planes: *mut gpointer,
    pub buffer: *mut gst::GstBuffer,
    pub map_infos: *mut gst::GstMapInfo,
    pub priv_planes_arr: [gpointer; 8],
    pub priv_map_infos_arr: [gst::GstMapInfo; 8],
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioBuffer @ {self:p}"))
            .field("info", &self.info)
            .field("n_samples", &self.n_samples)
            .field("n_planes", &self.n_planes)
            .field("planes", &self.planes)
            .field("buffer", &self.buffer)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioCdSrcClass {
    pub pushsrc_class: gst_base::GstPushSrcClass,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioCdSrc, *const c_char) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioCdSrc)>,
    pub read_sector: Option<unsafe extern "C" fn(*mut GstAudioCdSrc, c_int) -> *mut gst::GstBuffer>,
    pub _gst_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GstAudioCdSrcClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioCdSrcClass @ {self:p}"))
            .field("pushsrc_class", &self.pushsrc_class)
            .field("open", &self.open)
            .field("close", &self.close)
            .field("read_sector", &self.read_sector)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioCdSrcPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioCdSrcPrivate = _GstAudioCdSrcPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioCdSrcTrack {
    pub is_audio: gboolean,
    pub num: c_uint,
    pub start: c_uint,
    pub end: c_uint,
    pub tags: *mut gst::GstTagList,
    pub _gst_reserved1: [c_uint; 2],
    pub _gst_reserved2: [gpointer; 2],
}

impl ::std::fmt::Debug for GstAudioCdSrcTrack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioCdSrcTrack @ {self:p}"))
            .field("is_audio", &self.is_audio)
            .field("num", &self.num)
            .field("start", &self.start)
            .field("end", &self.end)
            .field("tags", &self.tags)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioChannelMixer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioChannelMixer = _GstAudioChannelMixer;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioClippingMeta {
    pub meta: gst::GstMeta,
    pub format: gst::GstFormat,
    pub start: u64,
    pub end: u64,
}

impl ::std::fmt::Debug for GstAudioClippingMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioClippingMeta @ {self:p}"))
            .field("meta", &self.meta)
            .field("format", &self.format)
            .field("start", &self.start)
            .field("end", &self.end)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioClockClass {
    pub parent_class: gst::GstSystemClockClass,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioClockClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioClockClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GstAudioConverter {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstAudioConverter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioConverter @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioDecoderClass {
    pub element_class: gst::GstElementClass,
    pub start: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub set_format:
        Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstCaps) -> gboolean>,
    pub parse: Option<
        unsafe extern "C" fn(
            *mut GstAudioDecoder,
            *mut gst_base::GstAdapter,
            *mut c_int,
            *mut c_int,
        ) -> gst::GstFlowReturn,
    >,
    pub handle_frame: Option<
        unsafe extern "C" fn(*mut GstAudioDecoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn,
    >,
    pub flush: Option<unsafe extern "C" fn(*mut GstAudioDecoder, gboolean)>,
    pub pre_push: Option<
        unsafe extern "C" fn(*mut GstAudioDecoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn,
    >,
    pub sink_event:
        Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstEvent) -> gboolean>,
    pub src_event:
        Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstEvent) -> gboolean>,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub negotiate: Option<unsafe extern "C" fn(*mut GstAudioDecoder) -> gboolean>,
    pub decide_allocation:
        Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub propose_allocation:
        Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub sink_query:
        Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub src_query:
        Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstQuery) -> gboolean>,
    pub getcaps:
        Option<unsafe extern "C" fn(*mut GstAudioDecoder, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub transform_meta: Option<
        unsafe extern "C" fn(
            *mut GstAudioDecoder,
            *mut gst::GstBuffer,
            *mut gst::GstMeta,
            *mut gst::GstBuffer,
        ) -> gboolean,
    >,
    pub _gst_reserved: [gpointer; 16],
}

impl ::std::fmt::Debug for GstAudioDecoderClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioDecoderClass @ {self:p}"))
            .field("element_class", &self.element_class)
            .field("start", &self.start)
            .field("stop", &self.stop)
            .field("set_format", &self.set_format)
            .field("parse", &self.parse)
            .field("handle_frame", &self.handle_frame)
            .field("flush", &self.flush)
            .field("pre_push", &self.pre_push)
            .field("sink_event", &self.sink_event)
            .field("src_event", &self.src_event)
            .field("open", &self.open)
            .field("close", &self.close)
            .field("negotiate", &self.negotiate)
            .field("decide_allocation", &self.decide_allocation)
            .field("propose_allocation", &self.propose_allocation)
            .field("sink_query", &self.sink_query)
            .field("src_query", &self.src_query)
            .field("getcaps", &self.getcaps)
            .field("transform_meta", &self.transform_meta)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioDecoderPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioDecoderPrivate = _GstAudioDecoderPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioDownmixMeta {
    pub meta: gst::GstMeta,
    pub from_position: *mut GstAudioChannelPosition,
    pub to_position: *mut GstAudioChannelPosition,
    pub from_channels: c_int,
    pub to_channels: c_int,
    pub matrix: *mut *mut c_float,
}

impl ::std::fmt::Debug for GstAudioDownmixMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioDownmixMeta @ {self:p}"))
            .field("meta", &self.meta)
            .field("from_position", &self.from_position)
            .field("to_position", &self.to_position)
            .field("from_channels", &self.from_channels)
            .field("to_channels", &self.to_channels)
            .field("matrix", &self.matrix)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioEncoderClass {
    pub element_class: gst::GstElementClass,
    pub start: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub set_format:
        Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut GstAudioInfo) -> gboolean>,
    pub handle_frame: Option<
        unsafe extern "C" fn(*mut GstAudioEncoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn,
    >,
    pub flush: Option<unsafe extern "C" fn(*mut GstAudioEncoder)>,
    pub pre_push: Option<
        unsafe extern "C" fn(*mut GstAudioEncoder, *mut *mut gst::GstBuffer) -> gst::GstFlowReturn,
    >,
    pub sink_event:
        Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstEvent) -> gboolean>,
    pub src_event:
        Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstEvent) -> gboolean>,
    pub getcaps:
        Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstCaps) -> *mut gst::GstCaps>,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub negotiate: Option<unsafe extern "C" fn(*mut GstAudioEncoder) -> gboolean>,
    pub decide_allocation:
        Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub propose_allocation:
        Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub transform_meta: Option<
        unsafe extern "C" fn(
            *mut GstAudioEncoder,
            *mut gst::GstBuffer,
            *mut gst::GstMeta,
            *mut gst::GstBuffer,
        ) -> gboolean,
    >,
    pub sink_query:
        Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub src_query:
        Option<unsafe extern "C" fn(*mut GstAudioEncoder, *mut gst::GstQuery) -> gboolean>,
    pub _gst_reserved: [gpointer; 17],
}

impl ::std::fmt::Debug for GstAudioEncoderClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioEncoderClass @ {self:p}"))
            .field("element_class", &self.element_class)
            .field("start", &self.start)
            .field("stop", &self.stop)
            .field("set_format", &self.set_format)
            .field("handle_frame", &self.handle_frame)
            .field("flush", &self.flush)
            .field("pre_push", &self.pre_push)
            .field("sink_event", &self.sink_event)
            .field("src_event", &self.src_event)
            .field("getcaps", &self.getcaps)
            .field("open", &self.open)
            .field("close", &self.close)
            .field("negotiate", &self.negotiate)
            .field("decide_allocation", &self.decide_allocation)
            .field("propose_allocation", &self.propose_allocation)
            .field("transform_meta", &self.transform_meta)
            .field("sink_query", &self.sink_query)
            .field("src_query", &self.src_query)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioEncoderPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioEncoderPrivate = _GstAudioEncoderPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioFilterClass {
    pub basetransformclass: gst_base::GstBaseTransformClass,
    pub setup: Option<unsafe extern "C" fn(*mut GstAudioFilter, *const GstAudioInfo) -> gboolean>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioFilterClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioFilterClass @ {self:p}"))
            .field("basetransformclass", &self.basetransformclass)
            .field("setup", &self.setup)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioFormatInfo {
    pub format: GstAudioFormat,
    pub name: *const c_char,
    pub description: *const c_char,
    pub flags: GstAudioFormatFlags,
    pub endianness: c_int,
    pub width: c_int,
    pub depth: c_int,
    pub silence: [u8; 8],
    pub unpack_format: GstAudioFormat,
    pub unpack_func: GstAudioFormatUnpack,
    pub pack_func: GstAudioFormatPack,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioFormatInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioFormatInfo @ {self:p}"))
            .field("format", &self.format)
            .field("name", &self.name)
            .field("description", &self.description)
            .field("flags", &self.flags)
            .field("endianness", &self.endianness)
            .field("width", &self.width)
            .field("depth", &self.depth)
            .field("silence", &self.silence)
            .field("unpack_format", &self.unpack_format)
            .field("unpack_func", &self.unpack_func)
            .field("pack_func", &self.pack_func)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioInfo {
    pub finfo: *const GstAudioFormatInfo,
    pub flags: GstAudioFlags,
    pub layout: GstAudioLayout,
    pub rate: c_int,
    pub channels: c_int,
    pub bpf: c_int,
    pub position: [GstAudioChannelPosition; 64],
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioInfo @ {self:p}"))
            .field("finfo", &self.finfo)
            .field("flags", &self.flags)
            .field("layout", &self.layout)
            .field("rate", &self.rate)
            .field("channels", &self.channels)
            .field("bpf", &self.bpf)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioLevelMeta {
    pub meta: gst::GstMeta,
    pub level: u8,
    pub voice_activity: gboolean,
}

impl ::std::fmt::Debug for GstAudioLevelMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioLevelMeta @ {self:p}"))
            .field("meta", &self.meta)
            .field("level", &self.level)
            .field("voice_activity", &self.voice_activity)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioMeta {
    pub meta: gst::GstMeta,
    pub info: GstAudioInfo,
    pub samples: size_t,
    pub offsets: *mut size_t,
    pub priv_offsets_arr: [size_t; 8],
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioMeta @ {self:p}"))
            .field("meta", &self.meta)
            .field("info", &self.info)
            .field("samples", &self.samples)
            .field("offsets", &self.offsets)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioQuantize {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioQuantize = _GstAudioQuantize;

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioResampler {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioResampler = _GstAudioResampler;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioRingBufferClass {
    pub parent_class: gst::GstObjectClass,
    pub open_device: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub acquire: Option<
        unsafe extern "C" fn(*mut GstAudioRingBuffer, *mut GstAudioRingBufferSpec) -> gboolean,
    >,
    pub release: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub close_device: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub start: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub pause: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub resume: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> gboolean>,
    pub delay: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer) -> c_uint>,
    pub activate: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer, gboolean) -> gboolean>,
    pub commit: Option<
        unsafe extern "C" fn(
            *mut GstAudioRingBuffer,
            *mut u64,
            *mut u8,
            c_int,
            c_int,
            *mut c_int,
        ) -> c_uint,
    >,
    pub clear_all: Option<unsafe extern "C" fn(*mut GstAudioRingBuffer)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioRingBufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioRingBufferClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("open_device", &self.open_device)
            .field("acquire", &self.acquire)
            .field("release", &self.release)
            .field("close_device", &self.close_device)
            .field("start", &self.start)
            .field("pause", &self.pause)
            .field("resume", &self.resume)
            .field("stop", &self.stop)
            .field("delay", &self.delay)
            .field("activate", &self.activate)
            .field("commit", &self.commit)
            .field("clear_all", &self.clear_all)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GstAudioRingBufferPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GstAudioRingBufferPrivate = _GstAudioRingBufferPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioRingBufferSpec {
    pub caps: *mut gst::GstCaps,
    pub type_: GstAudioRingBufferFormatType,
    pub info: GstAudioInfo,
    pub latency_time: u64,
    pub buffer_time: u64,
    pub segsize: c_int,
    pub segtotal: c_int,
    pub seglatency: c_int,
    pub ABI: GstAudioRingBufferSpec_ABI,
}

impl ::std::fmt::Debug for GstAudioRingBufferSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioRingBufferSpec @ {self:p}"))
            .field("caps", &self.caps)
            .field("type_", &self.type_)
            .field("info", &self.info)
            .field("latency_time", &self.latency_time)
            .field("buffer_time", &self.buffer_time)
            .field("segsize", &self.segsize)
            .field("segtotal", &self.segtotal)
            .field("seglatency", &self.seglatency)
            .field("ABI", &self.ABI)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioRingBufferSpec_ABI_abi {
    pub dsd_format: GstDsdFormat,
}

impl ::std::fmt::Debug for GstAudioRingBufferSpec_ABI_abi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioRingBufferSpec_ABI_abi @ {self:p}"))
            .field("dsd_format", &self.dsd_format)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioSinkClass {
    pub parent_class: GstAudioBaseSinkClass,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioSink) -> gboolean>,
    pub prepare:
        Option<unsafe extern "C" fn(*mut GstAudioSink, *mut GstAudioRingBufferSpec) -> gboolean>,
    pub unprepare: Option<unsafe extern "C" fn(*mut GstAudioSink) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioSink) -> gboolean>,
    pub write: Option<unsafe extern "C" fn(*mut GstAudioSink, gpointer, c_uint) -> c_int>,
    pub delay: Option<unsafe extern "C" fn(*mut GstAudioSink) -> c_uint>,
    pub reset: Option<unsafe extern "C" fn(*mut GstAudioSink)>,
    pub pause: Option<unsafe extern "C" fn(*mut GstAudioSink)>,
    pub resume: Option<unsafe extern "C" fn(*mut GstAudioSink)>,
    pub stop: Option<unsafe extern "C" fn(*mut GstAudioSink)>,
    pub extension: *mut GstAudioSinkClassExtension,
}

impl ::std::fmt::Debug for GstAudioSinkClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioSinkClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("open", &self.open)
            .field("prepare", &self.prepare)
            .field("unprepare", &self.unprepare)
            .field("close", &self.close)
            .field("write", &self.write)
            .field("delay", &self.delay)
            .field("reset", &self.reset)
            .field("pause", &self.pause)
            .field("resume", &self.resume)
            .field("stop", &self.stop)
            .field("extension", &self.extension)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioSinkClassExtension {
    pub clear_all: Option<unsafe extern "C" fn(*mut GstAudioSink)>,
}

impl ::std::fmt::Debug for GstAudioSinkClassExtension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioSinkClassExtension @ {self:p}"))
            .field("clear_all", &self.clear_all)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioSrcClass {
    pub parent_class: GstAudioBaseSrcClass,
    pub open: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> gboolean>,
    pub prepare:
        Option<unsafe extern "C" fn(*mut GstAudioSrc, *mut GstAudioRingBufferSpec) -> gboolean>,
    pub unprepare: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> gboolean>,
    pub close: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> gboolean>,
    pub read: Option<
        unsafe extern "C" fn(*mut GstAudioSrc, gpointer, c_uint, *mut gst::GstClockTime) -> c_uint,
    >,
    pub delay: Option<unsafe extern "C" fn(*mut GstAudioSrc) -> c_uint>,
    pub reset: Option<unsafe extern "C" fn(*mut GstAudioSrc)>,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioSrcClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioSrcClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("open", &self.open)
            .field("prepare", &self.prepare)
            .field("unprepare", &self.unprepare)
            .field("close", &self.close)
            .field("read", &self.read)
            .field("delay", &self.delay)
            .field("reset", &self.reset)
            .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GstAudioStreamAlign {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstAudioStreamAlign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioStreamAlign @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstDsdInfo {
    pub format: GstDsdFormat,
    pub rate: c_int,
    pub channels: c_int,
    pub layout: GstAudioLayout,
    pub reversed_bytes: gboolean,
    pub positions: [GstAudioChannelPosition; 64],
    pub flags: GstAudioFlags,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDsdInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDsdInfo @ {self:p}"))
            .field("format", &self.format)
            .field("rate", &self.rate)
            .field("channels", &self.channels)
            .field("layout", &self.layout)
            .field("reversed_bytes", &self.reversed_bytes)
            .field("flags", &self.flags)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstDsdPlaneOffsetMeta {
    pub meta: gst::GstMeta,
    pub num_channels: c_int,
    pub num_bytes_per_channel: size_t,
    pub offsets: *mut size_t,
    pub priv_offsets_arr: [size_t; 8],
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstDsdPlaneOffsetMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstDsdPlaneOffsetMeta @ {self:p}"))
            .field("meta", &self.meta)
            .field("num_channels", &self.num_channels)
            .field("num_bytes_per_channel", &self.num_bytes_per_channel)
            .field("offsets", &self.offsets)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstStreamVolumeInterface {
    pub iface: gobject::GTypeInterface,
}

impl ::std::fmt::Debug for GstStreamVolumeInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstStreamVolumeInterface @ {self:p}"))
            .field("iface", &self.iface)
            .finish()
    }
}

// Classes
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioAggregator {
    pub parent: gst_base::GstAggregator,
    pub current_caps: *mut gst::GstCaps,
    pub priv_: *mut GstAudioAggregatorPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioAggregator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioAggregator @ {self:p}"))
            .field("parent", &self.parent)
            .field("current_caps", &self.current_caps)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioAggregatorConvertPad {
    pub parent: GstAudioAggregatorPad,
    pub priv_: *mut GstAudioAggregatorConvertPadPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioAggregatorConvertPad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioAggregatorConvertPad @ {self:p}"))
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioAggregatorPad {
    pub parent: gst_base::GstAggregatorPad,
    pub info: GstAudioInfo,
    pub priv_: *mut GstAudioAggregatorPadPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioAggregatorPad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioAggregatorPad @ {self:p}"))
            .field("parent", &self.parent)
            .field("info", &self.info)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioBaseSink {
    pub element: gst_base::GstBaseSink,
    pub ringbuffer: *mut GstAudioRingBuffer,
    pub buffer_time: u64,
    pub latency_time: u64,
    pub next_sample: u64,
    pub provided_clock: *mut gst::GstClock,
    pub eos_rendering: gboolean,
    pub priv_: *mut GstAudioBaseSinkPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioBaseSink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioBaseSink @ {self:p}"))
            .field("element", &self.element)
            .field("ringbuffer", &self.ringbuffer)
            .field("buffer_time", &self.buffer_time)
            .field("latency_time", &self.latency_time)
            .field("next_sample", &self.next_sample)
            .field("provided_clock", &self.provided_clock)
            .field("eos_rendering", &self.eos_rendering)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioBaseSrc {
    pub element: gst_base::GstPushSrc,
    pub ringbuffer: *mut GstAudioRingBuffer,
    pub buffer_time: gst::GstClockTime,
    pub latency_time: gst::GstClockTime,
    pub next_sample: u64,
    pub clock: *mut gst::GstClock,
    pub priv_: *mut GstAudioBaseSrcPrivate,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioBaseSrc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioBaseSrc @ {self:p}"))
            .field("element", &self.element)
            .field("ringbuffer", &self.ringbuffer)
            .field("buffer_time", &self.buffer_time)
            .field("latency_time", &self.latency_time)
            .field("next_sample", &self.next_sample)
            .field("clock", &self.clock)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioCdSrc {
    pub pushsrc: gst_base::GstPushSrc,
    pub tags: *mut gst::GstTagList,
    pub priv_: *mut GstAudioCdSrcPrivate,
    pub _gst_reserved1: [c_uint; 2],
    pub _gst_reserved2: [gpointer; 2],
}

impl ::std::fmt::Debug for GstAudioCdSrc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioCdSrc @ {self:p}"))
            .field("pushsrc", &self.pushsrc)
            .field("tags", &self.tags)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioClock {
    pub clock: gst::GstSystemClock,
    pub func: GstAudioClockGetTimeFunc,
    pub user_data: gpointer,
    pub destroy_notify: glib::GDestroyNotify,
    pub last_time: gst::GstClockTime,
    pub time_offset: gst::GstClockTimeDiff,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioClock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioClock @ {self:p}"))
            .field("clock", &self.clock)
            .field("func", &self.func)
            .field("user_data", &self.user_data)
            .field("destroy_notify", &self.destroy_notify)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioDecoder {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub stream_lock: glib::GRecMutex,
    pub input_segment: gst::GstSegment,
    pub output_segment: gst::GstSegment,
    pub priv_: *mut GstAudioDecoderPrivate,
    pub _gst_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GstAudioDecoder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioDecoder @ {self:p}"))
            .field("element", &self.element)
            .field("sinkpad", &self.sinkpad)
            .field("srcpad", &self.srcpad)
            .field("stream_lock", &self.stream_lock)
            .field("input_segment", &self.input_segment)
            .field("output_segment", &self.output_segment)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioEncoder {
    pub element: gst::GstElement,
    pub sinkpad: *mut gst::GstPad,
    pub srcpad: *mut gst::GstPad,
    pub stream_lock: glib::GRecMutex,
    pub input_segment: gst::GstSegment,
    pub output_segment: gst::GstSegment,
    pub priv_: *mut GstAudioEncoderPrivate,
    pub _gst_reserved: [gpointer; 20],
}

impl ::std::fmt::Debug for GstAudioEncoder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioEncoder @ {self:p}"))
            .field("element", &self.element)
            .field("sinkpad", &self.sinkpad)
            .field("srcpad", &self.srcpad)
            .field("stream_lock", &self.stream_lock)
            .field("input_segment", &self.input_segment)
            .field("output_segment", &self.output_segment)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioFilter {
    pub basetransform: gst_base::GstBaseTransform,
    pub info: GstAudioInfo,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioFilter @ {self:p}"))
            .field("basetransform", &self.basetransform)
            .field("info", &self.info)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioRingBuffer {
    pub object: gst::GstObject,
    pub cond: glib::GCond,
    pub open: gboolean,
    pub acquired: gboolean,
    pub memory: *mut u8,
    pub size: size_t,
    pub timestamps: *mut gst::GstClockTime,
    pub spec: GstAudioRingBufferSpec,
    pub samples_per_seg: c_int,
    pub empty_seg: *mut u8,
    pub state: c_int,
    pub segdone: c_int,
    pub segbase: c_int,
    pub waiting: c_int,
    pub callback: GstAudioRingBufferCallback,
    pub cb_data: gpointer,
    pub need_reorder: gboolean,
    pub channel_reorder_map: [c_int; 64],
    pub flushing: gboolean,
    pub may_start: c_int,
    pub active: gboolean,
    pub cb_data_notify: glib::GDestroyNotify,
    pub priv_: *mut GstAudioRingBufferPrivate,
    pub _gst_reserved: [gpointer; 2],
}

impl ::std::fmt::Debug for GstAudioRingBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioRingBuffer @ {self:p}"))
            .field("object", &self.object)
            .field("cond", &self.cond)
            .field("open", &self.open)
            .field("acquired", &self.acquired)
            .field("memory", &self.memory)
            .field("size", &self.size)
            .field("spec", &self.spec)
            .field("samples_per_seg", &self.samples_per_seg)
            .field("empty_seg", &self.empty_seg)
            .field("state", &self.state)
            .field("segdone", &self.segdone)
            .field("segbase", &self.segbase)
            .field("waiting", &self.waiting)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioSink {
    pub element: GstAudioBaseSink,
    pub thread: *mut glib::GThread,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioSink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioSink @ {self:p}"))
            .field("element", &self.element)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GstAudioSrc {
    pub element: GstAudioBaseSrc,
    pub thread: *mut glib::GThread,
    pub _gst_reserved: [gpointer; 4],
}

impl ::std::fmt::Debug for GstAudioSrc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GstAudioSrc @ {self:p}"))
            .field("element", &self.element)
            .finish()
    }
}

// Interfaces
#[repr(C)]
#[allow(dead_code)]
pub struct GstStreamVolume {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GstStreamVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GstStreamVolume @ {self:p}")
    }
}

extern "C" {

    //=========================================================================
    // GstAudioBaseSinkDiscontReason
    //=========================================================================
    pub fn gst_audio_base_sink_discont_reason_get_type() -> GType;

    //=========================================================================
    // GstAudioBaseSinkSlaveMethod
    //=========================================================================
    pub fn gst_audio_base_sink_slave_method_get_type() -> GType;

    //=========================================================================
    // GstAudioBaseSrcSlaveMethod
    //=========================================================================
    pub fn gst_audio_base_src_slave_method_get_type() -> GType;

    //=========================================================================
    // GstAudioCdSrcMode
    //=========================================================================
    pub fn gst_audio_cd_src_mode_get_type() -> GType;

    //=========================================================================
    // GstAudioChannelPosition
    //=========================================================================
    pub fn gst_audio_channel_position_get_type() -> GType;

    //=========================================================================
    // GstAudioDitherMethod
    //=========================================================================
    pub fn gst_audio_dither_method_get_type() -> GType;

    //=========================================================================
    // GstAudioFormat
    //=========================================================================
    pub fn gst_audio_format_get_type() -> GType;
    pub fn gst_audio_format_build_integer(
        sign: gboolean,
        endianness: c_int,
        width: c_int,
        depth: c_int,
    ) -> GstAudioFormat;
    pub fn gst_audio_format_fill_silence(
        info: *const GstAudioFormatInfo,
        dest: gpointer,
        length: size_t,
    );
    pub fn gst_audio_format_from_string(format: *const c_char) -> GstAudioFormat;
    pub fn gst_audio_format_get_info(format: GstAudioFormat) -> *const GstAudioFormatInfo;
    pub fn gst_audio_format_to_string(format: GstAudioFormat) -> *const c_char;

    //=========================================================================
    // GstAudioLayout
    //=========================================================================
    pub fn gst_audio_layout_get_type() -> GType;

    //=========================================================================
    // GstAudioNoiseShapingMethod
    //=========================================================================
    pub fn gst_audio_noise_shaping_method_get_type() -> GType;

    //=========================================================================
    // GstAudioResamplerFilterInterpolation
    //=========================================================================
    pub fn gst_audio_resampler_filter_interpolation_get_type() -> GType;

    //=========================================================================
    // GstAudioResamplerFilterMode
    //=========================================================================
    pub fn gst_audio_resampler_filter_mode_get_type() -> GType;

    //=========================================================================
    // GstAudioResamplerMethod
    //=========================================================================
    pub fn gst_audio_resampler_method_get_type() -> GType;

    //=========================================================================
    // GstAudioRingBufferFormatType
    //=========================================================================
    pub fn gst_audio_ring_buffer_format_type_get_type() -> GType;

    //=========================================================================
    // GstAudioRingBufferState
    //=========================================================================
    pub fn gst_audio_ring_buffer_state_get_type() -> GType;

    //=========================================================================
    // GstDsdFormat
    //=========================================================================
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_format_get_type() -> GType;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_format_from_string(str: *const c_char) -> GstDsdFormat;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_format_get_width(format: GstDsdFormat) -> c_uint;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_format_to_string(format: GstDsdFormat) -> *const c_char;

    //=========================================================================
    // GstAudioChannelMixerFlags
    //=========================================================================
    pub fn gst_audio_channel_mixer_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioConverterFlags
    //=========================================================================
    pub fn gst_audio_converter_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioFlags
    //=========================================================================
    pub fn gst_audio_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioFormatFlags
    //=========================================================================
    pub fn gst_audio_format_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioPackFlags
    //=========================================================================
    pub fn gst_audio_pack_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioQuantizeFlags
    //=========================================================================
    pub fn gst_audio_quantize_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioResamplerFlags
    //=========================================================================
    pub fn gst_audio_resampler_flags_get_type() -> GType;

    //=========================================================================
    // GstAudioBuffer
    //=========================================================================
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn gst_audio_buffer_unmap(buffer: *mut GstAudioBuffer);
    pub fn gst_audio_buffer_clip(
        buffer: *mut gst::GstBuffer,
        segment: *const gst::GstSegment,
        rate: c_int,
        bpf: c_int,
    ) -> *mut gst::GstBuffer;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn gst_audio_buffer_map(
        buffer: *mut GstAudioBuffer,
        info: *const GstAudioInfo,
        gstbuffer: *mut gst::GstBuffer,
        flags: gst::GstMapFlags,
    ) -> gboolean;
    pub fn gst_audio_buffer_reorder_channels(
        buffer: *mut gst::GstBuffer,
        format: GstAudioFormat,
        channels: c_int,
        from: *const GstAudioChannelPosition,
        to: *const GstAudioChannelPosition,
    ) -> gboolean;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn gst_audio_buffer_truncate(
        buffer: *mut gst::GstBuffer,
        bpf: c_int,
        trim: size_t,
        samples: size_t,
    ) -> *mut gst::GstBuffer;

    //=========================================================================
    // GstAudioChannelMixer
    //=========================================================================
    pub fn gst_audio_channel_mixer_free(mix: *mut GstAudioChannelMixer);
    pub fn gst_audio_channel_mixer_is_passthrough(mix: *mut GstAudioChannelMixer) -> gboolean;
    pub fn gst_audio_channel_mixer_samples(
        mix: *mut GstAudioChannelMixer,
        in_: *const gpointer,
        out: *mut gpointer,
        samples: c_int,
    );
    pub fn gst_audio_channel_mixer_new(
        flags: GstAudioChannelMixerFlags,
        format: GstAudioFormat,
        in_channels: c_int,
        in_position: *mut GstAudioChannelPosition,
        out_channels: c_int,
        out_position: *mut GstAudioChannelPosition,
    ) -> *mut GstAudioChannelMixer;
    pub fn gst_audio_channel_mixer_new_with_matrix(
        flags: GstAudioChannelMixerFlags,
        format: GstAudioFormat,
        in_channels: c_int,
        out_channels: c_int,
        matrix: *mut *mut c_float,
    ) -> *mut GstAudioChannelMixer;

    //=========================================================================
    // GstAudioClippingMeta
    //=========================================================================
    pub fn gst_audio_clipping_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstAudioConverter
    //=========================================================================
    pub fn gst_audio_converter_get_type() -> GType;
    pub fn gst_audio_converter_new(
        flags: GstAudioConverterFlags,
        in_info: *mut GstAudioInfo,
        out_info: *mut GstAudioInfo,
        config: *mut gst::GstStructure,
    ) -> *mut GstAudioConverter;
    pub fn gst_audio_converter_convert(
        convert: *mut GstAudioConverter,
        flags: GstAudioConverterFlags,
        in_: gpointer,
        in_size: size_t,
        out: *mut u8,
        out_size: *mut size_t,
    ) -> gboolean;
    pub fn gst_audio_converter_free(convert: *mut GstAudioConverter);
    pub fn gst_audio_converter_get_config(
        convert: *mut GstAudioConverter,
        in_rate: *mut c_int,
        out_rate: *mut c_int,
    ) -> *const gst::GstStructure;
    pub fn gst_audio_converter_get_in_frames(
        convert: *mut GstAudioConverter,
        out_frames: size_t,
    ) -> size_t;
    pub fn gst_audio_converter_get_max_latency(convert: *mut GstAudioConverter) -> size_t;
    pub fn gst_audio_converter_get_out_frames(
        convert: *mut GstAudioConverter,
        in_frames: size_t,
    ) -> size_t;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn gst_audio_converter_is_passthrough(convert: *mut GstAudioConverter) -> gboolean;
    pub fn gst_audio_converter_reset(convert: *mut GstAudioConverter);
    pub fn gst_audio_converter_samples(
        convert: *mut GstAudioConverter,
        flags: GstAudioConverterFlags,
        in_: *mut gpointer,
        in_frames: size_t,
        out: *mut gpointer,
        out_frames: size_t,
    ) -> gboolean;
    pub fn gst_audio_converter_supports_inplace(convert: *mut GstAudioConverter) -> gboolean;
    pub fn gst_audio_converter_update_config(
        convert: *mut GstAudioConverter,
        in_rate: c_int,
        out_rate: c_int,
        config: *mut gst::GstStructure,
    ) -> gboolean;

    //=========================================================================
    // GstAudioDownmixMeta
    //=========================================================================
    pub fn gst_audio_downmix_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstAudioFilterClass
    //=========================================================================
    pub fn gst_audio_filter_class_add_pad_templates(
        klass: *mut GstAudioFilterClass,
        allowed_caps: *mut gst::GstCaps,
    );

    //=========================================================================
    // GstAudioFormatInfo
    //=========================================================================
    pub fn gst_audio_format_info_get_type() -> GType;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn gst_audio_format_info_fill_silence(
        info: *const GstAudioFormatInfo,
        dest: gpointer,
        length: size_t,
    );

    //=========================================================================
    // GstAudioInfo
    //=========================================================================
    pub fn gst_audio_info_get_type() -> GType;
    pub fn gst_audio_info_new() -> *mut GstAudioInfo;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn gst_audio_info_new_from_caps(caps: *const gst::GstCaps) -> *mut GstAudioInfo;
    pub fn gst_audio_info_convert(
        info: *const GstAudioInfo,
        src_fmt: gst::GstFormat,
        src_val: i64,
        dest_fmt: gst::GstFormat,
        dest_val: *mut i64,
    ) -> gboolean;
    pub fn gst_audio_info_copy(info: *const GstAudioInfo) -> *mut GstAudioInfo;
    pub fn gst_audio_info_free(info: *mut GstAudioInfo);
    pub fn gst_audio_info_is_equal(
        info: *const GstAudioInfo,
        other: *const GstAudioInfo,
    ) -> gboolean;
    pub fn gst_audio_info_set_format(
        info: *mut GstAudioInfo,
        format: GstAudioFormat,
        rate: c_int,
        channels: c_int,
        position: *const [GstAudioChannelPosition; 64],
    );
    pub fn gst_audio_info_to_caps(info: *const GstAudioInfo) -> *mut gst::GstCaps;
    pub fn gst_audio_info_from_caps(info: *mut GstAudioInfo, caps: *const gst::GstCaps)
        -> gboolean;
    pub fn gst_audio_info_init(info: *mut GstAudioInfo);

    //=========================================================================
    // GstAudioLevelMeta
    //=========================================================================
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn gst_audio_level_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstAudioMeta
    //=========================================================================
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn gst_audio_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstAudioQuantize
    //=========================================================================
    pub fn gst_audio_quantize_free(quant: *mut GstAudioQuantize);
    pub fn gst_audio_quantize_reset(quant: *mut GstAudioQuantize);
    pub fn gst_audio_quantize_samples(
        quant: *mut GstAudioQuantize,
        in_: *const gpointer,
        out: *mut gpointer,
        samples: c_uint,
    );
    pub fn gst_audio_quantize_new(
        dither: GstAudioDitherMethod,
        ns: GstAudioNoiseShapingMethod,
        flags: GstAudioQuantizeFlags,
        format: GstAudioFormat,
        channels: c_uint,
        quantizer: c_uint,
    ) -> *mut GstAudioQuantize;

    //=========================================================================
    // GstAudioResampler
    //=========================================================================
    pub fn gst_audio_resampler_free(resampler: *mut GstAudioResampler);
    pub fn gst_audio_resampler_get_in_frames(
        resampler: *mut GstAudioResampler,
        out_frames: size_t,
    ) -> size_t;
    pub fn gst_audio_resampler_get_max_latency(resampler: *mut GstAudioResampler) -> size_t;
    pub fn gst_audio_resampler_get_out_frames(
        resampler: *mut GstAudioResampler,
        in_frames: size_t,
    ) -> size_t;
    pub fn gst_audio_resampler_resample(
        resampler: *mut GstAudioResampler,
        in_: *mut gpointer,
        in_frames: size_t,
        out: *mut gpointer,
        out_frames: size_t,
    );
    pub fn gst_audio_resampler_reset(resampler: *mut GstAudioResampler);
    pub fn gst_audio_resampler_update(
        resampler: *mut GstAudioResampler,
        in_rate: c_int,
        out_rate: c_int,
        options: *mut gst::GstStructure,
    ) -> gboolean;
    pub fn gst_audio_resampler_new(
        method: GstAudioResamplerMethod,
        flags: GstAudioResamplerFlags,
        format: GstAudioFormat,
        channels: c_int,
        in_rate: c_int,
        out_rate: c_int,
        options: *mut gst::GstStructure,
    ) -> *mut GstAudioResampler;
    pub fn gst_audio_resampler_options_set_quality(
        method: GstAudioResamplerMethod,
        quality: c_uint,
        in_rate: c_int,
        out_rate: c_int,
        options: *mut gst::GstStructure,
    );

    //=========================================================================
    // GstAudioStreamAlign
    //=========================================================================
    pub fn gst_audio_stream_align_get_type() -> GType;
    pub fn gst_audio_stream_align_new(
        rate: c_int,
        alignment_threshold: gst::GstClockTime,
        discont_wait: gst::GstClockTime,
    ) -> *mut GstAudioStreamAlign;
    pub fn gst_audio_stream_align_copy(
        align: *const GstAudioStreamAlign,
    ) -> *mut GstAudioStreamAlign;
    pub fn gst_audio_stream_align_free(align: *mut GstAudioStreamAlign);
    pub fn gst_audio_stream_align_get_alignment_threshold(
        align: *const GstAudioStreamAlign,
    ) -> gst::GstClockTime;
    pub fn gst_audio_stream_align_get_discont_wait(
        align: *const GstAudioStreamAlign,
    ) -> gst::GstClockTime;
    pub fn gst_audio_stream_align_get_rate(align: *const GstAudioStreamAlign) -> c_int;
    pub fn gst_audio_stream_align_get_samples_since_discont(
        align: *const GstAudioStreamAlign,
    ) -> u64;
    pub fn gst_audio_stream_align_get_timestamp_at_discont(
        align: *const GstAudioStreamAlign,
    ) -> gst::GstClockTime;
    pub fn gst_audio_stream_align_mark_discont(align: *mut GstAudioStreamAlign);
    pub fn gst_audio_stream_align_process(
        align: *mut GstAudioStreamAlign,
        discont: gboolean,
        timestamp: gst::GstClockTime,
        n_samples: c_uint,
        out_timestamp: *mut gst::GstClockTime,
        out_duration: *mut gst::GstClockTime,
        out_sample_position: *mut u64,
    ) -> gboolean;
    pub fn gst_audio_stream_align_set_alignment_threshold(
        align: *mut GstAudioStreamAlign,
        alignment_threshold: gst::GstClockTime,
    );
    pub fn gst_audio_stream_align_set_discont_wait(
        align: *mut GstAudioStreamAlign,
        discont_wait: gst::GstClockTime,
    );
    pub fn gst_audio_stream_align_set_rate(align: *mut GstAudioStreamAlign, rate: c_int);

    //=========================================================================
    // GstDsdInfo
    //=========================================================================
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_get_type() -> GType;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_new() -> *mut GstDsdInfo;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_new_from_caps(caps: *const gst::GstCaps) -> *mut GstDsdInfo;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_copy(info: *const GstDsdInfo) -> *mut GstDsdInfo;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_free(info: *mut GstDsdInfo);
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_is_equal(info: *const GstDsdInfo, other: *const GstDsdInfo) -> gboolean;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_set_format(
        info: *mut GstDsdInfo,
        format: GstDsdFormat,
        rate: c_int,
        channels: c_int,
        positions: *const [GstAudioChannelPosition; 64],
    );
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_to_caps(info: *const GstDsdInfo) -> *mut gst::GstCaps;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_from_caps(info: *mut GstDsdInfo, caps: *const gst::GstCaps) -> gboolean;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_info_init(info: *mut GstDsdInfo);

    //=========================================================================
    // GstDsdPlaneOffsetMeta
    //=========================================================================
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_plane_offset_meta_get_info() -> *const gst::GstMetaInfo;

    //=========================================================================
    // GstAudioAggregator
    //=========================================================================
    pub fn gst_audio_aggregator_get_type() -> GType;
    pub fn gst_audio_aggregator_set_sink_caps(
        aagg: *mut GstAudioAggregator,
        pad: *mut GstAudioAggregatorPad,
        caps: *mut gst::GstCaps,
    );

    //=========================================================================
    // GstAudioAggregatorConvertPad
    //=========================================================================
    pub fn gst_audio_aggregator_convert_pad_get_type() -> GType;

    //=========================================================================
    // GstAudioAggregatorPad
    //=========================================================================
    pub fn gst_audio_aggregator_pad_get_type() -> GType;

    //=========================================================================
    // GstAudioBaseSink
    //=========================================================================
    pub fn gst_audio_base_sink_get_type() -> GType;
    pub fn gst_audio_base_sink_create_ringbuffer(
        sink: *mut GstAudioBaseSink,
    ) -> *mut GstAudioRingBuffer;
    pub fn gst_audio_base_sink_get_alignment_threshold(
        sink: *mut GstAudioBaseSink,
    ) -> gst::GstClockTime;
    pub fn gst_audio_base_sink_get_discont_wait(sink: *mut GstAudioBaseSink) -> gst::GstClockTime;
    pub fn gst_audio_base_sink_get_drift_tolerance(sink: *mut GstAudioBaseSink) -> i64;
    pub fn gst_audio_base_sink_get_provide_clock(sink: *mut GstAudioBaseSink) -> gboolean;
    pub fn gst_audio_base_sink_get_slave_method(
        sink: *mut GstAudioBaseSink,
    ) -> GstAudioBaseSinkSlaveMethod;
    pub fn gst_audio_base_sink_report_device_failure(sink: *mut GstAudioBaseSink);
    pub fn gst_audio_base_sink_set_alignment_threshold(
        sink: *mut GstAudioBaseSink,
        alignment_threshold: gst::GstClockTime,
    );
    pub fn gst_audio_base_sink_set_custom_slaving_callback(
        sink: *mut GstAudioBaseSink,
        callback: GstAudioBaseSinkCustomSlavingCallback,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_audio_base_sink_set_discont_wait(
        sink: *mut GstAudioBaseSink,
        discont_wait: gst::GstClockTime,
    );
    pub fn gst_audio_base_sink_set_drift_tolerance(
        sink: *mut GstAudioBaseSink,
        drift_tolerance: i64,
    );
    pub fn gst_audio_base_sink_set_provide_clock(sink: *mut GstAudioBaseSink, provide: gboolean);
    pub fn gst_audio_base_sink_set_slave_method(
        sink: *mut GstAudioBaseSink,
        method: GstAudioBaseSinkSlaveMethod,
    );

    //=========================================================================
    // GstAudioBaseSrc
    //=========================================================================
    pub fn gst_audio_base_src_get_type() -> GType;
    pub fn gst_audio_base_src_create_ringbuffer(
        src: *mut GstAudioBaseSrc,
    ) -> *mut GstAudioRingBuffer;
    pub fn gst_audio_base_src_get_provide_clock(src: *mut GstAudioBaseSrc) -> gboolean;
    pub fn gst_audio_base_src_get_slave_method(
        src: *mut GstAudioBaseSrc,
    ) -> GstAudioBaseSrcSlaveMethod;
    pub fn gst_audio_base_src_set_provide_clock(src: *mut GstAudioBaseSrc, provide: gboolean);
    pub fn gst_audio_base_src_set_slave_method(
        src: *mut GstAudioBaseSrc,
        method: GstAudioBaseSrcSlaveMethod,
    );

    //=========================================================================
    // GstAudioCdSrc
    //=========================================================================
    pub fn gst_audio_cd_src_get_type() -> GType;
    pub fn gst_audio_cd_src_add_track(
        src: *mut GstAudioCdSrc,
        track: *mut GstAudioCdSrcTrack,
    ) -> gboolean;

    //=========================================================================
    // GstAudioClock
    //=========================================================================
    pub fn gst_audio_clock_get_type() -> GType;
    pub fn gst_audio_clock_new(
        name: *const c_char,
        func: GstAudioClockGetTimeFunc,
        user_data: gpointer,
        destroy_notify: glib::GDestroyNotify,
    ) -> *mut gst::GstClock;
    pub fn gst_audio_clock_adjust(
        clock: *mut GstAudioClock,
        time: gst::GstClockTime,
    ) -> gst::GstClockTime;
    pub fn gst_audio_clock_get_time(clock: *mut GstAudioClock) -> gst::GstClockTime;
    pub fn gst_audio_clock_invalidate(clock: *mut GstAudioClock);
    pub fn gst_audio_clock_reset(clock: *mut GstAudioClock, time: gst::GstClockTime);

    //=========================================================================
    // GstAudioDecoder
    //=========================================================================
    pub fn gst_audio_decoder_get_type() -> GType;
    pub fn gst_audio_decoder_allocate_output_buffer(
        dec: *mut GstAudioDecoder,
        size: size_t,
    ) -> *mut gst::GstBuffer;
    pub fn gst_audio_decoder_finish_frame(
        dec: *mut GstAudioDecoder,
        buf: *mut gst::GstBuffer,
        frames: c_int,
    ) -> gst::GstFlowReturn;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn gst_audio_decoder_finish_subframe(
        dec: *mut GstAudioDecoder,
        buf: *mut gst::GstBuffer,
    ) -> gst::GstFlowReturn;
    pub fn gst_audio_decoder_get_allocator(
        dec: *mut GstAudioDecoder,
        allocator: *mut *mut gst::GstAllocator,
        params: *mut gst::GstAllocationParams,
    );
    pub fn gst_audio_decoder_get_audio_info(dec: *mut GstAudioDecoder) -> *mut GstAudioInfo;
    pub fn gst_audio_decoder_get_delay(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_drainable(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_get_estimate_rate(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_latency(
        dec: *mut GstAudioDecoder,
        min: *mut gst::GstClockTime,
        max: *mut gst::GstClockTime,
    );
    pub fn gst_audio_decoder_get_max_errors(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_min_latency(dec: *mut GstAudioDecoder) -> gst::GstClockTime;
    pub fn gst_audio_decoder_get_needs_format(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_get_parse_state(
        dec: *mut GstAudioDecoder,
        sync: *mut gboolean,
        eos: *mut gboolean,
    );
    pub fn gst_audio_decoder_get_plc(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_get_plc_aware(dec: *mut GstAudioDecoder) -> c_int;
    pub fn gst_audio_decoder_get_tolerance(dec: *mut GstAudioDecoder) -> gst::GstClockTime;
    pub fn gst_audio_decoder_merge_tags(
        dec: *mut GstAudioDecoder,
        tags: *const gst::GstTagList,
        mode: gst::GstTagMergeMode,
    );
    pub fn gst_audio_decoder_negotiate(dec: *mut GstAudioDecoder) -> gboolean;
    pub fn gst_audio_decoder_proxy_getcaps(
        decoder: *mut GstAudioDecoder,
        caps: *mut gst::GstCaps,
        filter: *mut gst::GstCaps,
    ) -> *mut gst::GstCaps;
    pub fn gst_audio_decoder_set_allocation_caps(
        dec: *mut GstAudioDecoder,
        allocation_caps: *mut gst::GstCaps,
    );
    pub fn gst_audio_decoder_set_drainable(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_estimate_rate(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_latency(
        dec: *mut GstAudioDecoder,
        min: gst::GstClockTime,
        max: gst::GstClockTime,
    );
    pub fn gst_audio_decoder_set_max_errors(dec: *mut GstAudioDecoder, num: c_int);
    pub fn gst_audio_decoder_set_min_latency(dec: *mut GstAudioDecoder, num: gst::GstClockTime);
    pub fn gst_audio_decoder_set_needs_format(dec: *mut GstAudioDecoder, enabled: gboolean);
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn gst_audio_decoder_set_output_caps(
        dec: *mut GstAudioDecoder,
        caps: *mut gst::GstCaps,
    ) -> gboolean;
    pub fn gst_audio_decoder_set_output_format(
        dec: *mut GstAudioDecoder,
        info: *const GstAudioInfo,
    ) -> gboolean;
    pub fn gst_audio_decoder_set_plc(dec: *mut GstAudioDecoder, enabled: gboolean);
    pub fn gst_audio_decoder_set_plc_aware(dec: *mut GstAudioDecoder, plc: gboolean);
    pub fn gst_audio_decoder_set_tolerance(dec: *mut GstAudioDecoder, tolerance: gst::GstClockTime);
    pub fn gst_audio_decoder_set_use_default_pad_acceptcaps(
        decoder: *mut GstAudioDecoder,
        use_: gboolean,
    );

    //=========================================================================
    // GstAudioEncoder
    //=========================================================================
    pub fn gst_audio_encoder_get_type() -> GType;
    pub fn gst_audio_encoder_allocate_output_buffer(
        enc: *mut GstAudioEncoder,
        size: size_t,
    ) -> *mut gst::GstBuffer;
    pub fn gst_audio_encoder_finish_frame(
        enc: *mut GstAudioEncoder,
        buffer: *mut gst::GstBuffer,
        samples: c_int,
    ) -> gst::GstFlowReturn;
    pub fn gst_audio_encoder_get_allocator(
        enc: *mut GstAudioEncoder,
        allocator: *mut *mut gst::GstAllocator,
        params: *mut gst::GstAllocationParams,
    );
    pub fn gst_audio_encoder_get_audio_info(enc: *mut GstAudioEncoder) -> *mut GstAudioInfo;
    pub fn gst_audio_encoder_get_drainable(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_frame_max(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_frame_samples_max(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_frame_samples_min(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_hard_min(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_hard_resync(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_latency(
        enc: *mut GstAudioEncoder,
        min: *mut gst::GstClockTime,
        max: *mut gst::GstClockTime,
    );
    pub fn gst_audio_encoder_get_lookahead(enc: *mut GstAudioEncoder) -> c_int;
    pub fn gst_audio_encoder_get_mark_granule(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_perfect_timestamp(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_get_tolerance(enc: *mut GstAudioEncoder) -> gst::GstClockTime;
    pub fn gst_audio_encoder_merge_tags(
        enc: *mut GstAudioEncoder,
        tags: *const gst::GstTagList,
        mode: gst::GstTagMergeMode,
    );
    pub fn gst_audio_encoder_negotiate(enc: *mut GstAudioEncoder) -> gboolean;
    pub fn gst_audio_encoder_proxy_getcaps(
        enc: *mut GstAudioEncoder,
        caps: *mut gst::GstCaps,
        filter: *mut gst::GstCaps,
    ) -> *mut gst::GstCaps;
    pub fn gst_audio_encoder_set_allocation_caps(
        enc: *mut GstAudioEncoder,
        allocation_caps: *mut gst::GstCaps,
    );
    pub fn gst_audio_encoder_set_drainable(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_frame_max(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_frame_samples_max(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_frame_samples_min(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_hard_min(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_hard_resync(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_headers(enc: *mut GstAudioEncoder, headers: *mut glib::GList);
    pub fn gst_audio_encoder_set_latency(
        enc: *mut GstAudioEncoder,
        min: gst::GstClockTime,
        max: gst::GstClockTime,
    );
    pub fn gst_audio_encoder_set_lookahead(enc: *mut GstAudioEncoder, num: c_int);
    pub fn gst_audio_encoder_set_mark_granule(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_output_format(
        enc: *mut GstAudioEncoder,
        caps: *mut gst::GstCaps,
    ) -> gboolean;
    pub fn gst_audio_encoder_set_perfect_timestamp(enc: *mut GstAudioEncoder, enabled: gboolean);
    pub fn gst_audio_encoder_set_tolerance(enc: *mut GstAudioEncoder, tolerance: gst::GstClockTime);

    //=========================================================================
    // GstAudioFilter
    //=========================================================================
    pub fn gst_audio_filter_get_type() -> GType;

    //=========================================================================
    // GstAudioRingBuffer
    //=========================================================================
    pub fn gst_audio_ring_buffer_get_type() -> GType;
    pub fn gst_audio_ring_buffer_debug_spec_buff(spec: *mut GstAudioRingBufferSpec);
    pub fn gst_audio_ring_buffer_debug_spec_caps(spec: *mut GstAudioRingBufferSpec);
    pub fn gst_audio_ring_buffer_parse_caps(
        spec: *mut GstAudioRingBufferSpec,
        caps: *mut gst::GstCaps,
    ) -> gboolean;
    pub fn gst_audio_ring_buffer_acquire(
        buf: *mut GstAudioRingBuffer,
        spec: *mut GstAudioRingBufferSpec,
    ) -> gboolean;
    pub fn gst_audio_ring_buffer_activate(
        buf: *mut GstAudioRingBuffer,
        active: gboolean,
    ) -> gboolean;
    pub fn gst_audio_ring_buffer_advance(buf: *mut GstAudioRingBuffer, advance: c_uint);
    pub fn gst_audio_ring_buffer_clear(buf: *mut GstAudioRingBuffer, segment: c_int);
    pub fn gst_audio_ring_buffer_clear_all(buf: *mut GstAudioRingBuffer);
    pub fn gst_audio_ring_buffer_close_device(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_commit(
        buf: *mut GstAudioRingBuffer,
        sample: *mut u64,
        data: *mut u8,
        in_samples: c_int,
        out_samples: c_int,
        accum: *mut c_int,
    ) -> c_uint;
    pub fn gst_audio_ring_buffer_convert(
        buf: *mut GstAudioRingBuffer,
        src_fmt: gst::GstFormat,
        src_val: i64,
        dest_fmt: gst::GstFormat,
        dest_val: *mut i64,
    ) -> gboolean;
    pub fn gst_audio_ring_buffer_delay(buf: *mut GstAudioRingBuffer) -> c_uint;
    pub fn gst_audio_ring_buffer_device_is_open(buf: *mut GstAudioRingBuffer) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn gst_audio_ring_buffer_get_segbase(buf: *mut GstAudioRingBuffer) -> u64;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn gst_audio_ring_buffer_get_segdone(buf: *mut GstAudioRingBuffer) -> u64;
    pub fn gst_audio_ring_buffer_is_acquired(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_is_active(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_is_flushing(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_may_start(buf: *mut GstAudioRingBuffer, allowed: gboolean);
    pub fn gst_audio_ring_buffer_open_device(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_pause(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_prepare_read(
        buf: *mut GstAudioRingBuffer,
        segment: *mut c_int,
        readptr: *mut *mut u8,
        len: *mut c_int,
    ) -> gboolean;
    pub fn gst_audio_ring_buffer_read(
        buf: *mut GstAudioRingBuffer,
        sample: u64,
        data: *mut u8,
        len: c_uint,
        timestamp: *mut gst::GstClockTime,
    ) -> c_uint;
    pub fn gst_audio_ring_buffer_release(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_samples_done(buf: *mut GstAudioRingBuffer) -> u64;
    pub fn gst_audio_ring_buffer_set_callback(
        buf: *mut GstAudioRingBuffer,
        cb: GstAudioRingBufferCallback,
        user_data: gpointer,
    );
    pub fn gst_audio_ring_buffer_set_callback_full(
        buf: *mut GstAudioRingBuffer,
        cb: GstAudioRingBufferCallback,
        user_data: gpointer,
        notify: glib::GDestroyNotify,
    );
    pub fn gst_audio_ring_buffer_set_channel_positions(
        buf: *mut GstAudioRingBuffer,
        position: *const GstAudioChannelPosition,
    );
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_audio_ring_buffer_set_errored(buf: *mut GstAudioRingBuffer);
    pub fn gst_audio_ring_buffer_set_flushing(buf: *mut GstAudioRingBuffer, flushing: gboolean);
    pub fn gst_audio_ring_buffer_set_sample(buf: *mut GstAudioRingBuffer, sample: u64);
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn gst_audio_ring_buffer_set_segdone(buf: *mut GstAudioRingBuffer, segdone: u64);
    pub fn gst_audio_ring_buffer_set_timestamp(
        buf: *mut GstAudioRingBuffer,
        readseg: c_int,
        timestamp: gst::GstClockTime,
    );
    pub fn gst_audio_ring_buffer_start(buf: *mut GstAudioRingBuffer) -> gboolean;
    pub fn gst_audio_ring_buffer_stop(buf: *mut GstAudioRingBuffer) -> gboolean;

    //=========================================================================
    // GstAudioSink
    //=========================================================================
    pub fn gst_audio_sink_get_type() -> GType;

    //=========================================================================
    // GstAudioSrc
    //=========================================================================
    pub fn gst_audio_src_get_type() -> GType;

    //=========================================================================
    // GstStreamVolume
    //=========================================================================
    pub fn gst_stream_volume_get_type() -> GType;
    pub fn gst_stream_volume_convert_volume(
        from: GstStreamVolumeFormat,
        to: GstStreamVolumeFormat,
        val: c_double,
    ) -> c_double;
    pub fn gst_stream_volume_get_mute(volume: *mut GstStreamVolume) -> gboolean;
    pub fn gst_stream_volume_get_volume(
        volume: *mut GstStreamVolume,
        format: GstStreamVolumeFormat,
    ) -> c_double;
    pub fn gst_stream_volume_set_mute(volume: *mut GstStreamVolume, mute: gboolean);
    pub fn gst_stream_volume_set_volume(
        volume: *mut GstStreamVolume,
        format: GstStreamVolumeFormat,
        val: c_double,
    );

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gst_audio_channel_get_fallback_mask(channels: c_int) -> u64;
    pub fn gst_audio_channel_positions_from_mask(
        channels: c_int,
        channel_mask: u64,
        position: *mut GstAudioChannelPosition,
    ) -> gboolean;
    pub fn gst_audio_channel_positions_to_mask(
        position: *const GstAudioChannelPosition,
        channels: c_int,
        force_order: gboolean,
        channel_mask: *mut u64,
    ) -> gboolean;
    pub fn gst_audio_channel_positions_to_string(
        position: *const GstAudioChannelPosition,
        channels: c_int,
    ) -> *mut c_char;
    pub fn gst_audio_channel_positions_to_valid_order(
        position: *mut GstAudioChannelPosition,
        channels: c_int,
    ) -> gboolean;
    pub fn gst_audio_check_valid_channel_positions(
        position: *const GstAudioChannelPosition,
        channels: c_int,
        force_order: gboolean,
    ) -> gboolean;
    pub fn gst_audio_clipping_meta_api_get_type() -> GType;
    pub fn gst_audio_downmix_meta_api_get_type() -> GType;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn gst_audio_formats_raw(len: *mut c_uint) -> *const GstAudioFormat;
    pub fn gst_audio_get_channel_reorder_map(
        channels: c_int,
        from: *const GstAudioChannelPosition,
        to: *const GstAudioChannelPosition,
        reorder_map: *mut c_int,
    ) -> gboolean;
    pub fn gst_audio_iec61937_frame_size(spec: *const GstAudioRingBufferSpec) -> c_uint;
    pub fn gst_audio_iec61937_payload(
        src: *const u8,
        src_n: c_uint,
        dst: *mut u8,
        dst_n: c_uint,
        spec: *const GstAudioRingBufferSpec,
        endianness: c_int,
    ) -> gboolean;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn gst_audio_level_meta_api_get_type() -> GType;
    #[cfg(feature = "v1_18")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_18")))]
    pub fn gst_audio_make_raw_caps(
        formats: *const GstAudioFormat,
        len: c_uint,
        layout: GstAudioLayout,
    ) -> *mut gst::GstCaps;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn gst_audio_meta_api_get_type() -> GType;
    pub fn gst_audio_reorder_channels(
        data: gpointer,
        size: size_t,
        format: GstAudioFormat,
        channels: c_int,
        from: *const GstAudioChannelPosition,
        to: *const GstAudioChannelPosition,
    ) -> gboolean;
    #[cfg(feature = "v1_26")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_26")))]
    pub fn gst_audio_reorder_channels_with_reorder_map(
        data: gpointer,
        size: size_t,
        bps: c_int,
        channels: c_int,
        reorder_map: *const c_int,
    );
    pub fn gst_buffer_add_audio_clipping_meta(
        buffer: *mut gst::GstBuffer,
        format: gst::GstFormat,
        start: u64,
        end: u64,
    ) -> *mut GstAudioClippingMeta;
    pub fn gst_buffer_add_audio_downmix_meta(
        buffer: *mut gst::GstBuffer,
        from_position: *const GstAudioChannelPosition,
        from_channels: c_int,
        to_position: *const GstAudioChannelPosition,
        to_channels: c_int,
        matrix: *mut *const c_float,
    ) -> *mut GstAudioDownmixMeta;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn gst_buffer_add_audio_level_meta(
        buffer: *mut gst::GstBuffer,
        level: u8,
        voice_activity: gboolean,
    ) -> *mut GstAudioLevelMeta;
    #[cfg(feature = "v1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_16")))]
    pub fn gst_buffer_add_audio_meta(
        buffer: *mut gst::GstBuffer,
        info: *const GstAudioInfo,
        samples: size_t,
        offsets: *mut size_t,
    ) -> *mut GstAudioMeta;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_buffer_add_dsd_plane_offset_meta(
        buffer: *mut gst::GstBuffer,
        num_channels: c_int,
        num_bytes_per_channel: size_t,
        offsets: *mut size_t,
    ) -> *mut GstDsdPlaneOffsetMeta;
    pub fn gst_buffer_get_audio_downmix_meta_for_channels(
        buffer: *mut gst::GstBuffer,
        to_position: *const GstAudioChannelPosition,
        to_channels: c_int,
    ) -> *mut GstAudioDownmixMeta;
    #[cfg(feature = "v1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_20")))]
    pub fn gst_buffer_get_audio_level_meta(buffer: *mut gst::GstBuffer) -> *mut GstAudioLevelMeta;
    #[cfg(feature = "v1_24")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_24")))]
    pub fn gst_dsd_convert(
        input_data: *const u8,
        output_data: *mut u8,
        input_format: GstDsdFormat,
        output_format: GstDsdFormat,
        input_layout: GstAudioLayout,
        output_layout: GstAudioLayout,
        input_plane_offsets: *const size_t,
        output_plane_offsets: *const size_t,
        num_dsd_bytes: size_t,
        num_channels: c_int,
        reverse_byte_bits: gboolean,
    );
    pub fn gst_dsd_plane_offset_meta_api_get_type() -> GType;

}
